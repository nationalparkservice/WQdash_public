---
title: "Water in Our Parks"
output:
  flexdashboard::flex_dashboard:
    theme: yeti  # theme options: default, cosmo, bootstrap, cerulean, journal, flatly, readable, spacelab, united, lumen, paper, sandstone, simplex, yeti. To allow bslib components in flexdashboard, only some themes have limited conflict, e.g., cosmo, shiny, default--but still problematic
    orientation: columns
    vertical_layout: fill
    horizontal_layout: fill
runtime: shiny
---

```{r global, include=FALSE}
# >>> PICK UP FROM HERE. WORKING FROM THIS COPY, WHICH DOES NOT HAVE THE BATCH. WQP IMPORTS SHOULD WORK IF NO CHARACTERISTIC FILTERS. ISSUE WITH THRESHOLD B/C IF DOESN'T INCLUDE SAMPLE FRACTION THEN SHOULD MATCH WITH PARAM REGARDLESS OF SAMPLE FRACTION.
  #      saveRDS(isolate(reactiveValuesToList(rv)), here::here("TEMP_rv.RDS"))
  # saveRDS(isolate(reactiveValuesToList(rv_param_temp)), here::here("TEMP_rv_param_temp.RDS"))
  # saveRDS(isolate(reactiveValuesToList(input)), here::here("TEMP_input.RDS"))

### HIGH PRIORITY
# > BREAK UP LARGE IMPORTS! Need informative message for large imports and possibly save to file in between?
# > Refresh map button should only show when there is a map. 
# > Imported data info tab should turn red once data are imported. SHould not show before? (or grayed out)
# > Pop-up should work from right clicking anywhere in circle not just dead center


### NEXT CHANGES:l
# > Default percentiles in bandaid bar shoudl just be q5 and q95p
# > When user selects all sites in park, highlight park darker yellow to show something happened
# > Offer an EPA threshold list??
# Rename all table columns nicely and consistently
# > Import
# -- Allow user to upload a shapefile or select a state (instead of park)
# -- NOAA precip data
# -- Upstream/downstream selection
# -- Start date for filter
# > Filter page input should have collapsing inputs just like Explore plots
# > Threshold import/setting should be moved to explore data threshold section
# > if a categorical parameter is selected, a warning/option to define categorical should show
# > Explore data page
# -- Add map toggle to show site labels; legend for colors
#If more than 3 plots showing on a page, need to show x-axis on all of them
# -- Give option to show data in 1-4 columns
# -- Percentile legend should say lowest X%, highest X%, etc. instead of below, above...
# > Incorporate EPA data cleaning/standardization functions (TADAShiny)


### UPCOMING CHANGES:
# > rnoaa is not available for R3.2. This package is going to be phased out in 2024, so keep an eye out
# > https://waterdata.usgs.gov/blog/wqx3/
# > A large update of dataRetrieval was just pushed to GitHub. This update will allow users to access the new "WQX3" profiles from the Water Quality Portal. Any new USGS discrete water quality data since March 11th is ONLY available via dataRetrieval from these new data profiles. With this update, all WQP functions that can use these new profiles will use them by default.
# > TADAShiny for synonymizing and flag/remove data (how does it deal with non-numeric entries like >XXX?). Perhaps add option for uploading a TADA file.
# > Update to work with hydrography revisions
# > Need to update scripts downstream of the WQP pulls to new column names and possibly different values returned. Eventually, you'll HAVE to update your workflows (the legacy profiles will eventually be retired). If you need to switch back to the production version of dataRetrieval, you can re-install (after unloading the package) by reinstalling the CRAN version:
# > More information is here:
# https://water.code-pages.usgs.gov/dataRetrieval/articles/qwdata_changes.html
# https://water.code-pages.usgs.gov/dataRetrieval/articles/Status.html
# > Look for the site on efficient pulling of WQP data

# Install and load packages
rm(list=ls())

pkgs <- c("flexdashboard", 
          "shiny", 
          "knitr",  
          "readr",
          "here", 
          "plyr", 
          "dplyr",
          "purrr",
          "tools",
          "ggplot2",
          "janitor", 
          "mgcv", 
          "scales", 
          "rlang", # check for empty variables <<<<<<<<<<<<
          "rtf", 
          "rmarkdown", 
          "shinyWidgets", 
          "leaflet", 
          "plotrix", 
          "GGally", 
          "plotly", 
          "httr", 
          # "climateR",
          "sp",
          "bslib", 
          "bsicons",
          "RgoogleMaps", # to set map zoom
          "sf",
          "tidyr",
          "magrittr", 
          "leaflet.extras", 
          "lubridate", 
          "stringr",
          "fontawesome", 
          "viridisLite", 
          "ggpubr", # for drawing separate legends
          "heatmaply", # for interactive heat plots
          "reactable", # for easy nested tables
          "htmltools", # for arranging plots in tab (browsable)
          "shinyFiles", # for user to save files in specified location
          "RColorBrewer", # to display brewer palettes
          "shinyjs", # for easy functions that use JavaScript
          "sortable", # drag-and-drop rank input
          "tmaptools", # for flexible color mapping (get_brewer_pal)
          "DT", # for interactive tables
          "zoo", # for year-month
          "cowplot", # to get legends from plots
          "gridExtra", # for arranging plots and adding plot annotations (ggplotly can't do captions or subtitles)
          "geojsonio", # to test for presence of features
          "lemon", # for facet_rep_wrap
          "shinyBS", # for collapsible panels
          # "tigris", # for state boundaries
          # "rnoaa", # to get NOAA climate data <<<<< THIS PACKAGE WILL RETIRE SOON. KEEP AN EYE ON THIS.
          "leaflet.minicharts") 

installed_pkgs <- pkgs %in% installed.packages()
if (length(pkgs[!installed_pkgs]) > 0) install.packages(pkgs[!installed_pkgs], repos = "https://cloud.r-project.org", dep=TRUE) 
invisible(lapply(pkgs, library, character.only = TRUE))

# Check for required dashboard files
req_files <- c("park_noaa_overlaps_list.RDS", "park_gage_overlaps_list.RDS", "parks_sf.RDS", "unique_parks_df.csv")
have_files <- list.files(path = here::here("dashboard_files"))
try(if(!all(req_files %in% have_files)) stop(paste("Missing required dashboard files in 'dashboard_files' subfolder:", setdiff(req_files, have_files))))

  # Read in park choice file
  unique_parks_df <- read_csv("dashboard_files/unique_parks_df.csv")

  # # >>>>>>>>>>>> PICK UP FROM HERE. ADD OPTION FOR USER TO ENTER STATE NAME/ABBREV. INSTEAD OF PARK.
  # usa <- st_as_sf(maps::map("state", fill=TRUE, plot =FALSE))
  # data.frame(state.abb, state.name) >>> does not include DC
  
options(shiny.maxRequestSize = 30*1024^2, # increases download limit to 30MB from 5MB default
        timeout = 3000,
        stringsAsFactors = FALSE,
        dplyr.summarise.inform = FALSE
)
  
```

```{r css}
# Make all progress bars larger
tags$style(HTML("
.shiny-progress {
  width: 500px !important;
  height: auto !important;
}

.progress {
  height: 25px !important;
  width: 100% !important;
}

.shiny-progress, .shiny-progress * {
  font-size: 20px !important;
  font-weight: bold !important;
}
"))
tags$style(HTML("
.section.level3 {
  overflow: visible !important;
  height: auto !important;
}
"))

# This forces datatable to fill height of modal
tags$style(".dataTables_scrollBody {
    height: calc(100vh - 180px) !important;
}")

# This sizes and positions the custom gif loading images
tags$style("dropdown-toggle {
           background-color:lightblue !important;
           padding:6px;
           }")

tags$style("#gif_modal .modal-body {padding:0px}
            #gif_modal .modal-dialog {width:auto; display:inline-block; position:absolute; top:35%;left:50%; transform:translate(-50%, -50%) !important;}
")

# This expands initial map to fill screen
tags$style("map {
           height: calc(100vh - 80px) !important;
           }")

# Call this to force an input value to reset to NULL
tags$script("
    Shiny.addCustomMessageHandler('setNull', function(variableName) {
      Shiny.setInputValue(id = variableName, value = null);
    });
  ")

# Call this to force an input value to reset to a specified value
tags$script("
    Shiny.addCustomMessageHandler('resetValue', function(variableName, inputValue) {
      Shiny.setInputValue(id = variableName, value = inputValue);
    });
  ")

# When an action button is disabled, text should be gray and button color light gray
tags$style(".btn.disabled {
  color:gray;
  background-color:light-gray;
}")

tags$style(".rank-list-title {
  font-size:14px;
  padding:4px;
}")

tags$style(".rank-list-item {
  font-size:14px;
  padding:4px;
}")

tags$style("table.dataTable tbody th, table.dataTable tbody td input.form-control {
    padding: 2px 5px; 
}") # reduce padding in data tables

tags$style(HTML(".shiny-output-error-validation {
  font-size:14px;
  color: #FF0000;
}")
) # validation text is in red. Could also add 'font-weight: bold;'

tags$style(".reactable {
font-size: 13px; 
}") # font size for reactable tables

tag.map.title <- tags$style(HTML("
  .leaflet-control.map-title { 
    text-align: center;
    font-weight: bold;
    background: rgba(255,255,255,0.75); # white box
    font-size: 28px;
    color: darkred;
  }
")) # add title to leaflet map

# Fix map losing focus issue
tags$style(HTML("
.leaflet-container {
  position: relative !important;
}

.tab-content {
  overflow: visible !important;
}
"))

tags$style(".map-unitcode {
           font-weight: bold;
           background: rgba(255,255,255,0.75); # white box
           font-size:35px;
           }") # add bold park unit name/code to leaflet map

tags$style(".chart-stage-flex {
overflow: scroll !important;
}") # Helps ensure data table bottoms don't get cut off

tags$style(HTML("
      .panel {
        margin-bottom: 10px; /* Adjust the margin between panels */
      }
      
      .panel-title {
      font-size: 14px; /* Adjust the font size as needed */
      }
      
      .panel-heading {
        font-size: 10px; /* Adjust the font size of the panel heading */
        padding: 5px 8px; /* Adjust the padding of the panel heading */
      }
      
      .panel-body {
        font-size: 10px; /* Adjust the font size of the panel body */
        padding: 5px; /* Adjust the padding of the panel body */
      }

    .panel-heading .panel-title a.collapsed:after {
      transform: rotate(180deg);
      transition: .5s ease-in-out;
    }
    
    .panel-heading .panel-title a:after {
      content:'⏶';
      text-align: right;
      float:right;
      transition: .5s ease-in-out;
    }
    
    .panel-heading .panel-title a:not([class]):after {
      transform: rotate(180deg);
    }
    ")) # Modify bsCollapse drop-down panels

tags$style(HTML("

  #categDT_wrapper .dataTables_scrollBody {
    max-height: 60vh;
    overflow-y: auto;
    overflow-x: auto;
  }
  
  #categDT td {
  white-space: normal !important;
  word-wrap: break-word;
  max-width: 100px;
  padding: 8px !important; /* ensure visible cell height */
  vertical-align: middle !important;
}

  .modal-lg {
    width: 100% !important;
  }
"))

tags$style(HTML("
.bslib-sidebar-layout > .collapse-toggle[aria-expanded='true']::after,
.bslib-sidebar-layout > .collapse-toggle[aria-expanded='false']::after {
  content: '';
  display: inline-block;
  padding: 2px 10px;
  background-color: #e97451;  
  color: white;
  border-radius: 12px;
  margin-left: -12px;  /* Slight left shift */
  font-size: 0.9em;
  font-weight: bold;
  white-space: nowrap;
}

.bslib-sidebar-layout > .collapse-toggle[aria-expanded='true']::after {
  content: 'Hide Map';
}

.bslib-sidebar-layout > .collapse-toggle[aria-expanded='false']::after {
  content: 'Show Map';
}
"))

tags$style(HTML("
.bslib-sidebar-layout > .collapse-toggle[aria-expanded='true']::after {
  content: 'Hide Map';
  }
  .bslib-sidebar-layout > .collapse-toggle[aria-expanded='false']::after {
  content: 'Show Map';
  }
"))

# Make the bslib card full screen icon and exit more obvious
tags$style(HTML("
        .bslib-full-screen-enter {
          bottom: var(--bslib-full-screen-enter-top);
          visibility: visible !important;
          background-color: #e97451 !important;
        }
        .bslib-full-screen-exit {
          visibility: visible !important;
          background-color: #e97451 !important;
          font-weight: bold !important;
          border-radius: 0.3rem;padding: 0.5rem 1rem;
          z-index: 10000;
          box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
          cursor: pointer;
      ")) # full-screen card shows on top right and in color
```

```{r generic_action_buttons}
# Action to cancel modal
observeEvent(eventExpr = input$button_cancelModal, {
  removeModal()
  })
```

```{r functions}
### FUNCTIONS ----
FuncAboutButton <- function(nam) {
  actionButton(nam, "   PAGE INSTRUCTIONS", icon = icon("question-sign", lib = "glyphicon"), width = "100%")
}

FuncShowWellPanel <- function(input_to_test, wp_to_toggle) {
  # Function to show or hide a well panel based on a checkbox selection
  #
  # Args:
  #   input_to_test:  The ID of the checkbox input, e.g., input$sel_ShowPanel
  #   wp_to_toggle:  ID of the well panel to toggle, e.g., wp_example
  #
  shiny::req(!is.null(rv$dat),!is.null(input_to_test))
  if(input_to_test) {
    shinyjs::showElement(wp_to_toggle)
    } else {
      shinyjs::hideElement(wp_to_toggle)
    }
  }

FuncAllNoneButtons <- function(cond, name_all, name_none) {
  # Function to create 'Select All' and 'Select None' action buttons
  #
  # Args:
  #   cond:  The input ID that needs to be defined for buttons to show (enter as input.XXX rather than as input$XXX)
  #   name_all:  ID to assign to 'Select All' button
  #   name_none:  ID to assign to 'Select None' button
  #
  conditionalPanel(
    condition = paste0("typeof ", cond, " !== 'undefined'"),
    actionButton(name_all, "Select All", style="color:black; display:inline-block; border:1px; padding:2px 6px;"),
    actionButton(name_none, "Select None", style="color:black; display:inline-block; border:1px; padding:2px 6px;")
  )
}

FuncCalcWaterSeasons <- function(dateVec){
  # Function to calculate water year from calendar date (modified from calcWaterSeasons function in package 'dataRetrieval')
  # POSIXlt years start at 100, POSIXlt months start at 0
  dateTimeVec <- as.POSIXlt(dateVec)
  calYear <- dateTimeVec$year + 1900
  calMon <- dateTimeVec$mon + 1
  
  # when the date is NA, it should not try to add 1
  whichPastOct <- calMon >= 10
  whichPastOct[is.na(whichPastOct)] <- FALSE
  
  # add one to the year if it is in October or after
  WaterSeasons <- calYear
  WaterSeasons[whichPastOct] <- calYear[whichPastOct] + 1
  
  return(WaterSeasons)
}

FuncBreakDates <- function(dat_df) {
  # Function to break dates into date categories
  #
  # Args:
  #   dat_df:  A data frame with the raw data. One column needs to be ActivityStartDate, which is date class with format yyyy-mm-dd
  #
  dat_df2 <- dat_df %>% 
    dplyr::mutate(
      YrDate = base::as.Date(cut(ActivityStartDate, breaks = "year")), # these maintain date class, so are useful for certain summaries
      MnthDate = base::as.Date(cut(ActivityStartDate, breaks = "month")),
      WkDate = base::as.Date(cut(ActivityStartDate, breaks = "week", start.on.monday = FALSE)), # Sunday start of week
      MeteoYr = as.integer(lubridate::year(ActivityStartDate)), # for other types of summaries
      WaterYr = as.integer(FuncCalcWaterSeasons(ActivityStartDate)),
      Season = factor(cut(lubridate::yday(ActivityStartDate),
                   breaks=c(-Inf, 59, 151, 243, 334, Inf), # NOTE: DOES NOT CORRECT FOR LEAP YEAR
                   labels=c("Winter","Spring","Summer", "Fall", "Winter")), levels = c("Spring","Summer", "Fall", "Winter")), # Meteorological Seasons: Spring=March 1 - May 31; Summer=June 1 - Aug 31; Fall=Sept1 - Nov30; Winter=Dec1 - Feb28
      Mnth = lubridate::month(ActivityStartDate, label = TRUE, abbr = TRUE),
      Wk = factor(lubridate::week(ActivityStartDate), levels = 1:52),
      DayOfYr = lubridate::yday(ActivityStartDate))
  dat_df2$Mnth = factor(dat_df2$Mnth, levels = levels(dat_df2$Mnth), ordered = FALSE)
  
  return(dat_df2)
}

FuncOrderCheck <- function(import = FALSE, filter_internal = FALSE, filter_external = FALSE, plot = FALSE) {

  # Function to check if data have been imported, filtered, and plot data summarized
    if(import) {
      shiny::validate(
     need(!is.null(rv$dat), message = "No data available. Please use the 'Get WQP Data' tab to first import or load water quality data."))}
  if(filter_internal) {
    shiny::validate(
    need(!is.null(rv_param_temp$subDat) & !is.null(rv_param_temp$subDatTypes), message = "From the left sidebar, choose a subset of data to work with"))}
  if(filter_external) {
    shiny::validate(
    need(!is.null(rv_param_temp$subDat) & !is.null(rv_param_temp$subDatTypes), message = "On the 'Define & Filter Data' page, please choose a subset of data to work with"))}
  if(plot) {
    shiny::validate(
    need(!is.null(rv_param_temp$plotDat), message = "On the 'Explore Data' page, select characteristic(s) and monitoring site(s) to plot and then click the green 'REFRESH PLOT DATA' button."))

  }
}

FuncCustomSeasons <- function(dat_df, seas) {
  # Function to assign USGS water year or custom seasons to ActivityStartDate
  #
  # Args:
  #   dat_df:  A data frame to modify. One column needs to be ActivityStartDate, which is date class with format yyyy-mm-dd
  #   seas: character string, "WaterSeasons" or "CustomSeasons"
  #
  dat_df$Season <- NA
  # assign the custom season names based on dates. Can't just use cut, in case the seasons aren't consecutive
  if(seas == "WaterSeasons") {
    df_CustomSeason <- data.frame(
      Name = c("Fall(WY)", "Winter(WY)", "Spring(WY)", "Summer(WY)"),
      RangeStart = as.Date("2018-01-01")-1 + c(274, 1, 91, 182),
      RangeEnd = as.Date("2018-01-01")-1 + c(265, 90, 181, 273))
  }
  if(seas == "CustomSeasons") {
    df_CustomSeason <- data.frame(
      Name = c(input$sel_Season1Name, input$sel_Season2Name, input$sel_Season3Name, input$sel_Season4Name),
      RangeStart = c(input$sel_Season1Range[1], input$sel_Season2Range[1], input$sel_Season3Range[1], input$sel_Season4Range[1]),
      RangeEnd = c(input$sel_Season1Range[2], input$sel_Season2Range[2], input$sel_Season3Range[2], input$sel_Season4Range[2]))
  }
  
  df_CustomSeason <- df_CustomSeason[df_CustomSeason$Name != "",] # if no name assigned, then it's not a season level
  for(i in 1:nrow(df_CustomSeason)) {
    Name <- df_CustomSeason$Name[i]
    StartDate <- lubridate::yday(df_CustomSeason$RangeStart[i])
    StartDate_LY <- lubridate::yday(gsub("^.{1,4}", "2000", df_CustomSeason$RangeStart[i])) # yday count is different for leap years
    EndDate <- lubridate::yday(df_CustomSeason$RangeEnd[i])
    EndDate_LY <- lubridate::yday(gsub("^.{1,4}", "2000", df_CustomSeason$RangeEnd[i])) # yday count is different for leap years
    
    
    if(StartDate < EndDate) {
      # for leap year
      dat_df$Season[lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) >= StartDate_LY & lubridate::yday(dat_df$ActivityStartDate) <= EndDate_LY] <- Name
      # for not leap year
      dat_df$Season[!lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) >= StartDate & lubridate::yday(dat_df$ActivityStartDate) <= EndDate] <- Name
    } else { # start yday is larger than end yday, it means it spans Dec 31-Jan 1
      # for leap year
      dat_df$Season[lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) >= StartDate_LY] <- Name
      dat_df$Season[lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) <= EndDate_LY] <- Name
      # for not leap year
      dat_df$Season[!lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) >= StartDate] <- Name
      dat_df$Season[!lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) <= EndDate] <- Name
    }
  }
  
  dat_df$Season <- factor(dat_df$Season, levels = df_CustomSeason$Name)
  return(dat_df)
}

FuncBaseMap <- function(maptype) {
    cbp1 <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7", "#0072B2", "#D55E00", "#999999", "#F0E442", "#000000", "chocolate4", "purple4", "chartreuse", "lightpink", "honeydew2") # Colorblind-friendly palette
  print("in FuncBaseMap")
  cbp1_org <- switch((length(unique(rv$sitesPointsSub$OrganizationFormalName)) <= length(cbp1)) + 1,  colorRampPalette(cbp1)(length(unique(rv$sitesPointsSub$OrganizationFormalName))), cbp1[1:length(unique(rv$sitesPointsSub$OrganizationFormalName))])
  
  rv_param_temp$palOrg <- colorFactor(palette = cbp1_org, domain = unique(rv$sitesPointsSub$OrganizationFormalName), levels = unique(rv$sitesPointsSub$OrganizationFormalName))
  
  iconGages = makeAwesomeIcon(
    text = fa("water"),
    iconColor = "black",
    markerColor = "blue")
  
  iconMeteo = makeAwesomeIcon(
    icon= "fa-cloud", 
    library = "fa", 
    squareMarker = TRUE, 
    markerColor = "white")
  
  iconCWA = makeAwesomeIcon(
    icon= "fa-building", 
    library = "fa", 
    markerColor = "lightgray")
  
  iconGagesSelected = makeAwesomeIcon(
      text = fa("water"),
      iconColor = "black",
      markerColor = "orange")
  
  iconMeteoSelected = makeAwesomeIcon(
      icon= "fa-cloud", 
      library = "fa", 
      squareMarker = TRUE, 
      markerColor = "orange")
  print("Creating base map")

  # Order map layers -- higher zIndex is on "top"
  map <- leaflet(options = leafletOptions(zoomControl = FALSE, zoomSnap = 0.25)) %>%
    addMapPane("pane_unitPoly", zIndex = 210) %>%
    addMapPane("pane_HUC", zIndex = 220) %>%
    addMapPane("pane_facilitiesPoints", zIndex = 225) %>%
    addMapPane("pane_meteoStations", zIndex = 230) %>%
    addMapPane("pane_gageStations", zIndex = 235) %>%
    addMapPane("pane_meteoStations_selected", zIndex = 240) %>%
    addMapPane("pane_gageStations_selected", zIndex = 245) %>%
    addMapPane("pane_availableStations", zIndex = 255) %>%
    addMapPane("pane_selectedStreamlines", zIndex = 257) %>%
    addMapPane("pane_selectedStations", zIndex = 260) %>% # always keep selected monitoring station points on "top" of map layers (highest zIndex)
    addMapPane("pane_selectedOrigin", zIndex = 265) %>%
    addTiles(options = tileOptions(noWrap = TRUE), group = "Street") %>%
    addProviderTiles("Esri.WorldImagery", options = providerTileOptions(noWrap = TRUE), group="Satellite") %>%
    addPolygons(data = rv$unitPoly, group = "NPS unit", color = "black", fillColor = "yellow", fillOpacity = 0.8, weight = 1, options = pathOptions(pane = "pane_unitPoly")) %>% # park unit outline
    addPolygons(data = rv[[rv$importSettings$sel_HUClevel]], group = rv$importSettings$sel_HUClevel, color = "blue", fillColor = "lightblue", fillOpacity = 0.6, weight = 0.5, layerId = ~HUC, options = pathOptions(pane = "pane_HUC")) %>% # HUC polygons
    addScaleBar() %>%
    addControl(rv$parkName, position = "topleft", className="map-unitcode") # add 4-letter UNIT code on map)
  print("Finished base map")
  # Conditional mapping (when data are available)
  
  init_sites <- subset(rv$sitesPointsSub, OrganizationFormalName %in% rv$importSettings$sel_Organization & MonitoringLocationTypeName %in% rv$importSettings$sel_SiteType)
  
  if(maptype == "initial") { # These are specific to the initial map
    print("Map type is 'initial'")
    if(nrow(init_sites) > 0) { # Available water quality stations
  map %<>% addCircleMarkers(data = init_sites, group = "Available monitoring sites", label = ~SITELAB, popup = ~SITEPOP, radius = 4, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 0.8, stroke = TRUE, weight = 1, color = ~rv_param_temp$palOrg(OrganizationFormalName), opacity = 0.7, options = pathOptions(pane = "pane_availableStations"))
      } # WQ stations
                                                         
      if(!is.null(rv$selectedStations)) {
        sel_stations <- rv$sitesPointsSub %>% dplyr::filter(MonitoringLocationIdentifier %in% rv$selectedStations$MonitoringLocationIdentifier)

        if(nrow(sel_stations) > 0) {
          print("Mapping selected sites")
    map %<>%
      addCircleMarkers(data = rv$sitesPointsSub %>% dplyr::filter(MonitoringLocationIdentifier %in% rv$selectedStations$MonitoringLocationIdentifier), group = "Selected monitoring sites", label = ~SITELAB, popup = ~SITEPOP, radius = 8, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 0.8, stroke = TRUE, weight = 4, color = "white", opacity = 1, options = pathOptions(pane = "pane_selectedStations"))
    }
      }

    
    if(all(!is.null(rv$selectedOriginStation), !is.null(rv$importSettings$sel_SelectMethod))){ # the origin station for up-down selection is outlined in red
    if(rv$importSettings$sel_SelectMethod=="methodDist") {
      if(nrow(rv$sitesPointsSub[rv$sitesPointsSub$MonitoringLocationIdentifier == rv$selectedOriginStation$identifier,]) > 0) {
      map %<>% 
        addCircleMarkers(data = rv$sitesPointsSub[rv$sitesPointsSub$MonitoringLocationIdentifier == rv$selectedOriginStation$identifier,], group = "Selected monitoring sites", label = ~SITELAB, popup = ~SITEPOP, radius = 8, fillOpacity = 0, stroke = TRUE, weight = 4, color = "red", opacity = 1, options = pathOptions(pane = "pane_selectedOrigin"))}
    }
    }
    
  }
  
  # These are for any map type
   if(all(rv$importSettings$sel_SelectMethod=="methodHuc",  !is.null(rv$selectedHucs))) { # layer the selected polygons on map, if selection method is by HUC 
     print("mapping HUCs")
    map %<>%
      addPolygons(data = rv[[rv$importSettings$sel_HUClevel]][rv[[rv$importSettings$sel_HUClevel]]$HUC %in% rv$selectedHucs,], group = rv$importSettings$sel_HUClevel, color = "blue", fillColor = "lightblue", fillOpacity = 0.8, weight = 1.5, layerId = ~HUC, options = pathOptions(pane = "pane_HUC"))
   }
  
  if(all(!is.null(rv$selectedOriginStation), !is.null(rv$importSettings$sel_SelectMethod))){
    if(rv$importSettings$sel_SelectMethod=="methodDist") {
    
    if(!is.null(rv$selectedDownstreamLines)) {
      map %<>%
        addPolylines(data = rv$selectedDownstreamLines, color = "#660000", weight = 2, opacity = 1, group = "Selected monitoring sites", options = pathOptions(pane = "pane_selectedStreamlines")) # downstream lines in brown
      }
    
    if(!is.null(rv$selectedUpstreamLines)) {
    map %<>%
        addPolylines(data = rv$selectedUpstreamLines, color = "#FFFFFF", weight = 2, opacity = 1, group = "Selected monitoring sites", options = pathOptions(pane = "pane_selectedStreamlines")) # upstream lines in blue
  }
    }
}
          
  print("about to map USGS stations")
  if(!is.null(rv$gageStations)) { # Add USGS gage (streamflow) stations only if found
    print("map USGS streamflow stations")
    map %<>%
      addAwesomeMarkers(icon = iconGages, data = rv$gageStations, group = "Gage stations", label = ~GAGELAB, popup = ~GAGEPOP, options = pathOptions(pane = "pane_gageStations")) # selected stream gage stations
  }

  print("about to map meteoStations")
  if(!is.null(rv$meteoStations)) { # Add weather stations only if found
    print("map metioStations")
    map %<>%
      addAwesomeMarkers(icon = iconMeteo, data = rv$meteoStations, group = "Weather stations", label = ~METEOLAB, popup = ~METEOPOP, options = pathOptions(pane = "pane_meteoStations")) # weather stations
  }
  
  if(!is.null(rv$facilitiesPointsSub)) { # Add EPA-monitored discharge facilities only if found
    print("map EPA facilities")
    map %<>%
      addAwesomeMarkers(icon = iconCWA, data = rv$facilitiesPointsSub, group = "Discharge facilities", label = ~FACLAB, popup = ~FACPOP)
  }
  
  print("about to map selected USGS stations")
  if(all(!is.null(rv$gageStations), !is.null(rv$selectedGages))) { # Add selected USGS gage stations only if found
  if(all(rv$selectedGages$GageID %in% rv$gageStations$GageID)) { 
    print("map selected USGS stations")
    map %<>%
      addAwesomeMarkers(icon = iconGagesSelected, data = rv$selectedGages, group = "Gage stations", label = ~GAGELAB, popup = ~GAGEPOP, options = pathOptions(pane = "pane_gageStations_selected"))
  }}
  
  print("about to map selected meteoStations")

  if(all(!is.null(rv$meteoStations), !is.null(rv$selectedMeteo))) {
    if(all(rv$selectedMeteo$MeteoID %in% rv$meteoStations$MeteoID)) {
      print("map selected meteoStations")
      map %<>%
        addAwesomeMarkers(icon = iconMeteoSelected, data = rv$selectedMeteo, group = "Weather stations", label = ~METEOLAB, popup = ~METEOPOP, options = pathOptions(pane = "pane_meteoStations_selected"))
    }}
  print("about to return map")
  return(map)
}

FuncUpdateHome <- function() {
  updateTextInput(session,
                  "sel_UnitCode",
                  value = "")
  
  updateSliderInput(session,
                    "sel_MapZoom", 
                    value = NULL)
  
  updateRadioButtons(session,
                     "sel_HUClevel",
                     selected = "HUC10")
  
  updateRadioButtons(session,
                     "sel_SelectMethod",
                     selected = "methodHuc")
  
  updateTextInput(session,
                  "sel_OriginStationID",
                  value = "")
  
  updateCheckboxGroupInput(session,
                           "sel_Organization",
                           choices = NULL,
                           selected = character(0))
  
  updateCheckboxGroupInput(session,
                           "sel_Gages",
                           choices = NULL,
                           selected = character(0))
  
  updateCheckboxGroupInput(session,
                           "sel_Meteo",
                           choices = NULL,
                           selected = character(0))
  
  # # Reset map center and map bounds to NULL
  session$sendCustomMessage(type = "setNull", message = "map_center")
  session$sendCustomMessage(type = "setNull", message = "map_bounds")
}

FuncUpdateFilterInputs <- function() {
  updateRadioButtons(session,
                     "sel_DefineSeasons",
                     selected = rv_param_temp$defaultInputs$sel_DefineSeasons)
  
  updateSliderInput(session,
                    "sel_SeasonsStart",
                    value = as.Date("2018-01-01"))
  
  updateTextInput(session,
                  "sel_Season1Name",
                  value = "")
  
  updateTextInput(session,
                  "sel_Season2Name",
                  value = "")
  
  updateTextInput(session,
                  "sel_Season3Name",
                  value = "")
  
  updateTextInput(session,
                  "sel_Season4Name",
                  value = "")
  
  updateSliderInput(session,
                    "sel_YrRange",
                    min = NULL, 
                    max = NULL, 
                    step = NULL, 
                    value = rv_param_temp$defaultInputs$sel_YrRange)
  
  updateNumericInput(session,
                     "sel_MinYrs",
                     value = rv_param_temp$defaultInputs$sel_MinYrs)
  
  updateCheckboxGroupInput(session,
                           "sel_ActivityType",
                           selected = rv_param_temp$defaultInputs$sel_ActivityType)
  
  updateCheckboxGroupInput(session,
                           "sel_ResultStatus",
                           selected = rv_param_temp$defaultInputs$sel_ResultStatus)
  
  
  updateCheckboxGroupInput(session,
                           "sel_SummaryOrg",
                           selected = rv_param_temp$defaultInputs$sel_SummaryOrg)
  
  updateCheckboxInput(session,
                      "sel_AddQuantile",
                      value = FALSE)
  
  updateRadioButtons(session,
                     "sel_ShowThresholds",
                     selected = "showthresh_none")
  
  updateRadioButtons(session,
                     "sel_AddGagePrecip",
                     selected = "none")
}


FuncUpdateInputsOther <- function() {
    updateSelectInput(session,
                    "sel_ShowCharType",
                    choices = NULL,
                    selected = NULL)
    
    updateCheckboxGroupInput(session,
                           "sel_ShowStations",
                           choices = NULL,
                           selected = character(0))
 
    updateRadioButtons(session,
                       "sel_Categ",
                       choices = "none",
                       selected = "none")
}

FuncUpdateImportSettings <- function(inputs_to_update) {
  shiny::req(!is.null(rv$dat))
  input_list <- shiny::isolate(shiny::reactiveValuesToList(input)) # difficulties indexing reactive list, so convert to unreactive list first
  replacement_list <- input_list[inputs_to_update]
  names(replacement_list) <- inputs_to_update # adds list element name, even for NULL elements
  rv$importSettings <- modifyList(rv$importSettings, replacement_list, keep.null = TRUE) # update only the list elements in replacement_list
}
  
FuncDataTypes <- function(dat) {
  # Function to identify which characteristic names have non-numeric entries, and what those entries are
  #
  # Args:
  #   dat: The imported data frame. Requires columns CharacteristicName and ResultMeasureValue
  # 
  # Returns:
  #   Data frame with each characteristic name, best guess of data type (categorical or numeric), and the non-numeric entries
  temp_datatype <- dat %>%
    dplyr::select(CharacteristicName, CharSampleType, ResultMeasureValue) %>%
    dplyr::group_by(CharacteristicName, CharSampleType)
  
  temp_datatype_count <- temp_datatype %>%
    dplyr::summarise(NumRecords = n()) %>%
    dplyr::select(CharSampleType, NumRecords)
  
  temp_datatype_categ <- temp_datatype %>%
    group_map(~sort(unique(na.omit(.x$ResultMeasureValue[which(is.na(suppressWarnings(as.numeric(gsub(",", "", .x$ResultMeasureValue)))))])))) # identify all non-numeric, non-NA entries for each characteristic. If it's a number with comma, removes the comma and still counts it as a number
  
  df_datatype <- as.data.frame.AsIs(temp_datatype_categ, stringsAsFactors=FALSE) %>% # unfortunately, I can't get the data table edit function to work with factor class variables
    dplyr::mutate(CharSampleType = unique(dat$CharSampleType),
                  DataType = ifelse(temp_datatype_categ %in% c("character(0)", "numeric(0)", "logical(0)"), "numeric", "categorical")) %>%
    rowwise() %>%
  mutate(NonNumericEntries = paste(temp_datatype_categ, collapse = " // ")) %>% # make sure using unique separator that wouldn't be part of any entry
    dplyr::select(-temp_datatype_categ) %>%
    dplyr::left_join(temp_datatype_count, by = "CharSampleType") %>%
    arrange(DataType, CharacteristicName, CharSampleType)
  df_datatype$DataType <- factor(df_datatype$DataType, levels = c("categorical", "numeric")) # only allows these entries
  return(df_datatype)
}

FuncFilterSelectCharSampleType <- function(sel_NPSparam, sel_YrRange, sel_SummaryOrg, sel_ActivityType, sel_ResultStatus, sel_MinYrs) {
  shiny::req(!is.null(rv$dat))
  
  char_vec <- rv$dat %>% 
    {if (sel_NPSparam == TRUE & "National Park Service Water Resources Division" %in% rv$dat$OrganizationFormalName) dplyr::filter(., OrganizationFormalName == "National Park Service Water Resources Division") else .} %>%
    dplyr::filter(ResultDetectionConditionText != "Not Reported") %>%
    dplyr::mutate(Yr = MeteoYr) %>%
    dplyr::filter(Yr >= as.integer(sel_YrRange[1]) & Yr <= as.integer(sel_YrRange[2]) & OrganizationFormalName %in% sel_SummaryOrg & ActivityTypeCode %in% sel_ActivityType & ResultStatusIdentifier %in% sel_ResultStatus) %>%
    dplyr::select(CharacteristicName, CharSampleType, MonitoringLocationIdentifier, Yr) %>%
    dplyr::distinct() %>%
    group_by(CharacteristicName, CharSampleType, MonitoringLocationIdentifier) %>%
    dplyr::mutate(TotalSurveyYrs = dplyr::n_distinct(Yr)) %>%
    dplyr::filter(TotalSurveyYrs >= sel_MinYrs) %>%
    dplyr::ungroup() %>%
    dplyr::pull(CharSampleType)
  
  return(sort(unique(char_vec)))
}

FuncInitFilter <- function() {
  shiny::req(!is.null(rv$dat))
  cat("defining filter defaults")
  # Initial default filtering of data so user can bypass filter page
  rv_param_temp$defaultInputs$sel_YrRange <- c(min(rv$dat$MeteoYr, na.rm = TRUE), max(rv$dat$MeteoYr, na.rm = TRUE))
  rv_param_temp$defaultInputs$sel_MinYrs <- 3
  rv_param_temp$defaultInputs$sel_DefineSeasons <- "MeteoSeasons"
  rv_param_temp$defaultInputs$sel_SummaryOrg <-sort(unique(rv$dat$OrganizationFormalName))
  rv_param_temp$defaultInputs$sel_NPSparam <- FALSE
  rv_param_temp$defaultInputs$sel_ActivityType <- sort(intersect(unique(rv$dat$ActivityTypeCode), c("Field Msr/Obs", "Field Msr/Obs-Portable Data Logger",  "Sample", "Sample-Routine")))
  rv_param_temp$defaultInputs$sel_ResultStatus <- sort(intersect(unique(rv$dat$ResultStatusIdentifier), c("Accepted", "Final", "Validated", "Historical")))
  
  shiny::req(!is.null(rv_param_temp$defaultInputs$sel_NPSparam), !is.null(rv_param_temp$defaultInputs$sel_YrRange), !is.null(rv_param_temp$defaultInputs$sel_SummaryOrg), !is.null(rv_param_temp$defaultInputs$sel_ActivityType), !is.null(rv_param_temp$defaultInputs$sel_ResultStatus), !is.null(rv_param_temp$defaultInputs$sel_MinYrs))

  rv_param_temp$selectCharSampleType <- FuncFilterSelectCharSampleType(
    sel_NPSparam = rv_param_temp$defaultInputs$sel_NPSparam, 
    sel_YrRange = rv_param_temp$defaultInputs$sel_YrRange, 
    sel_SummaryOrg = rv_param_temp$defaultInputs$sel_SummaryOrg, 
    sel_ActivityType = rv_param_temp$defaultInputs$sel_ActivityType, 
    sel_ResultStatus = rv_param_temp$defaultInputs$sel_ResultStatus, 
    sel_MinYrs = rv_param_temp$defaultInputs$sel_MinYrs)
  
    match_vec <- c("Dissolved oxygen", "Escherichia", "Flow, severity (choice list)", "Flow, stream stage (choice list)", "Nitrate + Nitrite", "Nitrogen", "pH", "Specific conductance", "Temperature", " Phosphorus", "Turbidity")
    init_param_select <- rv_param_temp$selectCharSampleType[grep(paste(match_vec, collapse = "|"), rv_param_temp$selectCharSampleType)]
  
  # Set initial plot input values
  print("SETTING INITIAL THRESHOLD VALUES")
  rv_param_temp$threshList <- NULL
  rv_param_temp$threshDF <- NULL
  print("SET THRESHLIST TO NULL")
  
  rv_param_temp$currentInputs$sel_SummaryParam <- init_param_select
  rv_param_temp$currentInputs$sel_ThreshLower <- NA
  rv_param_temp$currentInputs$sel_ThreshUpper <- NA
  rv_param_temp$currentInputs$sel_ThreshCateg1 <- rv_param_temp$currentInputs$sel_ThreshCateg2 <- rv_param_temp$currentInputs$sel_ThreshCateg3 <- "good"
  cat("end of define filter defaults")
  # session$sendCustomMessage(type = "resetValue", message = list("sel_SummaryParam", sort(rv_param_temp$selectCharSampleType)))
}

FuncRefreshFilter <- function(sel_MinYrs, sel_SummaryParam, sel_SummaryOrg, sel_YrRange, sel_ActivityType, sel_ResultStatus, sel_DefineSeasons) {
  # Update filter data to create rv_param_temp$subDat
  shiny::req(!is.null(rv$importSettings$sel_Organization))
  if(all(unique(rv$dat$OrganizationFormalName) %in% rv$importSettings$sel_Organization)==FALSE) {
    rv_param_temp$subDat <- NULL
    rv_param_temp$subDatYears <- NULL
    rv_param_temp$subDatTypes <- NULL
  } else {
    
    shiny::req(!is.null(rv$dat), !is.null(sel_MinYrs), !is.null(sel_SummaryParam), !is.null(sel_SummaryOrg), !is.null(sel_YrRange), !is.null(sel_ActivityType), !is.null(sel_ResultStatus), !is.null(sel_DefineSeasons))
    print("DOING FUNCREFRESHFILTER")
    rv_param_temp$seasonType <- switch(
      sel_DefineSeasons, 
      MeteoSeasons = "Calendar Year (starts Jan. 1)", 
      WaterSeasons = "Water Year (starts Oct. 1)", 
      CustomSeasons = paste0("Custom Year (starts ", as.character(input$sel_SeasonsStart, format="%b %d"), ")")
      )
    
    filterDat <- rv$dat
    if(sel_DefineSeasons=="MeteoSeasons") {
      filterDat$Yr <- as.integer(filterDat$MeteoYr)
      filterDat$Mnth <- factor(filterDat$Mnth,levels(rv$dat$Mnth))
    } else {
      filterDat$Yr <- as.integer(filterDat$WaterYr)
      filterDat$Mnth <- factor(filterDat$Mnth,levels(rv$dat$Mnth)[c(10,11,12,1:9)])
    }
    print("line731")
    filterDat %<>%
      dplyr::filter(Yr >= as.integer(sel_YrRange[1]) & Yr <= as.integer(sel_YrRange[2]) & OrganizationFormalName %in% sel_SummaryOrg & CharSampleType %in% sel_SummaryParam & ActivityTypeCode %in% sel_ActivityType & ResultStatusIdentifier %in% sel_ResultStatus)
    
    print("line763")
    # Assign custom seasons
    if(nrow(filterDat) > 0 & sel_DefineSeasons %in% c("WaterSeasons", "CustomSeasons"))
    {
      filterDat <- FuncCustomSeasons(dat_df = filterDat, seas = sel_DefineSeasons)
    }
    rv$importSettings$sel_DefineSeasons <- sel_DefineSeasons
    
    if(nrow(filterDat) > 0) {
      filterYears <- filterDat %>%
        dplyr::select(CharacteristicName, CharSampleType, MonitoringLocationIdentifier, Yr) %>%
        dplyr::group_by(CharacteristicName, CharSampleType, MonitoringLocationIdentifier) %>%
        dplyr::summarize(StartYr = as.integer(min(Yr, na.rm = TRUE)),
                         EndYr = as.integer(max(Yr, na.rm = TRUE)),
                         TotalSurveyYrs = dplyr::n_distinct(Yr),
                         NumRecords = n()) %>%
        dplyr::filter(TotalSurveyYrs >= sel_MinYrs)
      print("line780")
      if(nrow(filterYears) > 0) { # if none of the data meet the minimum years criterion, these entries will be NULL
        # Create ResultMeasureValue_replaced column that replaces values not detected

suppressWarnings(filterDat$ResultMeasureValue_replaced <- as.numeric(filterDat$ResultMeasureValue))
suppressWarnings(filterDat$ResultMeasureValue_replaced[filterDat$ResultDetectionConditionText != "Detected and Quantified" & is.na(filterDat$ResultMeasureValue) & !is.na(filterDat$DetectionQuantitationLimitMeasure.MeasureValue)] <-
  as.numeric(filterDat$DetectionQuantitationLimitMeasure.MeasureValue[filterDat$ResultDetectionConditionText != "Detected and Quantified" & is.na(filterDat$ResultMeasureValue) & !is.na(filterDat$DetectionQuantitationLimitMeasure.MeasureValue)])) # create a column in which the detection limit replaces NA, for records where result was above or below detection limit--this column will be used to calculate probability quantiles <<<<<<<<<<<<<<< INCLUDE THIS EXPLANATION IN DOCUMENTATION
  
filterDat$ThreshCateg <- filterDat$CategName <- filterDat$CategResultMeasureValue <- NA # Create these columns so they can be filled if threshold or categorical color files are loaded. Also resets to NA when the filter data are changed.

  # if(!is.null(rv_param_temp$threshList)) {
  #   print("ADDING THRESHOLD DATA TO FILTERED DATA FRAME")
  #   filterDat <- FuncAddThreshCateg(filterDat)
  # }
  
        rv_param_temp$subDat <- filterDat %>%
          right_join(filterYears[, c("CharacteristicName", "CharSampleType", "MonitoringLocationIdentifier")], by = c("CharacteristicName", "CharSampleType", "MonitoringLocationIdentifier")) # just keep the ones that met the data filter criteria for total survey years, so these are the raw data that are summarized in rv_param_temp$subDatYears
        if(!is.null(rv_param_temp$subDat)) {
          rv_param_temp$subDatTypes <- as.data.frame(FuncDataTypes(dat = rv_param_temp$subDat))}
        
        rv_param_temp$subDatYears <- filterYears
        print("line785")
        
      } else {
        rv_param_temp$subDat <- NULL
        rv_param_temp$subDatYears <- NULL
        rv_param_temp$subDatTypes <- NULL
        cat("line961")
      }
    } else {
      rv_param_temp$subDat <- NULL
      rv_param_temp$subDatYears <- NULL
      rv_param_temp$subDatTypes <- NULL
      cat("line966")
    }
    rm(filterDat)
  }
}

FuncPlotHeatMap <- function(dat, y_name, legend_range, legend_name) {
  # Function to create static heatmaps. X-axis is always year.
  #
  # Args:
  #   dat: Data frame with these columns: Yr (for x-axis), Y, FillCol, MonitoringLocationIdentifier.
  #   y_name, legend_name: Axis labels and legend titles
  #   
  # Returns:
  #   Static heat maps
  #

  # Create color scale
    # min_colorval <- legend_range[1]
    max_colorval <- legend_range[2] # make sure the range of color values is the same across all plots
    template_cols <- viridisLite::viridis(n = max_colorval, alpha = 1, begin = 0, end = 1, direction = -1)
  
    # # Calculate relative heights--This is generic to allow switching back to format where all characteristics are shown in a single page
    # sites_per_char <- dat %>% dplyr::arrange(CharacteristicName) %>% dplyr::distinct(CharacteristicName, MonitoringLocationIdentifier) %>% dplyr::count(CharacteristicName) %>% dplyr::ungroup() 
    # sites_per_char <- sites_per_char[order(sites_per_char$CharacteristicName),] %>% dplyr::pull(n) # For some absurd reason, dplyr::arrange() is not competent in sorting so using base R to sort
    
    # temp_distinct <- dat %>%
      # dplyr::select(CharacteristicName, MonitoringLocationIdentifier, TimeUnit) %>% dplyr::distinct()
    # rel_char_hts <- prop.table(sites_per_char) ### YES!!! This gets the heights correct. No need to try to account for title or x-axis labels, etc.--it's already adjusted for

  # A ggplot object with NO data.  Omit the characteristic from the facet_grid call
    freq <- switch(input$sel_TimeSubunit, Season = "season", Mnth = "month")
  p_title <- paste0(unique(dat$CharSampleType), ", # of surveys per ", freq)
  p <- ggplot(dat) +
    aes(x = Yr, y = TimeUnit, fill = FillCol) +
    geom_tile(color = "gray") +
    suppressWarnings(geom_text(aes(label = FillCol, colour = ifelse(FillCol > 5, "white", "black")))) +
    scale_colour_manual(values=c("white"="white", "black"="black"), guide = "none") +
    xlab(rv_param_temp$seasonType) +
    labs(title = p_title) +
    scale_x_continuous(expand=c(0, 0), breaks = seq(from = min(dat$Yr, na.rm = TRUE), to = max(dat$Yr, na.rm = TRUE), by = ifelse(diff(range(dat$Yr, na.rm = TRUE)) > 10, 2, 1)), limits = c(min(dat$Yr, na.rm = TRUE)-1, max(dat$Yr, na.rm = TRUE)+1)) + # Need to make limits wider b/c otherwise the fill color will be missing from the end columns. Setting the expand cuts out the empty space at beginning and end columns
    scale_y_discrete(limits = rev) +
        # scale_fill_viridis_c(direction = -1, na.value = "white", limits=c(1, max_colorval), name = legend_name) +
    scale_fill_viridis_c(direction = -1, na.value = "white", limits=c(1, 12), oob=scales::squish, breaks = seq(1, 12, by = 2), name = legend_name) +
    theme_bw(base_size = 14) +
    lemon::facet_rep_wrap(~MonitoringLocationIdentifier, ncol =1, repeat.tick.labels = "bottom") +
    theme(legend.position="top",
          plot.title = element_text(size = 22)) +
          # axis.text.x = element_text(angle = 90, hjust = 1)) +
    theme(plot.margin=unit(c(3,3,1,2),"lines"))
print("779")
#   # Build a separate graphic for each Characteristic
#   char_list <- lapply(sort(unique(dat$CharacteristicName)), function(i) {
#     p %+% 
#       subset(dat, CharacteristicName == i) + ggtitle(paste0(i, " (# of surveys per ", input$sel_TimeSubunit, ")"))
#     })
#   names(char_list) <-sort(unique(dat$CharacteristicName))
#   print("785")
#   # Build as Grobs and plot via gridExtra::grid.arrange
#   final_heat_plots <- char_list %>%
#     lapply(ggplotGrob) %>%
#     arrangeGrob(grobs = ., heights = rel_char_hts) %>%
#     grid.arrange(., ncol = 1)
# print("791")
#   return(final_heat_plots)
return(p)
}

FuncPlotlyPieMatrix <- function(dat, discrete_cols, discrete_levels, plot_title) {
  # Function to create plotly pie chart matrix of Threshold or Percentile categories, grouped by monitoring site (row) and year (col)
  #
  # Args:
  #   dat:  Plot data with percentile/threshold classifications
  #   discrete_cols: For discrete fill, the vector of colors
  #   discrete_levels: For discrete fill, the levels corresponding with colors
  #   plot_title: Title for plot page
  #
  # Returns:
  #   Page of plotly pie charts
  #
  fig <- plot_ly(textfont = list(size = 25))
  colors_list <- split(discrete_cols, discrete_levels)
  m <- list(
    l = 300,
    r = 90,
    b = 100,
    t = 100,
    pad = 0
  )
  
  dat$Color <- dplyr::recode(dat$CategVar, !!!colors_list)
  yr_vec <- seq(from = min(dat$Yr, na.rm = TRUE), to = max(dat$Yr, na.rm = TRUE), by = 1)
  
  
  for(row_num in 1:length(unique(dat$RowLev))) {
    row_filter <- sort(unique(dat$RowLev))[row_num]
    for(yr_num in 1:length(yr_vec)) {
      this_yr <- yr_vec[yr_num]
      pie_dat = subset(dat, RowLev == row_filter & Yr == this_yr)
      if(nrow(pie_dat)>0) {  
      fig <- fig %>% 
        add_pie(data = pie_dat,
                name = paste0(row_filter, "_", this_yr),
                labels = ~CategVar, 
                values = ~n,
                textposition = 'inside',
                textinfo = 'label+percent',
                insidetextfont = list(color = switch(("yellow" %in% discrete_cols)+1, "white", "black")),
                hoverinfo = 'text',
                text = ~HoverLabel,
                marker = list(colors = ~Color, line = list(color = '#FFFFFF', width = 1)),
                domain = list(row = row_num-1, column = yr_num-1))
    }
  }
  }
  
  width_px <- 420 + (110 * length(yr_vec)) # this is the plot width (paper)
  height_px <- 200 + (110 * length(unique(dat$RowLev))) # this is the plot height (paper)

  yr_seq_px <- seq(55, width_px-420, by = 110)/(110 * length(yr_vec)) # this is where year labels should align on x-axis, when reference is "paper"
  y_seq_px <- seq(55, height_px-55, length.out = length(unique(dat$RowLev)))/height_px
  title_loc <- 1 + (90/height_px) #it's into the top margin space, when reference is "container"
  legend_loc <- 1 + (50/height_px)
  yrs_loc_bottom <- -1 * (50/height_px)
  
  yr_labels_bottom <- list(
  text = as.list(as.character(yr_vec)),
  xref = "paper",
  yref = "container",
  yanchor = "center",
  xanchor = "center",
  font =list(size = 14),
  align = "right",
  x = yr_seq_px,
  y = yrs_loc_bottom,
  showarrow = FALSE)
  
  y_labels_left <- list(
    text = as.list(sort(unique(dat$RowLev), decreasing = TRUE)),
    xref = "paper",
    yref = "paper",
    xanchor = "right",
    yanchor = "center",
    font =list(size = 14),
    align = "center",
    x = -0.02,
    y = y_seq_px,
    showarrow = FALSE)
  
  fig_final <- fig %>% layout(
    margin = m,
    title = list(
      text = plot_title,
      x = 0.5,
      y = title_loc,
      xref = "container", # gets cut off if referenced to the plot only ("paper")
      yref = "paper",
      xanchor = "center",
      yanchor = "center"),
    showlegend = TRUE,
    legend = list(
      orientation = "h",
      x = 0.5,
      xref = "container",
      yref = "paper",
      xanchor = "center",
      y = legend_loc,
      yanchor = "center"),
    grid=list(
      rows=length(unique(dat$RowLev)),
      columns=length(yr_vec)),
    width = width_px,
    height = height_px,
    autosize = FALSE,
    annotations = y_labels_left) 
  
  fig_final <- fig_final %>% layout(annotations = yr_labels_bottom)

  fig_final
  return(fig_final)
}

FuncPlotDat <- function() {
  # Function to format plot data based on user selections on plot page
  #
  # Returns:
  #   Formatted plot data

  shiny::req(!is.null(rv_param_temp$subDat), !is.null(rv_param_temp$sel_summarize_by))
  # Filter plotting data by user inputs
  plotDat <- rv_param_temp$subDat %>%
    dplyr::select(ActivityStartDate, CharacteristicName, CharacteristicSet, CharSampleType, DetectionQuantitationLimitMeasure.MeasureValue, MonitoringLocationIdentifier, OrganizationFormalName, ResultDetectionConditionText, DetectionQuantitationLimitTypeName, ResultMeasureValue, ResultMeasureValue_replaced, ResultMeasure.MeasureUnitCode, ResultSampleFractionText, ThreshCateg, YrDate, MnthDate, WkDate, Yr, Season, Mnth, Wk, DayOfYr) %>% # just keep these columns
    dplyr::filter(MonitoringLocationIdentifier %in% rv_param_temp$showStations & CharSampleType %in% rv_param_temp$showCharTypes)
  plotDat$ResultMeasureValue <- as.numeric(plotDat$ResultMeasureValue)
  plotDat$DetectionQuantitationLimitMeasure.MeasureValue <- as.numeric(plotDat$DetectionQuantitationLimitMeasure.MeasureValue)
  
    
    # If assigning CUSTOM threshold limits, just update with plot data--not with the filtered data (those should keep the limits from an imported threshold file)
  
    if(all(!is.null(rv_param_temp$sel_show_thresholds), !is.null(input$sel_ThreshLower), !is.na(input$sel_ThreshLower), !is.null(input$sel_ThreshCateg1), !is.null(input$sel_ThreshCateg2), !is.null(input$sel_NumThresh), !is.null(plotDat))) {
    if(all(rv_param_temp$sel_show_thresholds == "showthresh_custom", rv_param_temp$sel_summarize_by == "by_chartype", identical(unique(plotDat$CharSampleType), rv_param_temp$showCharTypes), input$sel_NumThresh > 0)) {
      
      if(input$sel_NumThresh == 1) {
        cut_breaks <- c(-Inf, input$sel_ThreshLower, Inf)
        cut_categ <- c(input$sel_ThreshCateg1, input$sel_ThreshCateg2)
      }
      
      if(all(input$sel_NumThresh == 2, !is.null(input$sel_ThreshUpper), !is.na(input$sel_ThreshUpper))) {
        cut_breaks <- c(-Inf, input$sel_ThreshLower, input$sel_ThreshUpper, Inf)
        cut_categ <- c(input$sel_ThreshCateg1, input$sel_ThreshCateg2, input$sel_ThreshCateg3)
      }
      
      rv_param_temp$threshCustom <- list() # this is for plot backgrounds
      rv_param_temp$threshCustom[[unique(plotDat$CharSampleType)]] <- list(
        CharSampleType = unique(plotDat$CharSampleType), 
        ResultSampleFractionText = unique(plotDat$ResultSampleFractionText), 
        ResultMeasure.MeasureUnitCode = unique(plotDat$ResultMeasure.MeasureUnitCode), 
        Notes = NA, 
        cut_breaks = cut_breaks, 
        cut_categ = cut_categ)
      
      plotDat$ThreshCateg <- NA # this is for calculating pie charts
      plotDat$ThreshCateg <- as.character(cut(as.numeric(plotDat$ResultMeasureValue_replaced), breaks = cut_breaks, labels = cut_categ))
        }
      } else {
        rv_param_temp$threshCustom <- NULL
        }# end assign custom threshold limits

    # Determine quantiles for plots
  if(any(is.null(input$sel_AddQuantile), input$sel_AddQuantile == FALSE, is.null(input$sel_QuantileProbLower), is.null(input$sel_QuantileProbUpper))) {
      rv_param_temp$quantDat <- NULL
    } else {

      if(rv_param_temp$sel_summarize_by == "by_station" | (rv_param_temp$sel_summarize_by == "by_chartype" & input$sel_QuantileGroupBy == "quant_each"))  { # if 'by_station' or if 'by_chartype' and calculating separate quantile for each station, then group data by station-characteristicname
        rv_param_temp$quantDat <- plotDat %>%
          dplyr::select(MonitoringLocationIdentifier, CharacteristicName, ResultMeasureValue_replaced) %>%
          dplyr::group_by(MonitoringLocationIdentifier, CharacteristicName) %>%
          dplyr::summarise(QuantLineLower = quantile(ResultMeasureValue_replaced, probs = input$sel_QuantileProbLower, na.rm = TRUE),
                    QuantLineUpper = quantile(ResultMeasureValue_replaced, probs = input$sel_QuantileProbUpper, na.rm = TRUE)) # data frame where each row has a monitoring station ID and the value for the user-defined quantile probability
      }
      
      if(rv_param_temp$sel_summarize_by == "by_chartype" & input$sel_QuantileGroupBy == "quant_all") { # if 'by_chartype' and calculating one quantile across all stations
        rv_param_temp$quantDat <- data.frame(
          MonitoringLocationIdentifier = sort(unique(plotDat$MonitoringLocationIdentifier)),
          CharacteristicName = sort(unique(plotDat$CharacteristicName)),
          QuantLineLower = as.numeric(quantile(plotDat$ResultMeasureValue_replaced, probs = input$sel_QuantileProbLower, na.rm = TRUE)),
          QuantLineUpper = as.numeric(quantile(plotDat$ResultMeasureValue_replaced, probs = input$sel_QuantileProbUpper, na.rm = TRUE)),
          stringsAsFactors = FALSE)
      }
    }

    # Finalize the plotDat
    # Add quantDat columns
    if(!is.null(rv_param_temp$quantDat)) {
        plotDat2 <- plotDat %>%
          left_join(data.frame(rv_param_temp$quantDat), by = setdiff(names(rv_param_temp$quantDat), c("QuantLineLower", "QuantLineUpper"))) %>%
          dplyr::mutate(PercCateg = ifelse(ResultMeasureValue_replaced > QuantLineUpper, "above", ifelse(ResultMeasureValue_replaced < QuantLineLower, "below", ifelse(ResultMeasureValue_replaced >= QuantLineLower & ResultMeasureValue_replaced <= QuantLineUpper, "between", NA))))
        plotDat2$PercCateg <- factor(plotDat2$PercCateg, levels = c("below", "between", "above"))
    } else {
      plotDat2 <- plotDat %>%
        dplyr::mutate(PercCateg = NA)
    }
  
    return(plotDat2)
  }
 
FuncGageDat <- function(gage_station) {
  # Function to summarize gage data for plotting
  #
  # Args:
  #   gage_station: Name of the gage station to summarize data of
  #
  # Returns:
  #   Streamflow data for the selected gage station, and limited to the range of dates for which data will be plot

  shiny::req(!is.null(rv_param_temp$plotDat), !is.null(rv$gagesDat), !is.null(rv$importSettings$sel_DefineSeasons))
  shiny::validate(need(gage_station %in% unique(rv$gagesDat$GageName), message = "Streamflow data not available for the selected gage station"))
  gageDat <- subset(rv$gagesDat, GageName == gage_station & ActivityStartDate >= min(rv_param_temp$plotDat$ActivityStartDate, na.rm = TRUE) & ActivityStartDate <= max(rv_param_temp$plotDat$ActivityStartDate, na.rm = TRUE)) %>%
    dplyr::ungroup()
  
  # Assign custom seasons if applicable
  if(nrow(gageDat) > 0 & rv$importSettings$sel_DefineSeasons %in% c("WaterSeasons", "CustomSeasons"))
    {
    gageDat <- FuncCustomSeasons(dat_df = gageDat, seas = rv$importSettings$sel_DefineSeasons)
  }
  
  # Assign water year if applicable
  if(rv$importSettings$sel_DefineSeasons=="WaterSeasons") {
    gageDat$Yr <- gageDat$WaterYr
    gageDat$Mnth <- factor(gageDat$Mnth, levels(gageDat$Mnth)[c(10,11,12,1:9)])
    } else {
      gageDat$Yr <- gageDat$MeteoYr
      gageDat$Mnth <- factor(gageDat$Mnth, levels(rv$dat$Mnth))
    }
  
  if(!is.null(gageDat) & sum(!is.na(gageDat$MeanDailyDischarge)) == 0) {
        showModal(modalDialog(
          title = "No Data",
          "Streamflow data for the selected gage station do not overlap the timespan of water quality data."
          # , footer = modalButton("OK")
          ))
    gageDat <- NULL
        }
    
  return(gageDat)
} 

FuncPrecipDat <- function(precip_station) {
  # Function to summarize precipitation data for plotting. Use mean rather than total for each month, in case missing data
  #
  # Args:
  #   precip_station: Name of the precipitation station to summarize data of
  #
  # Returns:
  #   Precipitation data for the selected weather station, and limited to the range of dates for which data will be plot

  shiny::req(!is.null(rv_param_temp$plotDat), !is.null(rv$meteoDat), !is.null(rv$selectedMeteo))
  shiny::validate(need(precip_station %in% unique(rv$meteoDat$MeteoName), message = "Precipitation data not available for the selected weather station"))
  precipDat <- subset(rv$meteoDat, MeteoShortID == rv$selectedMeteo$MeteoShortID[rv$selectedMeteo$MeteoName == precip_station] & ActivityStartDate >= min(rv_param_temp$plotDat$ActivityStartDate, na.rm = TRUE) & ActivityStartDate <= max(rv_param_temp$plotDat$ActivityStartDate, na.rm = TRUE)) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(MeteoName = precip_station)
  
    # Assign custom seasons if applicable
  if(nrow(precipDat) > 0 & rv$importSettings$sel_DefineSeasons %in% c("WaterSeasons", "CustomSeasons"))
    {
    precipDat <- FuncCustomSeasons(dat_df = precipDat, seas = rv$importSettings$sel_DefineSeasons)
  }
  
  # Assign water year if applicable
  if(rv$importSettings$sel_DefineSeasons=="WaterSeasons") {
    precipDat$Yr <- precipDat$WaterYr
    precipDat$Mnth <- factor(precipDat$Mnth, levels(precipDat$Mnth)[c(10,11,12,1:9)])
    } else {
      precipDat$Yr <- precipDat$MeteoYr
      precipDat$Mnth <- factor(precipDat$Mnth, levels(rv$dat$Mnth))
    }

  return(precipDat)
} 

FuncPlotlyFormat <- function(plotly_list, plotly_title, subplot_titles_vec = NULL, xlab, shared_ylab = NULL, shared_ylab_position = NULL, ylab_vec = NULL, total_height, top_margin = 30, bottom_margin = 20, left_margin = 80, right_margin = 60, is_grouped_boxplots = FALSE) {  # changed top margin from 120 and removed page title
  # Function to arrange interactive plots from a list. Necessary because plotly does not format well just with grid.arrange or ggplot faceting
  #
  # Args:
  #   plotly_list: Lists of ggplots that will be generated as a set.
  #   plotly_title: Title for plot set.
  #   subplot_titles_vec: Vector of subplot titles
  #   xlab: X-axis label.
  #   shared_ylab: A single y-axis label to be shared across all subplots.
  #   shared_ylab_position: A number (usually negative) indicating location of a shared y-axis label
  #   ylab_vec: Vector of y-axis labels
  #   total_height: Total height for the plot set.
  #   top_margin...right_margin: Margin sizes that will be used for the final page
  #   is_grouped_boxplots: Logical--need additional code if grouped boxplots
  #
  # Returns:
  #   Formatted plotly for a set of plots
  # 
  out_list <- list()
  for(p in 1:length(plotly_list)) {
    temp_plot <- ggplotly(
      plotly_list[[p]],
      tooltip = "text",
      height = total_height
      ) %>% # specify the total plot height here because this layout will be applied to the entire page
      layout(
        # title = list( # this is the title for the page
        #   font = list(size = 18),
        #   text = plotly_title,
        #   yanchor = "bottom",
        #   y=0.98), # title margin does not seem to change anything
        margin = list(
          t=top_margin,
          b=bottom_margin,
          l= left_margin,
          r=right_margin),
        xaxis = list(
          title = xlab,
          titlefont = list(size = 14),
          font = list(size = 16, family = "Arial"),
          showspikes = TRUE,
          spikemode  = "across", # draw line across plots and to x-axis
          spikedash = "solid",
          spikecolor = "gray",
          spikesnap = "data",
          spikethickness = 2))
    
    # If adding a shared y-axis title...
    if(!is.null(shared_ylab)) {
      temp_plot %<>%
        layout(
          annotations = list(
            x = shared_ylab_position,
            y = 0.55,
            text = shared_ylab,
            showarrow = F, 
            xref="paper",
            yref="paper",
            xanchor="left",
            yanchor="middle",
            textangle=-90,
            font=list(size=16, family = "Arial", color="black")
          ))
      }
    
    # If adding subplot titles...
    if(!is.null(subplot_titles_vec)) {
      temp_plot %<>%
        layout(
          annotations = list(
            text = subplot_titles_vec[[p]],
            xref = "paper",
            yref = "paper",
            yanchor = "top",
            xanchor = "middle",
            x = 0.5,
            y = 1.2,
            showarrow = FALSE,
            font=list(size=16, family = "Arial", color="black")
          ))
    }
    
    # If adding individual y-axis titles...
    if(!is.null(ylab_vec)) {
      temp_plot %<>% 
        layout(
          yaxis = list(
            title = ylab_vec[p], 
            titlefont = list(size = 14),
            font = list(size = 16, family = "Arial")) # font size and family for y-axis
        )
    }
    
    if(is_grouped_boxplots) { # if boxplots for multiple stations, all combined
      temp_plot %<>% layout(boxmode = "group") # Will generate a false warning -- this is a known, unresolved issue with plotly (issue was closed due to low priority)
    }
    
    out_list[[p]] <- plotly::hide_legend(temp_plot) # this doesn't work for heatmap continuous colors
  }
  return(out_list)
}

FuncQuantLines <- function(quant_df, combine_sites, dat_df, p) {
  if(!is.null(quant_df)) {
    if(nrow(quant_df)>0) {
      # ...if stations will all be in a single plot and quantLine is by station...
      if(rv_param_temp$sel_summarize_by == "by_chartype" & combine_sites==TRUE & length(unique(dat_df$MonitoringLocationIdentifier)) > 1) {
        if(length(unique(quant_df$QuantLineLower)) > 1 | length(unique(quant_df$QuantLineUpper)) > 1) {
          showModal(modalDialog(
            title = "Percentile by Monitoring Site",
            "When combining monitoring sites in a plot, the percentile limits must be calculated across all sites rather than by individual sites"
            ))
          shiny::req(length(unique(quant_df$QuantLineLower)) == 1, length(unique(quant_df$QuantLineUpper)) == 1)
        }
        }
      p <- p +
        geom_hline(data = quant_df %>% dplyr::filter(CharacteristicName==sort(unique(dat_df$CharacteristicName)) & MonitoringLocationIdentifier==sort(unique(dat_df$MonitoringLocationIdentifier))), aes(yintercept = QuantLineLower), linetype = "dashed", color = "red") +
        geom_hline(data = quant_df %>% dplyr::filter(CharacteristicName==sort(unique(dat_df$CharacteristicName)) & MonitoringLocationIdentifier==sort(unique(dat_df$MonitoringLocationIdentifier))), aes(yintercept = QuantLineUpper), linetype = "solid", color = "red")
    }
  }
  return(p)
  }

FuncAddThresh <- function(v_char, thresh, p, xlow_temp = NULL, xhigh_temp = NULL, ylow_temp, yhigh_temp) {
  # Function to add threshold background color
  #
  # Args:
  #   v_char:  Characteristic Name
  #   thresh: NULL or the list for threshold background colors for this site-char
  #   p: Base plot
  #   xlow_temp, xhigh_temp, ylow_temp, yhigh_temp: lower/upper x/y limits for threshold box
  #
  # Returns:
  #   Plot with threshold background
  #
  print("IN FUNCADDTHRESH")
    for (i in 1:length(thresh$cut_categ)) {
      ylow = max(thresh$cut_breaks[i], ylow_temp)
      yhigh = min(thresh$cut_breaks[i+1], yhigh_temp)
      if(ylow <= yhigh) {
        fill_col = switch(thresh$cut_categ[i], "good" = rv_param_temp$threshColors[1], "caution" = rv_param_temp$threshColors[2], "poor" = rv_param_temp$threshColors[3])
        p <- p +
          geom_rect(data = data.frame(ylow, yhigh), aes(xmin = xlow_temp, xmax = xhigh_temp, ymin = ylow, ymax = yhigh), fill = fill_col, alpha = 0.15, show.legend = FALSE, inherit.aes = FALSE)
      }
    } # threshold background boxes
  return(p)
}

FuncPlotScatter <- function(plot_dat, quant_df = NULL, categ_df = NULL, x_nam = "ActivityStartDate", combine_sites, fixed_free_y = "fixed", add_loess = TRUE, incl_cens = FALSE, thresh_list = NULL, rotate_x = FALSE, gage_dat = NULL, precip_dat = NULL, month_summary = FALSE, sel_add_gage_precip = NULL, sel_categ, trans_log_y) {
  # Function to generate scatterplot of data, with censored values shown as dotted intervals
  #
  # Args:
  #   plot_dat:  A data frame with the raw data
  #   quant_df:  A data frame with quantile probability limits for each station
  #   categ_df: NULL or the imported categorical levels dataframe
  #   x_nam: Column name for x-axis variable
  #   combine_sites:  TRUE to combine multiple stations in a single plot of a characteristic
  #   fixed_free_y:  Are scales fixed or free across all plots?
  #   add_loess:  Add loess smooth? (will be biased by censored data)
  #   thresh_list: NULL or the list for threshold background colors
  #   incl_cens: Should censored data be plot as intervals?
  #   rotate_x: should x-axis labels be rotated?
  #   gage_dat: USGS gage station data, if streamflow plot should be included: otherwise, NULL
  #   precip_dat: weather station data, if precipitation plot should be included; otherwise, NULL
  #
  # Returns:
  #   List of scatterplot
  # 

  shiny::req(sum(!is.na(plot_dat$y)) > 0) # make sure there are data

  # All plots share a single x-axis. Don't need to do this for other x_nam because those are factors with specified levels.
if(x_nam == "ActivityStartDate") {
  xaxes_min = min(plot_dat$x, na.rm = TRUE)
  xaxes_max = max(plot_dat$x, na.rm = TRUE)
}

  # Create column for point shape
  plot_dat %<>% dplyr::mutate(
    pointShape = factor(ifelse(ResultDetectionConditionText == "Detected and Quantified", "quant", "censored"))) # filled circle (shape = 16) if the datum was detected and quantified, otherwise open circle (shape 1)

  # Create the water quality plot(s)
  p1_points_list <- list()
  print("line1434")
  
  if(rv_param_temp$sel_summarize_by == "by_chartype" & combine_sites==TRUE) {
    unique_df <- plot_dat %>% dplyr::select(CharSampleType) %>% dplyr::distinct() # If combining sites, then data frame has only column of CharSampleType
  } else {
    unique_df <- plot_dat %>% expand(CharSampleType, MonitoringLocationIdentifier) %>% arrange(CharSampleType, MonitoringLocationIdentifier) # If sites are separate plots, data frame of unique CharSampleType-sites
  print("line586")
  }
  
  char_vec <- unique_df$CharSampleType # vector of the CharSampleTypes, including duplicates
  print("line588")
  for (v in 1:nrow(unique_df)) { # for each df row
    
    current_chartype <- unique_df$CharSampleType[v]
    dat_df <- plot_dat %>%
      dplyr::filter(CharSampleType == current_chartype) # subset the data frame to the CharSampleTypes of interest
    
    if("MonitoringLocationIdentifier" %in% names(unique_df)) {
      dat_df %<>% 
        dplyr::filter(MonitoringLocationIdentifier == unique_df$MonitoringLocationIdentifier[v])
    }
    
    trans_y <- ifelse(all(!is.null(trans_log_y), current_chartype %in% trans_log_y), "log", "identity")
               
    print("line592")
    
    # Shared y-axes range
    yaxes_min_temp = switch(all(fixed_free_y=="fixed", length(unique(char_vec)) < 2)+1, min(dat_df$y, dat_df$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE), min(plot_dat$y, plot_dat$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE)) # y axis limits. If only one characteristic name and free_fixed_y=="fixed", calculate y-axis limits from the full plot_dat
    shiny::req(!is.null(yaxes_min_temp))
    yaxes_min = switch((yaxes_min_temp <= 0)+1, 0.9*yaxes_min_temp, yaxes_min_temp - 0.1)
    yaxes_max = switch(all(fixed_free_y=="fixed", length(unique(char_vec)) < 2)+1, 1.1*max(dat_df$y, dat_df$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE), 1.1*max(plot_dat$y, plot_dat$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE))
    print("line1448")
    
    # Set up the plot...
    if(x_nam=="ActivityStartDate") {
      p_points <- ggplot(data = dat_df, aes(x = x, y = y)) +
        scale_x_date(date_breaks = "1 year", date_labels = "%Y", limits = c(xaxes_min, xaxes_max))
    } else { # For seasonal plots
      dat_df$x <- as.numeric(dat_df$x)
      p_points <- ggplot(data = dat_df, aes(x = x, y = y))
      
      if(x_nam %in% c("DayOfYr", "Wk")) {
        p_points <- p_points + 
        scale_x_continuous(breaks = scales::breaks_pretty())
        } else { # for categorical x-axis
          p_points <- p_points +
          scale_x_continuous(breaks = 1:length(levels(plot_dat$x)), labels = levels(plot_dat$x))
        }
        }
    
   print("line1465") 
   
     # If adding threshold background...
   if(!is.null(thresh_list)){
     names(thresh_list) <- tolower(names(thresh_list))
   
      if(!is.null(thresh_list[[tolower(current_chartype)]])) {
        p_points <- FuncAddThresh(v_char = current_chartype, thresh = thresh_list[[tolower(current_chartype)]], p = p_points, xlow_temp = switch((x_nam=="ActivityStartDate")+1, 0.5, xaxes_min), xhigh_temp = switch((x_nam=="ActivityStartDate")+1, length(levels(plot_dat$x)) + 0.5, xaxes_max), ylow_temp = yaxes_min, yhigh_temp = yaxes_max)}
   }
    
    print("line623")
    # ...if coloring by a categorical characteristic, set up the data...
    if(sel_categ != "none" & !is.null(categ_df)) {
      levs <- unlist(base::strsplit(stringr::str_replace_all(categ_df$CategOrder[categ_df$CharSampleType == sel_categ], "[()]", ""), split="//")) # these are the categorical levels from the category import file--pull from there rather than from data to ensure no levels are omitted just because they were not in the data
      levels_ok <- all(na.exclude(unique(plot_dat$CategResultMeasureValue[plot_dat$CategName == sel_categ])) %in% levs)
      shiny::req(!is.null(levels_ok))
      if(!levels_ok) { # Discontinue if category levels in data don't match levels in imported category file
        showModal(modalDialog(
          title = "Categorical levels mismatch",
          paste0("At least one categorical level found in the data (", paste(sort(na.exclude(unique(plot_dat$CategResultMeasureValue[plot_dat$CategName == sel_categ]))), collapse = ", "), ") is not included in the levels imported from the  category file (", paste(sort(levs), collapse = ", "), "). Please amend the category file to match the data."))
        )}
      dat_df$CategResultMeasureValue <- factor(dat_df$CategResultMeasureValue, levels = levs)
      cols <- unlist(base::strsplit(stringr::str_replace_all(categ_df$CategColor[categ_df$CharSampleType == sel_categ], "[()]", ""), split="//"))
      names(cols) <- levs # create a named color vector to use as palette
      print("line1488")
      p_points <- p_points +
        suppressWarnings(geom_point(aes(shape = pointShape, color = CategResultMeasureValue, fill = CategResultMeasureValue, text = paste0("<span style='font-size:12px; font-weight:bold;'>", MonitoringLocationIdentifier, "<br>", CharSampleType, "<br>Date: ", ActivityStartDate, "<br>Value: ", y, "<br>Detection Level: ", ResultDetectionConditionText, "<br>Categorical Level: ", CategResultMeasureValue, "</span>")), size = 2, show.legend = c(fill = FALSE, color = TRUE, shape = FALSE))) + # aesthetic text is for ggplotly tooltip. Gives warning that it's not recognized but it still works and it's the only way to also allow geom_smooth (weird)
        scale_fill_manual(values = cols, na.value = "black", drop = FALSE) +
        scale_color_manual(name = paste0(sel_categ, "     "), limits = levs, values = cols, na.value = "black", drop = FALSE) # specifying all possible values in limits is required to make sure they are not dropped from legend when not in data
  } else {

      # ..if combining sites for a single characteristic, so coloring by monitoring site...
      if(all(rv_param_temp$sel_summarize_by == "by_chartype", combine_sites==TRUE)) { # if coloring by monitoring site, use viridis color scale
        p_points <- p_points +
          suppressWarnings(geom_point(aes(shape = pointShape, color = MonitoringLocationIdentifier, fill = MonitoringLocationIdentifier, text = paste0("<span style='font-size:12px; font-weight:bold;'>", MonitoringLocationIdentifier, "<br>", CharSampleType, "<br>Date: ", ActivityStartDate, "<br>Value: ", y, "<br>Detection Level: ", ResultDetectionConditionText, "</span>")), size = 2, show.legend = c(fill = FALSE, color = TRUE, shape = FALSE))) + # this will give a false unknown aesthetics warning for 'text'
          scale_fill_viridis_d() +
          scale_color_viridis_d(name = "Site")
      } else { # ...if not coloring the points...
      p_points <- p_points +
        suppressWarnings(geom_point(aes(shape = pointShape, text = paste0("<span style='font-size:12px; font-weight:bold;'>", MonitoringLocationIdentifier, "<br>", CharSampleType, "<br>Date: ", ActivityStartDate, "<br>Value: ", y, "<br>Detection Level: ", ResultDetectionConditionText, "</span>")), size = 2, color = "black", show.legend = FALSE))
      }
  }
  print("line1506")
  # Shape the points for quantified vs. censored data
    p1_points <- p_points +
      scale_shape_manual(values = c("quant" = 16, "censored" = 1))
  
  # If including censored data...
  if(incl_cens) {
    dat_cens <- subset(dat_df, ResultDetectionConditionText %in% c("Present Below Quantification Limit", "Not Detected", "Present Above Quantification Limit"))
    if(nrow(dat_cens) > 0) {
      dat_cens$segment_start <- dat_cens$segment_end <- NA
      dat_cens$segment_start[dat_cens$ResultDetectionConditionText %in% c("Not Detected", "Present Below Quantification Limit")] <- yaxes_min # left-censored data
      dat_cens$segment_end[dat_cens$ResultDetectionConditionText %in% c("Not Detected", "Present Below Quantification Limit")] <- dat_cens[dat_cens$ResultDetectionConditionText %in% c("Not Detected", "Present Below Quantification Limit"), "DetectionQuantitationLimitMeasure.MeasureValue", drop = TRUE]
      dat_cens$segment_start[dat_cens$ResultDetectionConditionText == "Present Above Quantification Limit"] <- dat_cens[dat_cens$ResultDetectionConditionText == "Present Above Quantification Limit", "DetectionQuantitationLimitMeasure.MeasureValue", drop = TRUE]
      dat_cens$segment_end[dat_cens$ResultDetectionConditionText == "Present Above Quantification Limit"] <- yaxes_max
      p1_points <- p1_points +
        geom_segment(data = dat_cens, aes(x = x, xend = x, y = segment_start, yend = segment_end), linewidth = 0.25, linetype = "dotted")
    }
  }

  print("line1533")  
    # If adding loess smooth...
  if(add_loess) {
    # If plotting all stations on one plot, color by station
    if(rv_param_temp$sel_summarize_by == "by_chartype" & combine_sites==TRUE) {
      p1_points <- p1_points + 
        suppressWarnings(geom_smooth(aes(color = MonitoringLocationIdentifier, fill = MonitoringLocationIdentifier), method = "loess", se = FALSE, size = 0.5, alpha = 0.3, show.legend = FALSE, na.rm = TRUE, fullrange = FALSE)) +
        coord_cartesian(ylim = c(c(yaxes_min, yaxes_max)))

      } else {
        p1_points <- p1_points + 
          suppressWarnings(geom_smooth(method = "loess", se = FALSE, size = 0.5, alpha = 0.3, show.legend = FALSE, na.rm = TRUE, fullrange = FALSE)) +
          coord_cartesian(ylim = c(c(yaxes_min, yaxes_max)))
      }
    }
    
    # If plotting percentile lines...
  
    p1_points <- FuncQuantLines(quant_df = quant_df, combine_sites = combine_sites, dat_df = dat_df, p = p1_points)
print("line1551")  

  # Final formatting of plots
  p1_points <- p1_points +
    scale_y_continuous(trans = trans_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks(), limits = c(yaxes_min, yaxes_max)) + # alternatively, can use 'coord_cartesian(ylim = c(yaxes_min, yaxes_max))' to zoom in to the limits rather than "cutting off" the limits, as setting limits within scale_y_continuous() would do 
    theme_bw(base_size = 14) +
    {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
    {if(rotate_x) {theme(axis.title.x = element_text(margin = margin(t = 10, r = 0, b = 0, l = 0)))}} +
    theme(axis.title.y = element_blank(),
          legend.position = "top",
          legend.text = element_text(size = 16),
          legend.title = element_text(size = 16)) +
    guides(color=guide_legend(ncol=2))
  
  # Add monitoring site as facet label if separate plot per site
  if(combine_sites==FALSE) { 
    p1_points <- p1_points +
      facet_wrap(. ~ MonitoringLocationIdentifier, drop = TRUE, ncol = 1)
  }
  
  p1_points_list[[v]] <- p1_points
  }
  
  ## If adding streamflow plot... ----
  if(sel_add_gage_precip == "streamflow" & !is.null(gage_dat)) {
    trans_gage_y <- ifelse(all(!is.null(trans_log_y), "streamflow" %in% trans_log_y), "log", "identity")
    
    if(x_nam=="ActivityStartDate") {
      if(month_summary == TRUE) {
        gage_dat <- gage_dat %>%
        dplyr::mutate(x = MnthDate + 14) %>% # plot at mid-point of month (on x-axis) for streamflow time series
        dplyr::group_by(GageName, x) %>%
        dplyr::summarise(MnthMean_MeanDailyDischarge = round(mean(MeanDailyDischarge, na.rm = TRUE), 2), # summarize mean daily discharge for each month
                MnthMax_MeanDailyDischarge = round(max(MeanDailyDischarge, na.rm = TRUE), 2)) %>%
        dplyr::ungroup()
        
        gage_plot <- ggplot(gage_dat, aes(x = x)) +
        suppressWarnings(geom_line(aes(y = MnthMean_MeanDailyDischarge, group = 1, text = paste0("Gage Name: ", GageName, "<br>Mid-month date: ", x, "<br>Mean daily discharge (cfs), MEAN for month: ", MnthMean_MeanDailyDischarge)), linetype = "solid", colour = "blue")) +
        suppressWarnings(geom_line(aes(y = MnthMax_MeanDailyDischarge, group = 1, text = paste0("Gage Name: ", GageName, "<br>Mid-month date: ", x, "<br>Mean daily discharge (cfs), MAX for month: ", MnthMax_MeanDailyDischarge)), linetype = "dashed", colour = "blue")) + # for time series point plots, present data summarized by month
          scale_x_date(date_breaks = "1 year", date_labels = "%Y", limits = c(xaxes_min, xaxes_max))
      } else { # just plot the points
        gage_plot <- ggplot(gage_dat, aes(x = ActivityStartDate, y = MeanDailyDischarge)) +
        suppressWarnings(geom_point(aes(text = paste0("Gage Name: ", GageName, "<br>Survey date: ", ActivityStartDate, "<br><br>Mean daily discharge (cfs): ", MeanDailyDischarge)))) + 
        scale_x_date(date_breaks = "1 year", date_labels = "%Y", limits = c(xaxes_min, xaxes_max))
        
        # If loess smooth and NOT monthly summary...
        if(add_loess) {
          gage_plot <- gage_plot + 
            suppressWarnings(geom_smooth(method = "loess", se = FALSE, size = 0.5, alpha = 0.3, show.legend = FALSE)) +
            coord_cartesian(ylim = c(c(yaxes_min, yaxes_max)))
        } 
        }
    } else { # if seasonal plot...
        gage_dat$x <- as.numeric(gage_dat$x)
        gage_plot <- ggplot(gage_dat, aes(x = x, y = MeanDailyDischarge)) +
          suppressWarnings(geom_point(aes(text = paste0("Gage Name: ", GageName, "<br>Survey date: ", ActivityStartDate, "<br><br>X-value: ", x, "<br>Mean daily discharge (cfs): ", MeanDailyDischarge)), alpha = 0.5))
        
        # if(x_nam=="DayOfYr") {
        if(x_nam %in% c("DayOfYr", "Wk")) {
          gage_plot <- gage_plot +
            # scale_x_continuous(breaks = seq(from = 0, to = 366, by = 20))
            scale_x_continuous(breaks = scales::breaks_pretty())
          } else {
            gage_plot <- gage_plot +
          scale_x_continuous(breaks = 1:length(levels(plot_dat$x)), labels = levels(plot_dat$x))
          }
        
        # If loess smooth...
        if(add_loess) {
          gage_plot <- gage_plot + 
            stat_smooth(se = TRUE, level = 0.95, size = 0.5, alpha = 0.3, show.legend = FALSE)
        }
        }
    
    # Final formatting of streamflow plot...
    gage_plot <- gage_plot +
      scale_y_continuous(trans = trans_gage_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks()) +
        theme_bw(base_size = 14) +
        {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
        theme(axis.title.x = element_blank(),
              axis.title.y = element_blank(),
              legend.position = "none") +
        facet_wrap(. ~ GageName, ncol = 1) + # add the name as facet label
       theme(strip.background = element_rect(fill="lightblue")) # use different color facet strip background to distinguish from water characteristic plots
    } else {
    gage_plot <- NA # blank data frame
    }
  print("line1642")
  
   ## If adding precipitation plot... ----
  if(sel_add_gage_precip == "precipitation" & !is.null(precip_dat)) {
    
    trans_precip_y <- ifelse(all(!is.null(trans_log_y), "precipitation" %in% trans_log_y), "log", "identity")
    
    if(x_nam=="ActivityStartDate") {
      if(month_summary == TRUE) {
      precip_dat <- precip_dat %>%
        dplyr::mutate(x = MnthDate + 14) %>% # plot at mid-point of month (on x-axis) for precipitation time series
        dplyr::group_by(MeteoName, x) %>%
        dplyr::summarise(AvgPrecip_cm = round(mean(PRCP_cm, na.rm = TRUE), 2), # summarize precipitation for each month
                MaxPrecip_cm = round(max(PRCP_cm, na.rm = TRUE), 2)) %>%
        dplyr::ungroup()

      precip_plot <- ggplot(precip_dat, aes(x = x)) +
        suppressWarnings(geom_line(aes(y = AvgPrecip_cm, group = 1, text = paste0("Weather Station Name: ", MeteoName, "<br>Mid-month date: ", x, "<br>Daily precipitation (cm), MEAN for month: ", AvgPrecip_cm)), linetype = "solid", colour = "blue")) +
        suppressWarnings(geom_line(aes(y = MaxPrecip_cm, group = 1, text = paste0("Weather Station Name: ", MeteoName, "<br>Mid-month date: ", x, "<br>Daily precipitation (cm), MAX for month: ", MaxPrecip_cm)), linetype = "dashed", colour = "blue")) + # for time series point plots, present data summarized by month
        scale_x_date(date_breaks = "1 year", date_labels = "%Y", limits = c(xaxes_min, xaxes_max))
      } else { # just plot the points
      precip_plot <- ggplot(precip_dat, aes(x = ActivityStartDate, y = PRCP_cm)) +
        suppressWarnings(geom_point(aes(text = paste0("Weather Station Name: ", MeteoName, "<br>Survey date: ", ActivityStartDate, "<br><br>Daily precipitation (cm): ", PRCP_cm)))) + 
        scale_x_date(date_breaks = "1 year", date_labels = "%Y", limits = c(xaxes_min, xaxes_max))
      
      # If loess smooth and NOT monthly summary...
      if(add_loess) {
        precip_plot <- precip_plot + 
          suppressWarnings(geom_smooth(method = "loess", se = FALSE, size = 0.5, alpha = 0.3, show.legend = FALSE))
      } 
      }
      } else { # if seasonal plot...
        precip_dat$x <- as.numeric(precip_dat$x)
        precip_plot <- ggplot(precip_dat, aes(x = x, y = PRCP_cm)) +
          suppressWarnings(geom_point(aes(text = paste0("Weather Station Name: ", MeteoName, "<br>Survey date: ", ActivityStartDate, "<br><br>X-value: ", x, "<br>Daily precipitation (cm)): ", PRCP_cm)), alpha = 0.5))
        
        # if(x_nam=="DayOfYr") {
                if(x_nam %in% c("DayOfYr", "Wk")) {
          precip_plot <- precip_plot +
            # scale_x_continuous(breaks = seq(from = 0, to = 366, by = 20))
            scale_x_continuous(breaks = scales::breaks_pretty())
          } else {
            precip_plot <- precip_plot +
              scale_x_continuous(breaks = 1:length(levels(plot_dat$x)), labels = levels(plot_dat$x))
          }
    
    # If loess smooth...
    if(add_loess) {
      precip_plot <- precip_plot +
        suppressWarnings(geom_smooth(method = "loess", se = FALSE, size = 0.5, alpha = 0.3, show.legend = FALSE))
    }
  }
    
    # Final formatting of precipitation plot...
    precip_plot <- precip_plot +
      scale_y_continuous(trans = trans_precip_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks()) +
        theme_bw(base_size = 14) +
        {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
        theme(axis.title.x = element_blank(),
              axis.title.y = element_blank(),
              legend.position = "none") +
        facet_wrap(. ~ MeteoName, ncol = 1) + # add the name as facet label
       theme(strip.background = element_rect(fill="lightblue")) # use different color facet strip background to distinguish from water characteristic plots
    } else {
    precip_plot <- NA # blank data frame
  }

  return_list <- list(p1_points_list, char_vec, gage_plot, precip_plot)
  return(return_list)
  }

FuncPlotBox <- function(plot_dat, quant_df = NULL, x_nam = "Yr", combine_sites = FALSE, fixed_free_y = "fixed", add_loess = TRUE, incl_cens = FALSE, thresh_list = NULL, rotate_x = FALSE, gage_dat = NULL, precip_dat = NULL, sel_add_gage_precip = NULL, trans_log_y) {
  # Function to generate boxplots of data, with reporting limits marked as dotted horizontal lines
  #
  # Args:
  #   plot_dat:  A data frame with the raw data
  #   quant_df:  A data frame with quantile probability limits for each station
  #   x_nam: Column name for x-axis variable. For time series, this is "Yr"
  #   combine_sites:  TRUE to combine multiple stations in a single plot of a characteristic
  #   fixed_free_y:  Are scales fixed or free across all facets?
  #   incl_cens: Should reporting limits be marked as dotted horizontal lines?
  #   thresh_list: NULL or the list for threshold background colors
  #   rotate_x: should x-axis labels be rotated?
  #   gage_dat: USGS gage station data, if streamflow plot should be included: otherwise, NULL
  #   precip_dat: weather station data, if precipitation plot should be included; otherwise, NULL
  #   
  # Returns:
  #   List of boxplots
  # 
  
  shiny::req(sum(!is.na(plot_dat$y)) > 0) # make sure there are data
  
  # Create the water quality plot(s)
  p1_box_list <- list()
  
  if(rv_param_temp$sel_summarize_by == "by_chartype" & combine_sites==TRUE) {
    unique_df <- plot_dat %>% dplyr::select(CharSampleType) %>% dplyr::distinct()
  } else {
    unique_df <- plot_dat %>% expand(CharSampleType, MonitoringLocationIdentifier) %>% arrange(CharSampleType, MonitoringLocationIdentifier) # data frame of unique characteristic-sites
  }
  
  char_vec <- unique_df$CharSampleType
  
  for (v in 1:nrow(unique_df)) { # for each characteristic-site
     current_chartype <- unique_df$CharSampleType[v]
     
    dat_df <- plot_dat %>%
      dplyr::filter(CharSampleType == current_chartype)
    
    if("MonitoringLocationIdentifier" %in% names(unique_df)) {
      dat_df %<>% 
        dplyr::filter(MonitoringLocationIdentifier == unique_df$MonitoringLocationIdentifier[v])
    }
    
    trans_y <- ifelse(all(!is.null(trans_log_y), current_chartype %in% trans_log_y), "log", "identity")
  
  # Cutoffs for detection limits--draw these lines on plot, if within the range of y axes
  y_upperQL <- ifelse(any(!is.na(dat_df$DetectionQuantitationLimitMeasure.MeasureValue[dat_df$ResultDetectionConditionText == "Present Above Quantification Limit"])),  min(dat_df$DetectionQuantitationLimitMeasure.MeasureValue[dat_df$ResultDetectionConditionText == "Present Above Quantification Limit"], na.rm = TRUE), NA) # lowest upper quantification limit -- These may change through time, and we are only going to show the most conservative value 
  
  y_lowerQL <- ifelse(any(!is.na(dat_df$DetectionQuantitationLimitMeasure.MeasureValue[dat_df$ResultDetectionConditionText %in% c("Not Detected", "Present Below Quantification Limit")])), max(dat_df$DetectionQuantitationLimitMeasure.MeasureValue[dat_df$ResultDetectionConditionText %in% c("Not Detected", "Present Below Quantification Limit")], na.rm = TRUE), NA) # highest lower quantification limit

  # Shared y-axes range
  yaxes_min_temp = switch((fixed_free_y=="fixed" & length(unique(char_vec)) < 2)+1, min(dat_df$y, dat_df$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE), min(plot_dat$y, plot_dat$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE)) # y axis limits. If only one characteristic name and free_fixed_y=="fixed", calculate y-axis limits from the full plot_dat
  yaxes_min = ifelse(yaxes_min_temp <= 0, yaxes_min_temp - 0.1, 0.9*yaxes_min_temp)
  yaxes_max = switch((fixed_free_y=="fixed" & length(unique(char_vec)) < 2)+1, 1.1*max(dat_df$y, dat_df$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE), 1.1*max(plot_dat$y, plot_dat$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE))
  
  # Set up the plot..
  p_box <- ggplot(data = dat_df, aes(x = x, y = y)) 
  
  # if(x_nam=="DayOfYr") {
  if(x_nam %in% c("DayOfYr", "Wk")) {
    p_box <- p_box +
      # scale_x_discrete(breaks = seq(from = 0, to = 366, by = 20))
    scale_x_discrete(breaks = scales::breaks_pretty())
  } else {
    p_box <- p_box +
      scale_x_discrete(drop = FALSE)
  }
  
  # If adding threshold background...
  if(!is.null(thresh_list)){
    names(thresh_list) <- tolower(names(thresh_list))
    
    if(!is.null(thresh_list[[tolower(current_chartype)]])) {
      
    p_box <- FuncAddThresh(v_char = current_chartype, thresh = thresh_list[[tolower(current_chartype)]], p = p_box, xlow_temp = 0.5, xhigh_temp = length(levels(plot_dat$x)) + 0.5, ylow_temp = yaxes_min, yhigh_temp = yaxes_max)
    }
  }
    
  # If combining sites for a single characteristic, so coloring by monitoring site...
  if(rv_param_temp$sel_summarize_by == "by_chartype" & combine_sites==TRUE) { # if coloring by monitoring site, use viridis color scale
    p1_box <- p_box +
      geom_boxplot(aes(fill = MonitoringLocationIdentifier), alpha = 0.4, show.legend = c(fill = TRUE)) +
      scale_fill_viridis_d(name = "Site") + 
      guides(fill = guide_legend(direction = "horizontal")) + # can't seem to turn legend horizontal with theme(legend...)
      theme(legend.position = "top")
    } else {
      p1_box <- p_box + geom_boxplot()
    }
  
  # If including censored data...
  if(incl_cens) {
    if(!is.na(y_lowerQL) & y_lowerQL >= yaxes_min) { # add LQL line
      p1_box <- p1_box +
        geom_hline(yintercept = y_lowerQL, linetype = "dotted", color = "gray")
      }
    if(!is.na(y_upperQL) & y_upperQL <= yaxes_max) { # add UQL line
      p1_box <- p1_box +
        geom_hline(yintercept = y_upperQL, linetype = "dotted", color = "black")
    }
    }
  
  # If plotting percentile lines...
  p1_box <- FuncQuantLines(quant_df = quant_df, combine_sites = combine_sites, dat_df = dat_df, p = p1_box)
  
  # Final formatting of plots
  
  p1_box <- p1_box +
    scale_y_continuous(trans = trans_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks(), limits = c(yaxes_min, yaxes_max))  +
    theme_bw(base_size = 14) +
    {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
    {if(rotate_x) {theme(axis.title.x = element_text(margin = margin(t = 10, r = 0, b = 0, l = 0)))}} +
    theme(axis.title.y = element_blank())
  
  # Add monitoring site as facet label if separate plot per site
  if(combine_sites==FALSE) {
    p1_box <- p1_box +
      facet_wrap(. ~ MonitoringLocationIdentifier, drop = TRUE, ncol = 1)
    }
  
  p1_box_list[[v]] <- p1_box
  }
  
  # If adding streamflow plot...
  if(sel_add_gage_precip == "streamflow" & !is.null(gage_dat)) {
    trans_gage_y <- ifelse(all(!is.null(trans_log_y), "streamflow" %in% trans_log_y), "log", "identity")
    
    gage_box <- ggplot(gage_dat, aes(x = x, y = MeanDailyDischarge)) + 
      geom_boxplot() +
      {if(x_nam == "DayOfYr") {scale_x_discrete(breaks = seq(from = 0, to = 366, by = 20))} else {scale_x_discrete(drop = FALSE)}} +
      scale_y_continuous(trans = trans_gage_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks()) +
      theme_bw(base_size = 14) +
      {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
      theme(axis.title.x = element_blank(),
            axis.title.y = element_blank(),
            legend.position = "none") +
      facet_wrap(. ~ GageName, ncol = 1) + # add the name as facet label
      theme(strip.background = element_rect(fill="lightblue"))
    } else {
      gage_box <- NA # blank data frame
    }
  
  # If adding precipitation plot...
  if(sel_add_gage_precip == "precipitation" & !is.null(precip_dat)) {
    
    trans_precip_y <- ifelse(all(!is.null(trans_log_y), "precipitation" %in% trans_log_y), "log", "identity")
    
    precip_box <- ggplot(precip_dat, aes(x = x, y = PRCP_cm)) + 
      geom_boxplot() +
      {if(x_nam == "DayOfYr") {scale_x_discrete(breaks = seq(from = 0, to = 366, by = 20))} else {scale_x_discrete(drop = FALSE)}} +
      scale_y_continuous(trans = trans_precip_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks()) +
      theme_bw(base_size = 14) +
      {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
      theme(axis.title.x = element_blank(),
            axis.title.y = element_blank(),
            legend.position = "none") +
      facet_wrap(. ~ MeteoName, ncol = 1) + # add the name as facet label
      theme(strip.background = element_rect(fill="lightblue"))
    } else {
      precip_box <- NA # blank data frame
    }
  
  return_list <- list(p1_box_list, char_vec, gage_box, precip_box)
  return(return_list)
}
  
FuncPlotlyPieMatrix <- function(dat, discrete_cols, discrete_levels, plot_title) {
  # Function to create plotly pie chart matrix of Threshold or Percentile categories, grouped by monitoring site (row) and year (col)
  #
  # Args:
  #   dat:  Plot data with percentile/threshold classifications
  #   discrete_cols: For discrete fill, the vector of colors
  #   discrete_levels: For discrete fill, the levels corresponding with colors
  #   plot_title: Title for plot page
  #
  # Returns:
  #   Page of plotly pie charts
  #
  fig <- plot_ly(textfont = list(size = 25))
  colors_list <- split(discrete_cols, discrete_levels)
  m <- list(
    l = 300,
    r = 90,
    b = 100,
    t = 100,
    pad = 0
  )
  
  dat$Color <- dplyr::recode(dat$CategVar, !!!colors_list)
  yr_vec <- seq(from = min(dat$Yr, na.rm = TRUE), to = max(dat$Yr, na.rm = TRUE), by = 1)
  
  
  for(row_num in 1:length(unique(dat$RowLev))) {
    row_filter <- sort(unique(dat$RowLev))[row_num]
    for(yr_num in 1:length(yr_vec)) {
      this_yr <- yr_vec[yr_num]
      pie_dat = subset(dat, RowLev == row_filter & Yr == this_yr)
      if(nrow(pie_dat)>0) {  
      fig <- fig %>% 
        add_pie(data = pie_dat,
                name = paste0(row_filter, "_", this_yr),
                labels = ~CategVar, 
                values = ~n,
                textposition = 'inside',
                textinfo = 'label+percent',
                insidetextfont = list(color = switch(("yellow" %in% discrete_cols)+1, "white", "black")),
                hoverinfo = 'text',
                text = ~HoverLabel,
                marker = list(colors = ~Color, line = list(color = '#FFFFFF', width = 1)),
                domain = list(row = row_num-1, column = yr_num-1))
    }
  }
  }
  
  width_px <- 420 + (85 * length(yr_vec)) # this is the plot width (paper). The plot value used to be 110 (not 85). Changed from 390 to 420
  height_px <- 200 + (85 * length(unique(dat$RowLev))) # this is the plot height (paper)

  yr_seq_px <- seq(55, width_px-420, by = 85)/(85 * length(yr_vec)) # this is where year labels should align on x-axis, when reference is "paper"
  y_seq_px <- seq(55, height_px-55, length.out = length(unique(dat$RowLev)))/height_px
  title_loc <- 1.05 + (90/height_px) #it's into the top margin space, when reference is "container"- CHANGED THIS FROM 1 +
  legend_loc <- 1 + (50/height_px)
  yrs_loc_bottom <- -1 * (50/height_px)
  
  yr_labels_bottom <- list(
  text = as.list(as.character(yr_vec)),
  xref = "paper",
  yref = "container",
  yanchor = "center",
  xanchor = "center",
  font =list(size = 14),
  align = "right",
  x = yr_seq_px,
  y = yrs_loc_bottom,
  showarrow = FALSE)
  
  y_labels_left <- list(
    text = as.list(sort(unique(dat$RowLev), decreasing = TRUE)),
    xref = "paper",
    yref = "paper",
    xanchor = "right",
    yanchor = "center",
    font =list(size = 14),
    align = "center",
    x = -0.02,
    y = y_seq_px,
    showarrow = FALSE)
  
  fig_final <- fig %>% layout(
    margin = m,
    title = list(
      text = plot_title,
      x = 0.5,
      y = title_loc,
      xref = "container", # gets cut off if referenced to the plot only ("paper")
      yref = "paper",
      xanchor = "center",
      yanchor = "center"),
    showlegend = TRUE,
    legend = list(
      orientation = "h",
      x = 0.5,
      xref = "container",
      yref = "paper",
      xanchor = "center",
      y = legend_loc,
      yanchor = "center"),
    grid=list(
      rows=length(unique(dat$RowLev)),
      columns=length(yr_vec)),
    width = width_px,
    height = height_px,
    autosize = FALSE,
    annotations = y_labels_left) 
  
  fig_final <- fig_final %>% layout(annotations = yr_labels_bottom)

  fig_final
  return(fig_final)
}

FuncPlotList <- function(time_unit) {
  
  free_y = switch(is.null(input$sel_FreeY)+1, input$sel_FreeY, FALSE)
  sel_combine_sites = switch(is.null(input$sel_CombineSites)+1, input$sel_CombineSites, FALSE)
  trans_log_y = input$sel_log_y
  sel_add_gage_precip = switch(is.null(rv_param_temp$sel_add_gage_precip)+1, rv_param_temp$sel_add_gage_precip, "none")
  sel_categ = switch(is.null(input$sel_Categ)+1, input$sel_Categ, "none")
 
  plot_dat <- isolate(rv_param_temp$plotDat)
# Includes censored data
    incl_cens <- any(c("Present Below Quantification Limit", "Not Detected", "Present Above Quantification Limit") %in% unique(plot_dat$ResultDetectionConditionText)) # TRUE if there are any reporting limits
  
    if(time_unit == "ActivityStartDate" & input$sel_PlotType == "box") {time_unit <- "Yr"} # Box plots for time series are grouped by year
    
      plot_dat$x <- plot_dat[[time_unit]]
      plot_dat$y <- round(plot_dat[["ResultMeasureValue_replaced"]], 2)
      shiny::req(sum(!is.na(plot_dat$y)) > 0) # make sure there are data!
      
      # Thresholds
    thresh_list <- switch(rv_param_temp$sel_show_thresholds,
                          showthresh_file = rv_param_temp$threshList,
                          showthresh_custom = rv_param_temp$threshCustom,
                          showthresh_none = NULL)
      
    # Categorical data columns
      if(all(!is.null(input$sel_Categ), input$sel_Categ != "none", !is.null(rv_param_temp$categLevelsPlot))) {
        if(rv_param_temp$sel_summarize_by == "by_chartype") {
          shiny::validate(
            need(input$sel_CombineSites == FALSE, message = "Cannot color points by a categorical characteristic when multiple monitoring sites are combined in a single plot. Please UNSELECT the checkbox for 'Combine sites in one plot'"))
        }
        shiny::validate(
          need(input$sel_Categ %in% unique(rv_param_temp$subDatTypes$CharSampleType), message = "The selected categorical characteristic is not recognized as a categorical characteristic in the dataset."))
        plot_categ_dat <- rv_param_temp$subDat %>% # pulling from the filtered data
          dplyr::filter(CharSampleType == input$sel_Categ) %>%
          dplyr::select(OrganizationFormalName, ActivityStartDate, MonitoringLocationIdentifier, CategName = CharSampleType, CategResultMeasureValue = ResultMeasureValue) %>%
          dplyr::mutate(CategResultMeasureValue = toupper(CategResultMeasureValue)) %>%
          dplyr::distinct(.)

        plot_dat %<>% dplyr::left_join(plot_categ_dat, by = c("OrganizationFormalName", "MonitoringLocationIdentifier", "ActivityStartDate"))
        plot_dat$CategResultMeasureValue <- as.factor(plot_dat$CategResultMeasureValue)
        print("line1034")
    }
      # If adding streamflow data...
        if(any(sel_add_gage_precip!="streamflow", is.null(rv_param_temp$sel_gage_station), is.null(rv$gagesDat), is.null(rv$selectedGages))) {
          gageDat <- NULL
          gage_YScale <- NULL
        } else {
          gageDat <- FuncGageDat(gage_station = rv_param_temp$sel_gage_station)
          if(!is.null(gageDat)) {
            gage_YScale <- rv_param_temp$sel_gage_yscale
            } else {
              gage_YScale <- NULL
            }
        }
      # If adding precipitation data...
        if(any(sel_add_gage_precip!="precipitation", is.null(rv_param_temp$sel_precip_station), is.null(rv$meteoDat), is.null(rv$selectedMeteo))) {
          precipDat <- NULL
          precip_YScale <- NULL
        } else {
          precipDat <- FuncPrecipDat(precip_station = rv_param_temp$sel_precip_station)
          precip_YScale <- rv_param_temp$sel_precip_yscale
        }
      
      print("line1898")
      # For seasonal patterns...
      if(time_unit != "ActivityStartDate") {
        xseq = switch(time_unit,
                      Yr = seq(min(as.numeric(as.character(plot_dat$x)), na.rm = TRUE), max(as.numeric(as.character(plot_dat$x)), na.rm = TRUE), by = 1), # this is only for time series boxplots
                      Season = levels(plot_dat$Season), # c("Spring", "Summer", "Fall", "Winter"),
                      Mnth = levels(plot_dat$Mnth),
                      Wk = 1:53,
                      DayOfYr = 1:366 # account for leap year
                      )
        
        plot_dat$x <- factor(plot_dat$x, levels = xseq, labels = xseq)
        
        if(!is.null(gageDat)) {
          gageDat$x <- factor(gageDat[[time_unit]], levels = xseq, labels = xseq)
        }
        
        if(!is.null(precipDat)) {
          precipDat$x <- factor(precipDat[[time_unit]], levels = xseq, labels = xseq)
        }
      }
      if(!is.null(input$sel_PlotType)) {
        month_summary <- all(sel_add_gage_precip != "none", input$sel_PlotType %in% c("points", "points_smooth"))
      } else {
        month_summary <- FALSE
      }
  print("line1921")
    if(input$sel_PlotType %in% c("points", "points_smooth")) {

      ts_plot <- FuncPlotScatter(plot_dat = plot_dat, quant_df = rv_param_temp$quantDat, categ_df = rv_param_temp$categLevelsPlot, x_nam = time_unit, combine_sites = ifelse(length(unique(plot_dat$CharacteristicName)) == 1, ifelse(sel_combine_sites, TRUE, FALSE), FALSE), fixed_free_y = ifelse(free_y, "free_y", "fixed"), add_loess = ifelse(input$sel_PlotType == "points_smooth", TRUE, FALSE), incl_cens = incl_cens, thresh_list = thresh_list, rotate_x = TRUE, gage_dat = gageDat, precip_dat = precipDat, month_summary = month_summary, sel_add_gage_precip = sel_add_gage_precip, sel_categ = sel_categ, trans_log_y = trans_log_y)}

    if(input$sel_PlotType == "box") {
      ts_plot <- FuncPlotBox(plot_dat = plot_dat, quant_df = rv_param_temp$quantDat, x_nam = time_unit, combine_sites = ifelse(length(unique(plot_dat$CharacteristicName)) == 1, ifelse(sel_combine_sites, TRUE, FALSE), FALSE), fixed_free_y = ifelse(free_y, "free_y", "fixed"), incl_cens = incl_cens, thresh_list = thresh_list, rotate_x = TRUE, gage_dat = gageDat, precip_dat = precipDat, sel_add_gage_precip = sel_add_gage_precip, trans_log_y = trans_log_y)}
  
  return(ts_plot)
}

FuncPlotPage <- function(plot_list, time_unit) {
  
  sel_plot_ht = switch(is.null(input$sel_PlotHt)+1, 280+20*input$sel_PlotHt, 280)
  sel_combine_sites = switch(is.null(input$sel_CombineSites)+1, input$sel_CombineSites, FALSE)
  sel_add_gage_precip = switch(is.null(rv_param_temp$sel_add_gage_precip)+1, rv_param_temp$sel_add_gage_precip, "none")
  
  plot_dat <- isolate(rv_param_temp$plotDat)
  
  # PUT THE PLOTS TOGETHER
  
  shiny::req(!is.null(plot_list[[1]])) # this is the list of plots
  
  # Get the shared legend if it exists - getting shared legends to format properly with plotly is a PITB. Tried following many stackexchange suggestions, with no success.
  slegend <- cowplot::get_plot_component(plot_list[[1]][[1]], 'guide-box-top', return_all = TRUE)
  if(!is.null(slegend)) {
    shared_legend <- slegend
  #   # shared_legend <- ggpubr::as_ggplot(ggpubr::get_legend(plot_list[[1]][[1]])) # if a legend exists, extract it
  } else {
    shared_legend <- NULL
  }
  
  total_plot_height <- 64 + sel_plot_ht * (length(plot_list[[1]]) + as.integer(sel_add_gage_precip!="none")) # Final plot will take the layout of the first plot, so the first plot needs to have the height of final plot. Initially tried to account for x_axis height, but seems it was probably already adjusted for
  
  # First, the parameter plots
  param_plotly <- FuncPlotlyFormat(
    plotly_list = plot_list[[1]],
    # plotly_title = paste0(switch((length(unique(plot_dat$CharacteristicName)) > 1) + 1, unique(plot_dat$CharacteristicName), unique(plot_dat$MonitoringLocationIdentifier)), " (", min(plot_dat$Yr, na.rm = TRUE), " to ", max(plot_dat$Yr, na.rm = TRUE), ")"),
    xlab = switch(time_unit, ActivityStartDate = "Survey Date (time series)", DayOfYr = "Day", Wk = "Week", Mnth = "Month", Season = "Season"),
    ylab_vec = plot_list[[2]],
    total_height = total_plot_height,
    is_grouped_boxplots = (input$sel_PlotType == "box" & length(unique(plot_dat$CharacteristicName)) == 1 & length(unique(plot_dat$MonitoringLocationIdentifier)) > 1 & sel_combine_sites == TRUE) # boxplots for multiple stations, all combined in a single plot
  ) 
  
  # If there is a streamflow plot, add that in
  if(sel_add_gage_precip == "streamflow" & "ggplot" %in% class(plot_list[[3]])) {
    
    extra_plotly <- FuncPlotlyFormat(
      plotly_list = list(Streamflow = plot_list[[3]]),
      plotly_title = "Mean Daily Discharge",
      xlab = switch(time_unit, ActivityStartDate = "Survey Date (time series)", DayOfYr = "Day of Year", Wk = "Week of Year", Mnth = "Month of Year", Season = "Season of Year"),
      ylab_vec = c("Mean Daily Discharge (cfs)"),
      total_height = total_plot_height,
      is_grouped_boxplots = FALSE
    )
  }
  
  # If there is a precipitation plot, add that in
  if(sel_add_gage_precip == "precipitation" & "ggplot" %in% class(plot_list[[4]])) {
    
    extra_plotly <- FuncPlotlyFormat(
      plotly_list = list(Precipitation = plot_list[[4]]),
      plotly_title = "Precipitation",
      xlab = switch(time_unit, ActivityStartDate = "Survey Date (time series)", DayOfYr = "Day of Year", Wk = "Week of Year", Mnth = "Month of Year", Season = "Season of Year"),
      ylab_vec = c("Precip (cm)"),
      total_height = total_plot_height,
      is_grouped_boxplots = FALSE
    )
  }
  print("line1978")
  shiny::req(!is.null(param_plotly))
  
  if(exists("extra_plotly")) {
    subplot_list <- c(param_plotly, extra_plotly)
    n_plots <- length(plot_list[[1]])+1
  } else {
    subplot_list <- param_plotly
    n_plots <- length(plot_list[[1]])
  }
  print("line2121")
  shiny::req(!is.null(subplot_list))
  plotly_page <-
    subplot(subplot_list,
            nrows = n_plots, # add 1 for precip plot
            shareX = TRUE, # if set to FALSE, the X-axis labels will appear but will be cut off unless margin is increased. If margin is increased, plot sizes will be uneven
            shareY = FALSE,
            titleX = TRUE,
            titleY = TRUE,
            margin = c(0, 0.0, 0.02/length(subplot_list), 0.18/length(subplot_list)), # used to be 0.14/length(subplot_list)
            which_layout = 1)
  return_list <- list(plotly_page = plotly_page, shared_legend = shared_legend)
  return(return_list)
  }

FuncPieDat <- function(limit_type) {
  shiny::req(sum(!is.na(rv_param_temp$plotDat[limit_type])) > 0)
    
    # if(rv_param_temp$sel_summarize_by=="by_chartype") {
      temp_pie_dat <- rv_param_temp$plotDat %>%
        dplyr::filter(!is.na(get(limit_type))) %>%
        group_by(MonitoringLocationIdentifier, CharSampleType, Yr) %>%
        summarise(N = n()) %>%
        left_join(rv_param_temp$plotDat %>%
                    dplyr::rename("CategVar" = limit_type) %>%
                    group_by(MonitoringLocationIdentifier, CharSampleType, Yr) %>%
                    dplyr::count(CategVar), by = c("MonitoringLocationIdentifier", "CharSampleType", "Yr")) 
      
      if(rv_param_temp$sel_summarize_by=="by_chartype") {
        temp_pie_dat %<>% dplyr::rename(RowLev = MonitoringLocationIdentifier)
      } else {
        temp_pie_dat %<>% dplyr::rename(RowLev = CharSampleType)
      }
      
    temp_pie_dat %<>%
      dplyr::mutate(HoverLabel = paste0(RowLev, "<br>", rv_param_temp$seasonType, ": ", Yr, "<br>LEVEL: ", CategVar, "<br>COUNT: ", n, " out of N = ", N))
    return(temp_pie_dat)
}

FuncPieMap <- function(pie_map, map_by_yr = input$sel_MapByYr, limit_type, limit_name, pie_size) {
        pie_matrix <- rv_param_temp$plotDat %>%
          dplyr::filter(!is.na(get(limit_type)))
        
         if(map_by_yr == TRUE) {
           pie_matrix %<>% 
             dplyr::filter(Yr == as.numeric(input$sel_SurvYr)) %>%
             dplyr::group_by(MonitoringLocationIdentifier, Yr)
           } else {
             pie_matrix %<>%
               dplyr::group_by(MonitoringLocationIdentifier)
             }
        
        if(limit_type == "ThreshCateg") {
          pie_matrix$ThreshCateg <- factor(pie_matrix$ThreshCateg, levels = c("good", "caution", "poor")) # ensures that a column is created even if a factor level is not in the data
        }
        
  #                                      cat("WRITING PIE TEMP DAT") # <<<<<<<<<<<<<<<<<<<<<<<<
  # saveRDS(pie_matrix, "TEMP_pie_dat.RDS")
  
        pie_matrix %<>%
          dplyr::count(.[[limit_type]]) %>%
          tidyr::spread(key = `.[[limit_type]]` , value = n, drop = FALSE, fill = 0) %>%
          dplyr::left_join(
            cbind(rv$sitesPointsSub, sf::st_coordinates(rv$sitesPointsSub)) %>%
              dplyr::select(MonitoringLocationIdentifier, SITELAB, X, Y), by = "MonitoringLocationIdentifier") %>%
          ungroup()

        
        if(map_by_yr == TRUE) {
          map_caption <- paste(input$sel_ShowCharType, limit_name, "in Year", input$sel_SurvYr)
          } else {
            map_caption <- paste(input$sel_ShowCharType, limit_name, "summed across surveys")
          }
        
        if(limit_type == "PercCateg") {
          chart_matrix <- as.matrix(pie_matrix[, c("below", "between", "above")]) 
          chart_palette <- c("lightgray", "#56B4E9", "orange")
        }
        
        if(limit_type == "ThreshCateg") {
          chart_matrix = as.matrix(pie_matrix[, c("good", "caution", "poor")])
          chart_palette = rv_param_temp$threshColors
        }
        
        pie_map %<>% 
          addControl(tags$div(tag.map.title, HTML(map_caption)), position = "topleft", className="map-title") %>%
          addMinicharts(
            lng = pie_matrix$X,
            lat = pie_matrix$Y,
            time = switch((map_by_yr == TRUE)+1, NULL, pie_matrix$Yr),
            type = "pie",
            transitionTime = 0,
            height = pie_size,
            width = pie_size,
            showLabels = TRUE,
            legend = TRUE,
            layerId = pie_matrix$SITELAB,
            chartdata = chart_matrix,
            colorPalette = chart_palette,
            opacity = 1) %>%
          hideGroup("Imported monitoring sites") %>%
          hideGroup("Selected monitoring sites") %>%
          hideGroup("Selected gage stations") %>%
          hideGroup("Selected weather stations")
        
        return(pie_map)
      }

# Function to generate table with horizontal bar (pop-up map)
FuncParamTable <- function(df, threshold_df, MonitoringLocationIdentifier) {
  
  # CSS donut
  build_css_donut <- function(parts, colors, categories) {
    total <- sum(parts, na.rm = TRUE)
    if (total == 0) return('<div style="width: 80px; height: 80px; border-radius: 50%; background: #cccccc; display: flex; align-items: center; justify-content: center;"><span style="font-size: 12px;">0</span></div>')
    
    if (length(parts) <= 3) {
      percentages <- cumsum(parts) / total * 100
      stops <- paste0(colors, " ", c(0, head(percentages, -1)), "% ", percentages, "%")
      
      return(sprintf(
        '<div style="width: 80px; height: 80px; border-radius: 50%%; background: conic-gradient(%s); position: relative; display: flex; align-items: center; justify-content: center;"><div style="width: 35px; height: 35px; background: white; border-radius: 50%%; display: flex; align-items: center; justify-content: center;"><span style="font-size: 12px; font-weight: 600;">%d</span></div></div>',
        paste(stops, collapse = ", "), total
      ))
    }
    
    # SVG fallback if there are more than 3 categories in the future....
    circumference <- 157.08
    percentages <- parts / total * 100
    paths <- sprintf('<circle cx="40" cy="40" r="25" fill="none" stroke="%s" stroke-width="15" stroke-dasharray="%f %f" stroke-dashoffset="-%f" transform="rotate(-90 40 40)"/>', colors, (percentages / 100) * circumference, circumference, c(0, cumsum(head((percentages / 100) * circumference, -1))))

    paste0('<svg width="80" height="80" viewBox="0 0 80 80">', paste(paths, collapse=""), sprintf('<text x="40" y="45" text-anchor="middle" font-size="12" font-weight="600">%d</text>', total), '</svg>')
  }

  # Bar chart builder
  build_css_bar <- function(low, high, recent_values_str, recent_dates_str, n) {
    # Generate sample for percentiles
    sample_size <- min(n, 200)
    all_values <- runif(sample_size, low, high)
    q15 <- quantile(all_values, 0.05, na.rm = TRUE)
    q85 <- quantile(all_values, 0.95, na.rm = TRUE)
    med <- median(all_values, na.rm = TRUE)
    
    # Parse recent data
    recent_values <- tryCatch({
      vals <- as.numeric(unlist(strsplit(as.character(recent_values_str), ",")))
      vals[!is.na(vals)]
    }, error = function(e) numeric(0))
    
    recent_dates <- tryCatch({
      dates <- unlist(strsplit(as.character(recent_dates_str), ","))
      dates[!is.na(dates) & dates != ""]
    }, error = function(e) character(0))
    
    # Ensure matching pairs and limit to 5
    min_length <- min(length(recent_values), length(recent_dates), 5)
    if (min_length > 0) {
      recent_values <- recent_values[1:min_length]
      recent_dates <- recent_dates[1:min_length]
    } else {
      recent_values <- med
      recent_dates <- "Recent"
    }
    
    # Build dots 
    dots_html <- ""
    for (i in seq_along(recent_values)) {
      val <- recent_values[i]
      date <- recent_dates[i]
      y_pos <- 8 + (i-1) * 14
      
      # Simple categorization and positioning
      if (val < q15) {
        x_pos <- 7.5
        color <- "#6c757d"
      } else if (val > q85) {
        x_pos <- 92.5
        color <- "#6c757d"
      } else {
        if (q85 > q15) {
          relative_pos <- (val - q15) / (q85 - q15)
          x_pos <- 15 + relative_pos * 70
        } else {
          x_pos <- 50
        }
        color <- "#007BFF"  # Solid blue, no gradient
      }
      
      # Simple hover format - value (date)
      dots_html <- paste0(dots_html, sprintf(
        '<div style="position: absolute; top: %dpx; left: %.1f%%; width: 12px; height: 12px; background: %s; border: 2px solid white; border-radius: 50%%; z-index: 10; box-shadow: 0 1px 3px rgba(0,0,0,0.3);" title="%.1f (%s)"></div>',
        y_pos, x_pos, color, val, date
      ))
    }
    
    # Calculate median position
    median_pos <- if (q85 > q15) 15 + ((med - q15) / (q85 - q15)) * 70 else 50
    
    # Count summary
    num_low <- sum(recent_values < q15)
    num_high <- sum(recent_values > q85)
    num_normal <- length(recent_values) - num_low - num_high
    
    # Generate summary text
    summary_parts <- c()
    if (num_low > 0) summary_parts <- c(summary_parts, sprintf("%d in lower 15%%", num_low))
    if (num_normal > 0) summary_parts <- c(summary_parts, sprintf("%d in middle 70%%", num_normal))
    if (num_high > 0) summary_parts <- c(summary_parts, sprintf("%d in upper 15%%", num_high))
    
    summary_text <- if (length(summary_parts) > 0) {
      paste(summary_parts, collapse = ", ")
    } else {
      "All values in middle 70% of historical data"
    }
    
    sprintf(
      '<div style="position: relative; height: 80px; background: linear-gradient(to right, #f0f4f8 0%%, #f0f4f8 15%%, #ffffff 15%%, #ffffff 85%%, #f0f4f8 85%%, #f0f4f8 100%%); border-radius: 8px; border: 1px solid #dee2e6; overflow: visible; margin-top: 12px;">
         <div style="position: absolute; top: -18px; left: -20px; font-size: 10px; color: #6c757d; font-weight: 600; text-align: left; white-space: nowrap;">LOWER 15%% (< %.1f)</div>
         <div style="position: absolute; top: -18px; left: 15%%; font-size: 10px; color: #495057; font-weight: 600; text-align: center; width: 70%%; white-space: nowrap;">MIDDLE 70%% OF DATA (%.1f - %.1f)</div>
         <div style="position: absolute; top: -18px; right: -20px; font-size: 10px; color: #6c757d; font-weight: 600; text-align: right; white-space: nowrap;">UPPER 15%% (> %.1f)</div>
         <div style="position: absolute; top: 0; bottom: 0; left: 15%%; width: 2px; background: #6c757d; opacity: 0.3; border-radius: 1px;"></div>
         <div style="position: absolute; top: 0; bottom: 0; left: 85%%; width: 2px; background: #6c757d; opacity: 0.3; border-radius: 1px;"></div>
         <div style="position: absolute; top: 0; bottom: 0; left: 15%%; width: 70%%; background: rgba(0, 123, 255, 0.08); z-index: 1;" title="15th to 85th percentile range: %.1f - %.1f"></div>
         <div style="position: absolute; top: 0; bottom: 0; left: %.1f%%; width: 3px; background: #333; z-index: 2; border-radius: 2px;" title="Median (50th percentile): %.1f"></div>
         %s
       </div>',
      q15, q15, q85, q85, q15, q85, median_pos, med, dots_html
    )
  }

  css <- "
    .compact-table { border-collapse: separate; border-spacing: 0 8px; table-layout: fixed;}
    .compact-table td { padding: 14px; vertical-align: top; border-bottom: 1px solid #f0f0f0; }
    .compact-table thead th { background-color: #f8f9fa; font-weight: 600; padding: 12px; border-bottom: 2px solid #dee2e6; text-align: center; }
    .param-info { text-align: left; width: 220px; word-wrap: break-word; white-space: normal;}
    .param-name { font-weight: 600; font-size: 13px; color: #333; margin-bottom: 2px; word-wrap: break-word; line-height: 1.2; white-space: normal;}
    .param-details { font-size: 12px; color: #666; line-height: 1.4; white-space: normal;}
    .bar-column { width: 32opx; text-align: center; white-space: normal;}
    .threshold-column { width: 240px; text-align: center; white-space: normal;}
    .donut-container-large { display: flex; flex-direction: row; align-items: center; gap: 12px; justify-content: center; }
    .legend-compact { font-size: 11px; text-align: left; max-width: 140px; }
  "

  color_map <- c("good" = "#56B4E9", "caution" = "#F0E442", "poor" = "#E69F00", "unknown" = "#999999")

  # Process rows with minimal overhead
  rows <- lapply(1:nrow(df), function(i) {
    row <- df[i, ]
    
    # Extract values
    low <- as.numeric(row$Lowest_Value_Numeric)
    high <- as.numeric(row$Highest_Value_Numeric) 
    val <- as.numeric(row$Most_Recent_Value)
    n <- as.numeric(row$Sample_Size)
    param <- as.character(row$Characteristic)
    unit <- as.character(row$Unit)
    
    # Single sprintf for parameter info
    param_info <- sprintf('<div class="param-info"><div class="param-name">%s (%s)</div><div class="param-details"><div>N = %d samples</div><div>Years: %s</div><div>Range: %.1f - %.1f %s</div><div>Most recent: %.1f (%s)</div></div></div>', param, unit, n, row$Year_Range, low, high, unit, val, row$Most_Recent_Sample_Date)

    # Bar chart
    bar_html <- tryCatch(build_css_bar(low, high, as.character(row$Recent_Values), as.character(row$Recent_Dates), n), error = function(e) sprintf('<div style="padding: 20px; text-align: center; color: #666;">Error: %s</div>', e$message))

    cat("STARTING THRESHOLD LOOKUP")
    # Threshold lookup
    thresh_sub <- switch(any(is.null(threshold_df), nrow(threshold_df)==0)+1, threshold_df[tolower(threshold_df$Characteristic) == tolower(param), ], data.frame())

    if (nrow(thresh_sub) > 0) {
      donut_html <- build_css_donut(thresh_sub$n, color_map[thresh_sub$ThreshCateg], thresh_sub$ThreshCateg)
      legend_html <- paste(sprintf('<div style="color:%s; font-size: 11px;">%s: N=%d</div>', color_map[thresh_sub$ThreshCateg], thresh_sub$ThreshCateg_Label, thresh_sub$n), collapse = "")
    } else {
      donut_html <- sprintf('<div style="width: 80px; height: 80px; border-radius: 50%%; background: #cccccc; display: flex; align-items: center; justify-content: center;"><span style="font-size: 12px;">%d</span></div>', n)
      legend_html <- '<div style="color:#666666; font-size: 11px;">Undefined</div>'
    }

    shiny::tags$tr(
      shiny::tags$td(htmltools::HTML(param_info)),
      shiny::tags$td(htmltools::HTML(bar_html), class = "bar-column"),
      shiny::tags$td(htmltools::HTML(sprintf('<div class="donut-container-large">%s<div class="legend-compact">%s</div></div>', donut_html, legend_html)), class = "threshold-column")
    )
  })

  shiny::tagList(
    shiny::tags$style(htmltools::HTML(css)),
    shiny::tags$table(
      class = "compact-table",
      style = "width: 100%; font-size: 12px;",
      shiny::tags$thead(
        shiny::tags$tr(
          shiny::tags$th("Parameter Details", style = "text-align: left; width: 220px;"),
          shiny::tags$th("Recent Data Values (up to 5 shown)", style = "width: 320px;"),
          shiny::tags$th("Threshold Breakdown for ALL Data", style = "width: 240px;")
        )
      ),
      shiny::tags$tbody(rows)
    )
  )
}

FuncSummaryStats <- function(dat, plot_summarize_by) {
  
  if(plot_summarize_by == "by_station") {
    temp_dat <- dat %>%
      dplyr::rename("GroupingVar" = "CharacteristicName")
  } else {
    temp_dat <- dat %>%
      dplyr::rename("GroupingVar" = "MonitoringLocationIdentifier")
  }

  temp_plot_summary <- temp_dat %>% 
    dplyr::group_by(GroupingVar) %>% 
    dplyr::summarise(
      NumRecords = n(),
      NumSampleDays = length(unique(ActivityStartDate)),
      Mean = round(mean(ResultMeasureValue, na.rm = TRUE), 2),
      Median = round(median(ResultMeasureValue, na.rm = TRUE), 2),
      Min = round(min(ResultMeasureValue, na.rm = TRUE), 2),
      Max = round(max(ResultMeasureValue, na.rm = TRUE), 2)
      )
  param_tab_list <- list()

for (i in c("ResultDetectionConditionText", "ThreshCateg", "PercCateg")) {
  if(sum(!is.na(temp_dat[i])) > 0) {
    temp_add_cols <- temp_dat %>% 
      dplyr::rename("CategVar" = i) %>%
      dplyr::group_by(GroupingVar) %>%
          dplyr::count(CategVar) %>%
        dplyr::left_join(temp_plot_summary[, c("GroupingVar", "NumRecords")], by = "GroupingVar")

    temp_add_cols %<>%
      mutate(Perc = round((n/NumRecords)*100, 1)) %>%
      select(-n, -NumRecords) %>%
      spread(key = CategVar, value = Perc, sep = ": %", drop = FALSE, fill = 0)
    names(temp_add_cols) <- gsub("CategVar", i, names(temp_add_cols), fixed = TRUE)
    param_tab_list[[i]] <- temp_add_cols
  }
}
  
    final_plot_summary <- c(list(temp_plot_summary), param_tab_list) %>% purrr::reduce(left_join, by =  c("GroupingVar")) # left-join multiple tables
    names(final_plot_summary) <- gsub(pattern = "ResultDetectionConditionText: ", replacement = "", names(final_plot_summary))
    names(final_plot_summary) <- gsub(pattern = "ThreshCateg", replacement = "Thresholds", names(final_plot_summary))

    if(plot_summarize_by == "by_station") {
    final_plot_summary %<>%
      dplyr::rename("Characteristic"="GroupingVar")
  } else {
    final_plot_summary %<>%
      dplyr::rename("Site"="GroupingVar")
  }
    
    final_plot_summary
}


FuncClearAll <- function() {
  rv <- reactiveValues(wqp_url = NULL, parkName = NULL, parkID = NULL, unitPoly = NULL, HUC10 = NULL, HUC12 = NULL, sitesPointsSub = NULL, meteoStations = NULL, selectedMeteo = NULL, meteoDat = NULL, facilitiesPointsSub = NULL, selectedHucs = NULL, selectedStations = NULL, selectedOriginStation = NULL, selectedUpstreamStations = NULL, selectedDownstreamStations = NULL, selectedUpstreamLines = NULL, selectedDownstreamLines = NULL, selectedDataSummary = NULL, orgs = NULL, gageStations = NULL, selectedGages = NULL, gagesDat = NULL, dat = NULL, importSettings = list()) 
  
  rv_param_temp <- reactiveValues(defaultInputs = list(), currentInputs = list(), loadMap = FALSE, resetFilter = FALSE, newImport = NULL, palOrg = NULL, selectCharSampleType = NULL, N_plotly_page = NULL, subDat = NULL, subDatTypes = NULL, subDatYears = NULL, popupSiteSummary = NULL, filterNPlot = NULL, showStations = NULL, sel_summarize_by = NULL, sel_add_gage_precip = NULL, sel_gage_station = NULL, sel_gage_yscale = NULL, sel_precip_station = NULL, sel_precip_yscale = NULL, plotDat = NULL, quantDat = NULL, ggplot_ts_list = NULL, ggplot_season_list = NULL, finalPlot = list(plotly_page = NULL, shared_legend = NULL), seasonalPlot = list(plotly_page = NULL, shared_legend = NULL), plotSummary = NULL, precipDat = NULL, categLevels = NULL, categLevelsPlot = NULL, categLevelsImport = NULL, threshList = NULL, threshDF = NULL, threshCustom = NULL, threshColors = c("#56B4E9", "#F0E442", "#E69F00"), sel_show_thresholds = NULL, percCateg= NULL, showDM = FALSE, seasonType = NULL, param_map_highlight = NULL, update_from_sidebar = NULL)
  
  # Hide filter wellPanels
  restart_panels_filter <- c("new_data_P1", "new_data_P2", "new_data_P3", "new_data_P4", "create_categfile_P1", "create_categfile_P2", "create_categfile_P3", "create_categfile_P4") 
  lapply(restart_panels_filter, FUN = function(x) shinyjs::hideElement(x))
  
  # Update inputs
  FuncUpdateHome()
  FuncUpdateInputsOther()
  
  input <- list()
  
}

  # FuncSelHUC <- function(huc, huc_sf, park_code, overlaps_list) {
  #   # Function to generate HUC sf with only the HUCs that overlap the selected park unit.
  #   huc_on_park <- overlaps_list[[huc]] %>%
  #   dplyr::filter(unit_code == park_code) %>%
  #   dplyr::pull(tolower(huc))
  #   
  #   huc_sf_subset <- huc_sf %>% 
  #     dplyr::rename(HUC = tolower(huc)) %>%
  #     dplyr::filter(HUC %in% huc_on_park)
  #   
  #   return(huc_sf_subset)
  # }
  
# These are reactable functions
bar_chart <- function(label, width = "100%", height = "14px", fill = "#00bfc4", background = NULL) {
  bar <- div(style = list(background = fill, width = width, height = height))
  chart <- div(style = list(flexGrow = 1, marginLeft = "6px", background = background), bar)
  div(style = list(display = "flex", alignItems = "center"), label, chart)
  }

with_tooltip <- function(value, tooltip) {
  tags$abbr(style = "text-decoration: underline; text-decoration-style: dotted; cursor: help", title = tooltip, value)
}

download_button <- function(outputId, label = "Download", class = NULL, ...)  {
     tags$a(id = outputId, class = paste("btn btn-default shiny-download-link", 
        class), href = "", target = "_blank", download = NA, 
        icon("download"), label, ...)
}

grabit <- function(url) {
  tmpfile <- "tempdownload.geojson"
  req <- download.file(url, tmpfile, mode = "w")
  temp <- sf::st_read(dsn = tmpfile) 
  file.remove(tmpfile)
 return(temp)
}

```

```{r startup}
rv <- reactiveValues(wqp_url = NULL, parkName = NULL, parkID = NULL, unitPoly = NULL, HUC10 = NULL, HUC12 = NULL, sitesPointsSub = NULL, meteoStations = NULL, selectedMeteo = NULL, meteoDat = NULL, facilitiesPointsSub = NULL, selectedHucs = NULL, selectedStations = NULL, selectedOriginStation = NULL, selectedUpstreamStations = NULL, selectedDownstreamStations = NULL, selectedUpstreamLines = NULL, selectedDownstreamLines = NULL, selectedDataSummary = NULL, orgs = NULL, gageStations = NULL, selectedGages = NULL, gagesDat = NULL, dat = NULL, importSettings = list()) 
   
rv_param_temp <- reactiveValues(defaultInputs = list(), currentInputs = list(), loadMap = FALSE, resetFilter = FALSE, newImport = NULL, palOrg = NULL, selectCharSampleType = NULL, N_plotly_page = NULL, subDat = NULL, subDatTypes = NULL, subDatYears = NULL, popupSiteSummary = NULL, filterNPlot = NULL, showStations = NULL, sel_summarize_by = NULL, sel_add_gage_precip = NULL, sel_gage_station = NULL, sel_gage_yscale = NULL, sel_precip_station = NULL, sel_precip_yscale = NULL, plotDat = NULL, quantDat = NULL, ggplot_ts_list = NULL, ggplot_season_list = NULL, finalPlot = list(plotly_page = NULL, shared_legend = NULL), seasonalPlot = list(plotly_page = NULL, shared_legend = NULL), plotSummary = NULL, precipDat = NULL, categLevels = NULL, categLevelsPlot = NULL, categLevelsImport = NULL, threshList = NULL, threshDF = NULL, threshCustom = NULL, threshColors = c("#56B4E9", "#F0E442", "#E69F00"), sel_show_thresholds = NULL, percCateg= NULL, showDM = FALSE, seasonType = NULL, param_map_highlight = NULL, update_from_sidebar = NULL)
```

```{r observe_inputs}
observeEvent(input$sel_SummaryParam, {
    rv_param_temp$currentInputs$sel_SummaryParam <- input$sel_SummaryParam
  })

observeEvent(input$sel_ShowCharType, { # when a different parameter is selected, custom threshold limits are reset to NA
  print("PARAM CHANGED, SO RESETTING THRESHOLDS")
    rv_param_temp$currentInputs$sel_ThreshLower <- NA
    rv_param_temp$currentInputs$sel_ThreshUpper <- NA
    rv_param_temp$currentInputs$sel_ThreshCateg1 <- rv_param_temp$currentInputs$sel_ThreshCateg2 <- rv_param_temp$currentInputs$sel_ThreshCateg3 <- "good"
  })

observeEvent(input$sel_ThreshLower, { 
    rv_param_temp$currentInputs$sel_ThreshLower <- input$sel_ThreshLower
    print("ASSIGNED LOWER THRESH TO RV_PARAM_TEMP")
    })

observeEvent(input$sel_ThreshUpper, { 
    rv_param_temp$currentInputs$sel_ThreshUpper <- input$sel_ThreshUpper
    print("ASSIGNED UPPER THRESH TO RV_PARAM_TEMP")
    })

observeEvent(input$currentInputs$sel_ThreshCateg1, {
  rv_param_temp$currentInputs$sel_ThreshCateg1 <- input$sel_ThreshCateg1
  print("ASSIGNED THRESHCATEG1")
})

observeEvent(input$currentInputs$sel_ThreshCateg2, {
  rv_param_temp$currentInputs$sel_ThreshCateg2 <- input$sel_ThreshCateg2
  print("ASSIGNED THRESHCATEG2")
})

observeEvent(input$currentInputs$sel_ThreshCateg3, {
  rv_param_temp$currentInputs$sel_ThreshCateg3 <- input$sel_ThreshCateg3
  print("ASSIGNED THRESHCATEG3")
})

```

```{r action_button_beginSearch}
# Action to begin data search from Main Page----
observeEvent(eventExpr = input$button_beginSearch, {
  
  FuncClearAll()
  
# If user chooses to import new data from WQP...

if(input$sel_GetData == "new_data") { 
  shinyjs::showElement("new_data_P1")
  } else { # if user chooses to load existing data...
    showModal(modalDialog(
    fileInput("saved_data_file", label = "Import a saved dashboard data file ('RDS' extension)", placeholder = "Click 'Browse...' button then navigate to file", accept = c('.rds'), width = "100%"),
    footer = tagList(
      modalButton("Cancel")
    )
  ))
  }
})
```

```{r action_saved_data_file}
# Action to load saved .RDS file from Main Page ----
observeEvent(eventExpr = input$saved_data_file, {
  shiny::req(!is.null(input$saved_data_file$datapath))

  if(!toupper(tools::file_ext(input$saved_data_file$datapath)) %in% c("RDS")) {
    showModal(modalDialog(
    title = "Error",
    "File must have .RDS extension. Please select a different file."
    ))
  } else {

    tryCatch(out_file <- readRDS(input$saved_data_file$datapath),
             error = function(e) {out_file <- NULL; print("Cannot import the selected file")})
    
  shiny::req(!is.null(out_file))
  if(class(out_file)!="list") {
    showModal(modalDialog(
    title = "Error",
    "Cannot import the selected file. Please try a different .RDS file."
    ))
    }
  
  shiny::req(!is.null(out_file))
  for(i in names(out_file)) {
      rv[[i]] <- out_file[[i]] # load the data in the dashboard
    }
  cat("line2723")
  rv_param_temp$loadMap <- TRUE

  FuncInitFilter()
  FuncUpdateFilterInputs() 
  FuncRefreshFilter(sel_MinYrs = rv_param_temp$defaultInputs$sel_MinYrs, sel_SummaryParam = rv_param_temp$currentInputs$sel_SummaryParam, sel_SummaryOrg = rv_param_temp$defaultInputs$sel_SummaryOrg, sel_YrRange = rv_param_temp$defaultInputs$sel_YrRange, sel_ActivityType = rv_param_temp$defaultInputs$sel_ActivityType, sel_ResultStatus = rv_param_temp$defaultInputs$sel_ResultStatus, sel_DefineSeasons = rv_param_temp$defaultInputs$sel_DefineSeasons) # generate the initial filtered data based on default filters. Also call this filter when action button clicked for refreshing filter
  # rv_param_temp$resetFilter <- TRUE
  rm(out_file)
  cat("line2731")
  rv_param_temp$plotDat <- NULL # Just to make doubly sure everything is cleared out
  rv_param_temp$threshList <- NULL
  rv_param_temp$threshDF <- NULL
  rv_param_temp$categLevelsPlot <- NULL
  
  showModal(modalDialog(
  title = "Done",
  "You may now navigate to the other dashboard pages"
  ))
  }
})
```

```{r action_button_showStations}
# Action to show WQP stations from Main Page ----
observeEvent(eventExpr = input$button_showStations, {
  if(input$sel_UnitCode=="") { # can't print validation message within observeEvent, so use modalDialogs
    showModal(modalDialog(
      title = "No Data",
      "Please choose a Park unit"
    ))
    }
 
  shiny::req(input$sel_UnitCode!="") # make sure user has entered Park unit code

  FuncClearAll()
  
  rv$parkName <- input$sel_UnitCode
  rv$parkID <- unique_parks_df$unit_code[unique_parks_df$unit_name_combined == rv$parkName]
  
  print("line2417")
  withProgress(message = "Getting data", detail = "...Park unit and intersecting watershed boundaries", value = 0, {

  showModal(tags$div(id = "gif_modal", modalDialog(
      HTML('<img src="https://media.giphy.com/media/BAKUHQxl7y7Zu/giphy.gif"><br><center>I am just your entertainment.<br><center>The progress bar is below.'), # custom loading gif--pdog blowing bubble gum
      easyClose = TRUE,
      footer = NULL
      )))
    
  shinyjs::hideElement("new_data_P2")
  shinyjs::hideElement("new_data_P3")
  shinyjs::hideElement("new_data_P4")
    
  # Get park unit boundary data from dashboard files ----
  # Check for problems with self-intersections, etc. These problems should be fixed in the updated version of LandscapeDynamics
  parks_sf <- readRDS(here::here("dashboard_files", "parks_sf.RDS"))
    rv$unitPoly <- parks_sf %>% dplyr::filter(UNIT_CODE == rv$parkID) %>% sf::st_make_valid(.)
  print("line2432")
   # Get HUC10 & HUC12 boundary data from web services ----
    # Files are too large to save with dashboard for quick pull

    for(hucLevel in 6:5) {
      hucName <- switch((hucLevel==6)+1, "HUC10", "HUC12")
     
      incProgress(1/7, detail = paste0("...", hucName, " boundaries from National Watershed Boundary Dataset"))

      hucURL <- paste0("https://hydro.nationalmap.gov/arcgis/rest/services/wbd/MapServer/", hucLevel, "/query?where=&text=&objectIds=&time=&geometry=", paste(as.character(sf::st_bbox(rv$unitPoly)), collapse ="%2C"), "&geometryType=esriGeometryEnvelope&inSR=4326&outSR=4326&spatialRel=esriSpatialRelIntersects&relationParam=&outFields=*&returnGeometry=true&returnTrueCurves=false&maxAllowableOffset=&geometryPrecision=&having=&returnIdsOnly=false&returnCountOnly=false&orderByFields=&groupByFieldsForStatistics=&outStatistics=&returnZ=false&returnM=false&gdbVersion=&historicMoment=&returnDistinctValues=false&resultOffset=&resultRecordCount=&queryByDistance=&returnExtentOnly=false&datumTransformation=&parameterValues=&rangeValues=&quantizationParameters=&featureEncoding=esriDefault&f=geojson")

    if(httr::http_status(httr::GET(hucURL))$category!="Success") { # make sure the service call is valid
      shiny::showModal(
         urlModal(hucURL, title = "Data Retrieval Error", subtitle = htmltools::HTML(paste0("Error retrieving ", hucName, " boundary data from the National Watershed Boundary Dataset. The message from the web service is: `", httr::http_status(GET(hucURL))$message, "`.<br><br><strong>To confirm this is a problem with the web service (and not the dashboard), enter the above URL in a browser and see if data successfully downloads.</strong> If this is an issue with the dashboard, help us improve this dashboard by reporting the problem via the project GitHub page: https://github.com/nationalparkservice/WQdash_public<br><br>")))
       )
      }
   
    shiny::req(httr::http_status(GET(hucURL))$category=="Success") # if not a valid service call, abort
    
    # hucPoly <- tryCatch(sf::st_read(hucURL), error=function(e) print("Error retrieving ", hucName, " data")
    # NOTE: st_read() on a data service (WCS, maybe arcgis/rest too) uses GDAL to let it become a virtual feature, not (yet) downloading the entire data.  That includes extra authentication, which often gets broken by any ssl change on our systems
    hucPoly <- tryCatch(grabit(hucURL), error=function(e) print("Error retrieving ", hucName, " data"))

    if(!"sf" %in% class(hucPoly)) {
      showModal(
         urlModal(hucURL, title = "Data Retrieval Error", subtitle = paste0("Could not successfully retrieve HUC boundary data from the National Watershed Boundary Dataset. To see if this is a problem with the web service (and not the dashboard), enter the above URL in a browser and see if data successfully downloads with boundary information in geojson format."))
       )
      }
    shiny::req("sf" %in% class(hucPoly))
    hucPoly <- sf::st_transform(hucPoly, crs = st_crs(rv$unitPoly))
    
    if(exists("hucPolySub")) {rm(hucPolySub)}
    
    # tryCatch(hucPolySub <- sf::st_intersection(rv$unitPoly, hucPoly), error = function(e) NULL)
    
    # rv$unitPoly <- st_make_valid(rv$unitPoly)
    tryCatch(hucPolySub <- hucPoly[unlist(sf::st_intersects(rv$unitPoly, hucPoly)),], error = function(e) NULL) # can't use intersection here b/c it clips
    
    if(exists("hucPolySub")) {
      hucPolySub %<>%
      dplyr::rename(HUC = tolower(hucName))
      
      rv[[hucName]] <- hucPolySub
      rm(hucPolySub)
      }
      
    rm(hucURL,hucPoly)
    }
    

    # Get Monitoring station sites for overlapping HUC10 bbox, from web services ----
    # Real-time pull so user can set filters

    incProgress(1/7, detail = "...Monitoring sites from Water Quality Portal")
    print("line2481")
    shiny::req(!is.null(rv[["HUC10"]]), !is.null(input$sel_ActiveWithinYrs))
    print("line2483")
    huc10_bbox <- sf::st_bbox(rv[["HUC10"]]) # HUC10 bbox
    
  # Recently active WQP stations that fall within the HUC10 bbox (sampled within past [user-specified number of] years) 
  sitesURL <- paste0("https://www.waterqualitydata.us/data/Station/search?siteType=Aggregate%20surface-water-use&siteType=Estuary&siteType=Lake%2C%20Reservoir%2C%20Impoundment&siteType=Spring&siteType=Stream&siteType=Well&siteType=Wetland&siteType=Aggregate%20groundwater%20use&siteType=Aggregate%20groundwater%20use%20&siteType=Aggregate%20water-use%20establishment&siteType=Subsurface&bBox=", paste(huc10_bbox, collapse ="%2C"), "&characteristicType=Toxicity&characteristicType=Physical&characteristicType=Organics%2C%20PFAS&characteristicType=Organics%2C%20Pesticide&characteristicType=Organics%2C%20PCBs&characteristicType=Nutrient&characteristicType=Microbiological&characteristicType=Cyanotoxins%2C%20Phytotoxins&characteristicType=Inorganics%2C%20Major%2C%20Metals&characteristicType=Inorganics%2C%20Major%2C%20Non-metals&minactivities=1&startDateLo=01-01-", lubridate::year(Sys.Date())-as.integer(input$sel_ActiveWithinYrs), "&sampleMedia=Water&sampleMedia=water&mimeType=csv&zip=no&providers=NWIS&providers=STEWARDS&providers=STORET")
   
    if(httr::http_status(httr::GET(sitesURL))$category!="Success") { # make sure the service call is valid
      shiny::showModal(
        urlModal(sitesURL, title = "Data Retrieval Error", subtitle = htmltools::HTML(paste0("Error retrieving monitoring sites information from the Water Quality Portal. The message from the web service is: `", httr::http_status(GET(sitesURL))$message, "`.<br><br><strong>To confirm this is a problem with the web service (and not the dashboard), enter the above URL in a browser and see if data successfully downloads.</strong> If this is an issue with the dashboard, help us improve this dashboard by reporting the problem via the project GitHub page: https://github.com/nationalparkservice/WQdash_public<br><br>")))
      )
    }
    
    shiny::req(httr::http_status(GET(sitesURL))$category=="Success") # if not a valid service call, abort
    # polite::bow(sitesURL) %>% rip(destfile = "tempSites.csv", mode = "w")

    download.file(sitesURL, "tempSites.csv", mode = "w")
    sites <- read_csv("tempSites.csv", trim_ws = TRUE)
    sites$HUCEightDigitCode <- gsub(pattern="-", replacement = "", x= as.character(sites$HUCEightDigitCode)) # Weird issue with BLRI
    
    if(is.null(sites)|nrow(sites)==0) { # if no monitoring stations, abort
      showModal(modalDialog(
        title = "No Monitoring Sites",
        "No monitoring sites found in Water Quality Portal for specified query. Please try again."
      ))
      }
    shiny::req(!is.null(sites) & nrow(sites)>0)
    
  # Create sf of WQP stations point location
  temp_points <- sf::st_as_sf(x = sites, 
                        coords = c("LongitudeMeasure", "LatitudeMeasure"),
                        crs = 4269)# NAD83. Difference between NAD83 and WGS84 is only ~1m, so just use NAD83 b/c it's the most common.
    
    temp_points <- sf::st_transform(temp_points, crs = st_crs(rv$unitPoly)) # convert to WGS84
    # subset to the HUC10 boundaries. Did not import using the HUC10's b/c that approaches seems to miss some sites that don't have associated HUC10 information (?)
    
    sitesPoints <- st_filter(temp_points, rv[["HUC10"]]) # These are the ones that fall within HUC10's, so keep them
    
    sitesPoints %<>%
      dplyr::mutate(
        SITELAB = paste0("Monitoring Site: ", MonitoringLocationName, " [", MonitoringLocationIdentifier, "]"),

        SITEPOP = paste0("Org: ", OrganizationFormalName, '<br>Site ID: <a href="https://www.waterqualitydata.us/provider/', ProviderName, '/', OrganizationIdentifier, '/', MonitoringLocationIdentifier, '/" target="_blank">', MonitoringLocationIdentifier, '</a>', "<br>Water Monitoring Station: ", MonitoringLocationName, "<br>Type: ", MonitoringLocationTypeName))
    
    rv$sitesPointsSub <- sitesPoints
    rm(sites, temp_points, sitesPoints)
    unlink("tempSites.csv")
  
  # Get recently active USGS stream gauging station information, within HUC10's, from dashboard files ----
  incProgress(1/7, detail = "...USGS stream gages station information from NWIS")
  print("Getting gages")
  
  park_gage_overlaps_list <- readRDS(here::here("dashboard_files", "park_gage_overlaps_list.RDS"))                                             
  gages <- park_gage_overlaps_list[[rv$parkID]] # Get stream gage stations for that park unit
  rm(park_gage_overlaps_list)
  if(all(!is.null(nrow(gages)), nrow(gages) >0)) {
    
    # Create sf of gage stations point location
  temp_gagepoints <- sf::st_as_sf(x = gages, 
                        coords = c("Longitude", "Latitude"),
                        crs = 4269)# NAD83.
  
  temp_gagepoints <- sf::st_transform(temp_gagepoints, crs = st_crs(rv$unitPoly)) # convert to WGS84
    # subset to the HUC10 boundaries. 
  
  gagePoints <- st_filter(temp_gagepoints, rv[["HUC10"]]) # These are the ones that fall within HUC10's, so keep them
  
  if(nrow(gagePoints) > 0) {
    rv$gageStations <- gagePoints
  } else {
    rv$gageStations <- NULL # None actually fall within HUC10's
  }
  
  } else {
    rv$gageStations <- NULL
  }
  
  if(is.null(rv$gageStations)) {
    showModal(modalDialog(
      title = "No Stream Gage Stations Meet Download Criteria",
      "Could not find active USGS stream gage stations with at least 10 years of data, located within the park's HUC10 watershed boundaries (active = most recent data are less than one year old). These data are not necessary for visualizing water quality data on the dashboard.",
      easyClose = FALSE,
      footer = tagList(
        div(style="display:inline-block; width:100px;", actionButton("dismiss_gages_modal", "Got it!"))
        )
      )
      )
  } # Require user to click 'Got it!' button for the modal to close
  
  rm(gages, temp_gagepoints, gagePoints)

  # Get locations of recently active weather stations, for the bounding box, from dashboard files ----
  # This requires a token, so don't want to embed in dashboard
  incProgress(1/7, detail = "...Weather station locations from NOAA")

    park_noaa_overlaps_list <- readRDS(here::here("dashboard_files", "park_noaa_overlaps_list.RDS"))
    noaa <- park_noaa_overlaps_list[[rv$parkID]] # Get stream gage stations for that park unit
    
    if(all(!is.null(nrow(noaa)), nrow(noaa) >0)) {

  # Create sf of gage stations point location
  temp_noaapoints <- sf::st_as_sf(x = noaa, 
                        coords = c("longitude", "latitude"),
                        crs = 4269)# NAD83.
  
  temp_noaapoints <- sf::st_transform(temp_noaapoints, crs = st_crs(rv$unitPoly)) # convert to WGS84
    # subset to the HUC10 boundaries. 

  rv$meteoStations <- temp_noaapoints
    } else {
    rv$meteoStations <- NULL
    
    showModal(modalDialog(
      title = "No Weather Stations Meet Download Criteria",
      "Could not find active weather stations with at least 10 years of data, located within the park's HUC10 watershed boundaries box (active = most recent data are less than one year old). These data are not necessary for visualizing water quality data on the dashboard.",
      easyClose = FALSE,
      footer = tagList(
        div(style="display:inline-block; width:100px;", actionButton("dismiss_weather_modal", "Got it!"))
        )
      )
      ) # Require user to click 'Got it!' button for the modal to close
  }
print("line2336")

  # Get Discharge facilities locations from ECHO, for the bounding box - restrict to "major" facilities ----
  incProgress(1/7, detail = "...Discharge facilities locations from EPA ECHO Map Services")
  print("Getting EPA")
  facilitiesPoints <- NULL # make sure previous search information erased
  
 facilitiesURL <- paste0("https://ofmpub.epa.gov/echo/cwa_rest_services.get_facility_info?output=GEOJSON&p_maj=Y&p_wbd=", paste(rv$HUC10$HUC, collapse = ",")) # major facilities only, falls within the HUC10 boundaries
print("line2614")
print(facilitiesURL)
  if(httr::http_status(GET(facilitiesURL))$category!="Success") { # make sure the service call is valid
    showModal(modalDialog(
      title = "No Discharge Facilities Data",
      "Error retrieving discharge facilities locations data from EPA ECHO. These data are not necessary for visualizing water quality data on the dashboard.",
      easyClose = FALSE,
      footer = tagList(
        div(style="display:inline-block; width:100px;", actionButton("dismiss_discharge_modal", "Got it!"))
        )
      )
      ) # Require user to click 'Got it!' button for the modal to close
    } else {
      if(length(str_detect(content(GET(facilitiesURL))$message, "invalid:")) > 0) { # if the http is valid, but some HUCs are not found, remove those HUCs from the search
        lostHUCS <- unlist(str_extract_all(content(GET(facilitiesURL))$message, "[[:digit:]]{10}")) # extract the HUC10's
        subsetHUC <- setdiff(rv$HUC10$HUC, lostHUCS) # remove those HUC's from the list, and try again
        facilitiesURL <- paste0("https://ofmpub.epa.gov/echo/cwa_rest_services.get_facility_info?output=GEOJSON&p_maj=Y&p_wbd=", paste(subsetHUC, collapse = ",")) # major facilities only, falls within the HUC10 boundaries
        print(facilitiesURL)
      }
      tempFacilitiesOutput <- "tempFacilities.geojson"
      print("line2360")
      download.file(facilitiesURL, tempFacilitiesOutput)
      facilitiesPoints <- tryCatch(readOGR(dsn = tempFacilitiesOutput, dropNULLGeometries = FALSE), error=function(e) print("Error retrieving discharge facilities information"))
print("line2635")
      if(class(facilitiesPoints)!="SpatialPointsDataFrame") {
        rv$facilitiesPointsSub <- NULL
        showModal(modalDialog(
          title = "No Discharge Facilities Data",
          "Error retrieving discharge facilities locations data from EPA ECHO. These data are not necessary for visualizing water quality data on the dashboard.",
          easyClose = FALSE,
          footer = tagList(
            actionButton("dismiss_discharge_modal", "Got it!")
            )
          )
      ) # Require user to click 'Got it!' button for the modal to close
        
        } else {
          facilitiesPoints %<>%
            dplyr::mutate(
              FACLAB = paste0("Discharge Facility: ", CWPName, " [", SourceID, "]"),
              FACPOP = paste0('Discharge Facility: <a href="https://echo.epa.gov/detailed-facility-report?fid=', SourceID, '" target="_blank">', CWPName, '</a>', "<br>Source ID: ", SourceID, "<br>Type: ", CWPFacilityTypeIndicator, "<br>County: ", CWPCounty, "<br>State: ", CWPState)) # CWPName
          rv$facilitiesPointsSub <- facilitiesPoints[rv$HUC10,]
          rm(facilitiesPoints)
        }
      rm(facilitiesURL, tempFacilitiesOutput)
      unlink("tempFacilities.geojson")
    }
    # If displaying shapes, points, etc., Leaflet will automatically project the WGS84 long-lat coordinates when displaying. Leaflet only supports TILES that have been published in EPSG 3857, so if using other tiles (e.g., NPS), need to change projections
  })
  
  shinyjs::showElement("new_data_P2")
    
  print("set loadMap to TRUE")
  rv_param_temp$loadMap <- TRUE
  print("reset Filter")
  # rv_param_temp$resetFilter <- FALSE # make sure these are still set to FALSE. User can't filter or plot data until they are downloaded/imported.


showModal(modalDialog(
  title = "Done",
  HTML("In the <strong>'2. Filter Sites to Download'</strong> panel, choose the monitoring sites you want to download data from. You can:<ul>
    <li>Download data for the entire park,</li>
    <li>Select specific watersheds, or</li>
    <li>Specify an origin station and distance upstream/downstream.</li>
  </ul>
  You can also apply additional filters using the other options in the panel. When you're ready, click <strong>'Summarize Selected Sites'</strong> to preview a summary of the data before downloading.")
))

}, ignoreInit = TRUE) # end of run search button
```

```{r action_button_highlightStations}
# Action to summarize selected stations ----
observeEvent(eventExpr = input$button_summarizeStations, {
  
  if(is.null(input$sel_Organization)) {
    showModal(modalDialog(
      title = "No organization selected",
      "Please select at least one organization to download WQ data from"))
    shiny::req(!is.null(input$sel_Organization))
    }
  
  if(is.null(input$sel_SiteType)) {
      showModal(modalDialog(
        title = "No site type selected",
        "Please select at least one site type to download WQ data for"))
      shiny::req(!is.null(input$sel_SiteType))
  }
  
  if(is.null(input$sel_CharType)) {
    showModal(modalDialog(
      title = "No characteristic group(s) selected",
      "Please select at least one characteristic group to download"))
    shiny::req(!is.null(input$sel_CharType))
  }
  
  rv$selectedDataSummary <- NULL
  
  # Select stations by Park
  if(input$sel_SelectMethod == "methodPark") {
    
    rv$selectedOriginStation <- rv$selectedUpstreamLines <- rv$selectedDownstreamLines <- rv$selectedUpstreamStations <- rv$selectedDownstreamStations <- NULL

    rv$selectedStations <- rv$sitesPointsSub[rv$unitPoly,] %>%
            dplyr::filter(OrganizationFormalName %in% input$sel_Organization & MonitoringLocationTypeName %in% input$sel_SiteType) %>% # limit to selected orgs and site types
      dplyr::select(MonitoringLocationIdentifier, OrganizationFormalName, MonitoringLocationTypeName) %>%
      dplyr::distinct() %>%
      dplyr::arrange(MonitoringLocationIdentifier) %>%
      as.data.frame(.)
    
    cat("Identified stations within park unit")

    shiny::req(length(rv$selectedStations$MonitoringLocationIdentifier) > 0)
    } # end of methodPark
  
  # Select stations by HUC
  if(input$sel_SelectMethod == "methodHuc") {
    
    if(is.null(rv$selectedHucs)) {
      showModal(modalDialog(
        title = "No HUCs selected",
        "Please click on the map to select HUC(s)."
      ))
      shiny::req(!is.null(rv$selectedHucs))
    }
    
    rv$selectedOriginStation <- rv$selectedUpstreamLines <- rv$selectedDownstreamLines <- rv$selectedUpstreamStations <- rv$selectedDownstreamStations <- NULL

    rv$selectedStations <- rv$sitesPointsSub[rv[[input$sel_HUClevel]][rv[[input$sel_HUClevel]]$HUC %in% rv$selectedHucs,],] %>%
            dplyr::filter(OrganizationFormalName %in% input$sel_Organization & MonitoringLocationTypeName %in% input$sel_SiteType) %>% # limit to selected orgs and site types
      dplyr::select(MonitoringLocationIdentifier, OrganizationFormalName, MonitoringLocationTypeName) %>%
      dplyr::distinct() %>%
      dplyr::arrange(MonitoringLocationIdentifier) %>%
      as.data.frame(.)
    
    shiny::req(length(rv$selectedStations$MonitoringLocationIdentifier) > 0)
    } # end of methodHuc
 
  # Select stations by distance from origin
  if(input$sel_SelectMethod == "methodDist") {
     
    if(is.null(input$sel_OriginStationID)) {
      showModal(modalDialog(
        title = "No origin monitoring site entered", 
        "To select monitoring sites based on distance from an origin, please enter an origin monitoring site"
      ))
      shiny::req(!is.null(input$sel_OriginStationID))
    }
    
    if(!input$sel_OriginStationID %in% unique(rv$sitesPointsSub$MonitoringLocationIdentifier[rv$sitesPointsSub$OrganizationFormalName %in% input$sel_Organization])) {
      showModal(modalDialog(
        title = "Cannot find the requested origin monitoring site",
        "The requested origin monitoring site is not available for the Park and organizations of interest."
      ))
      shiny::req(input$sel_OriginStationID %in% unique(rv$sitesPointsSub$MonitoringLocationIdentifier[rv$sitesPointsSub$OrganizationFormalName %in% input$sel_Organization]))
    }
 
  if(input$sel_DistKmUpstream == 0 & input$sel_DistKmDownstream == 0) {
        showModal(modalDialog(
          title = "No distance from origin monitoring site entered",
          "To select monitoring sites based on distance from an origin, please enter a distance (in km) upstream or downstream from the origin monitoring site."
        ))
        shiny::req(input$sel_DistKmUpstream > 0 | input$sel_DistKmDownstream > 0)
      }

    withProgress(message = "Downloading from Hydro Network-Linked Data Index...", value = 0, {
      
        showModal(tags$div(id = "gif_modal", modalDialog(
      HTML('<img src="https://media.giphy.com/media/l44QjgeQ5ium91n9K/source.gif"><br><center>I am just your entertainment.<br><center>The progress bar is below.'), # custom loading gif--raccoon thief
      easyClose = TRUE,
      footer = NULL
      )))
      
    nldiURLS <- list(
      selectedOriginStation = paste0("https://labs.waterdata.usgs.gov/api/nldi/linked-data/nwissite/", input$sel_OriginStationID),
      selectedUpstreamLines = ifelse(input$sel_DistKmUpstream > 0, paste0("https://labs.waterdata.usgs.gov/api/nldi/linked-data/nwissite/", input$sel_OriginStationID, "/navigation/", ifelse(input$sel_IncludeTribs, "UT", "UM"), "?distance=", input$sel_DistKmUpstream), NA),
      selectedDownstreamLines = ifelse(input$sel_DistKmDownstream > 0, paste0("https://labs.waterdata.usgs.gov/api/nldi/linked-data/nwissite/", input$sel_OriginStationID, "/navigation/", ifelse(input$sel_IncludeDiversions, "DD", "DM"), "?distance=", input$sel_DistKmDownstream), NA),
      selectedUpstreamStations = ifelse(input$sel_DistKmUpstream > 0, paste0("https://labs.waterdata.usgs.gov/api/nldi/linked-data/nwissite/", input$sel_OriginStationID, "/navigation/", ifelse(input$sel_IncludeTribs, "UT", "UM"), "/wqp?distance=", input$sel_DistKmUpstream), NA),
      selectedDownstreamStations = ifelse(input$sel_DistKmDownstream > 0, paste0("https://labs.waterdata.usgs.gov/api/nldi/linked-data/nwissite/", input$sel_OriginStationID, "/navigation/", ifelse(input$sel_IncludeDiversions, "DD", "DM"), "/wqp?distance=", input$sel_DistKmDownstream), NA))
    
    saveRDS(nldiURLS, "temp_nldi.RDS")
 
    for(n in names(nldiURLS)) {
   
      incProgress(1/7, detail = paste0("...", n))
      if(!is.na(nldiURLS[[n]])) { # if URL is specified
        tempURL <- nldiURLS[[n]]
      
        if(httr::http_status(GET(tempURL))$category!="Success") { # make sure the service call is valid
          showModal(
            urlModal(tempURL, title = "Data Retrieval Error", subtitle = htmltools::HTML(paste0("Error retrieving data from the Hydro Network-Linked Data Index for the `", n, "` query. The message from the web service is: `", httr::http_status(GET(tempURL))$message, "`.<br><br><strong>To confirm this is a problem with the web service (and not the dashboard), enter the above URL in a browser and see if data successfully downloads.</strong> If this is an issue with the dashboard, help us improve this dashboard by reporting the problem via the project GitHub page: https://github.com/nationalparkservice/WQdash_public<br><br>")))
            )
          }
   
        shiny::validate(need(httr::http_status(GET(tempURL))$category=="Success", message = FALSE)) # if not a valid service call, abort
        
        checkhydro <- tryCatch(rgdal::readOGR(dsn = tempURL[[1]], verbose = FALSE), error=function(e) NULL) # <<<<<<<<<<<<<<<<<<<<<<<<<<<<< PACKAGE DISCONTINUED?
    
        if(is.null(checkhydro)) {
        showModal(modalDialog(
          title = "No Data",
          "Error retrieving data from the Hydro Network-Linked Data Index",
          footer = modalButton("OK")
          ))
        } else {
          checkhydro <- spTransform(checkhydro, CRS("+proj=longlat +datum=WGS84")) # convert to WGS84
          rv[[n]] <- checkhydro 
        }
      
        # renderText(paste(n, "is of class", class(nldiData[n][[1]])[1], "and has", length(nldiData[n][[1]]), "features"))
      }
    }
    }) # end of with Progress
# 
      
    rv$selectedStations <- 
      rbind.fill(data.frame(rv$selectedOriginStation), if(!is.null(rv$selectedUpstreamStations)) data.frame(rv$selectedUpstreamStations), if(!is.null(rv$selectedDownstreamStations)) data.frame(rv$selectedDownstreamStations)) %>% # combine into one data frame
      dplyr::rename(MonitoringLocationIdentifier = identifier) %>%
      left_join(unique(data.frame(rv$sitesPointsSub[, c("MonitoringLocationIdentifier", "OrganizationFormalName", "MonitoringLocationTypeName")])), by = "MonitoringLocationIdentifier") %>%
      dplyr::filter(OrganizationFormalName %in% input$sel_Organization & MonitoringLocationTypeName %in% input$sel_SiteType) %>% # limit to selected orgs and site types
      dplyr::distinct() %>%
      dplyr::arrange(MonitoringLocationIdentifier) %>%
      as.data.frame(.)
    
    shiny::req(length(rv$selectedStations$MonitoringLocationIdentifier) > 0)
} # end of methodDist
  
  withProgress(message = "Summarizing selected data...", detail = "You're gonna love this!", value = 0, { 
  # Get statistics about the parameters and number of data records for the selected sites and characteristic types
  
  stationChoiceString <- paste0(unique(rv$selectedStations$MonitoringLocationIdentifier), collapse = "&siteid=")
  
  charTypeChoiceString <- paste(input$sel_CharType, collapse = "&characteristicType=", sep = ";") %>%
  gsub(",", "%2C", .) %>%
  gsub(" ", "%20", .)
  
  # searchURL <- paste0("search?siteid=", stationChoiceString, "&characteristicType=", charTypeChoiceString, "&sampleMedia=Water&mimeType=csv&zip=no") # REMOVED SITETYPE & MINACTIVITIES & START & END DATES AS AN OPTION AT THIS STAGE)
  
    summaryURL <- paste0("https://www.waterqualitydata.us/data/summary/monitoringLocation/search?siteid=", stationChoiceString, "&characteristicType=", charTypeChoiceString, "&sampleMedia=Water&mimeType=csv&zip=no&summaryYears=all&count=no&dataProfile=periodOfRecord")
    
        if(httr::http_status(GET(summaryURL))$category!="Success") { # make sure the service call is valid
      showModal(
        urlModal(summaryURL, title = "Data Retrieval Error", subtitle = htmltools::HTML(paste0("Error retrieving data selection information from the Water Quality Portal. The message from the web service is: `", httr::http_status(GET(summaryURL))$message, "`.<br><br><strong>To confirm this is a problem with the web service (and not the dashboard), enter the above URL in a browser and see if data successfully downloads.</strong> If this is an issue with the dashboard, help us improve this dashboard by reporting the problem via the project GitHub page: https://github.com/nationalparkservice/WQdash_public<br><br>")))
      )
    }
    
    shiny::req(httr::http_status(GET(summaryURL))$category=="Success") # if not a valid service call, abort

    download.file(summaryURL, "tempSummary.csv", mode = "w")
    rv$selectedDataSummary <- read_csv("tempSummary.csv", trim_ws = TRUE) %>%
      dplyr::select(-MonitoringLocationUrl, -CountyName, -StateName, -MonitoringLocationLatitude, -MonitoringLocationLongitude)
  
  # For downloading data, break up large data requests
  # subset_stations_list <- split(unique(rv$selectedStations$MonitoringLocationIdentifier), ceiling(seq_along(unique(rv$selectedStations$MonitoringLocationIdentifier))/3)) # import data for 10 stations (max) at a time
  
  # rv$wqp_url_list <- lapply(subset_stations_list, function(s) {
    # 
    # stationChoiceString_partial <- paste0(s, collapse = "&siteid=")
    # paste0("https://www.waterqualitydata.us/data/Result/search?siteid=", stationChoiceString_partial, "&characteristicType=", charTypeChoiceString, "&sampleMedia=Water&mimeType=csv&zip=no")
  # }) # this is a LIST of wqp download url's
  
  # stationChoiceString <- paste0(s, collapse = "&siteid=")
  
  # rv$wqp_url <- paste0("https://www.waterqualitydata.us/data/Result/search?siteid=", stationChoiceString, "&characteristicType=", charTypeChoiceString, "&sampleMedia=Water&mimeType=csv&zip=no") # <<<<<< GO BACK TO THIS AFTER WQP FIXED
    
    rv$wqp_url <- paste0("https://www.waterqualitydata.us/data/Result/search?siteid=", stationChoiceString, "&sampleMedia=Water&mimeType=csv&zip=no")

cat("line2993")
  # Create tab with the summary info after downloading it. Add totals to message. Check what generates the white highlight.

showModal(modalDialog(
  title = "Done",
  HTML(paste0("<strong>You have selected ", sum(rv$selectedDataSummary$ResultCount), " data records from ", length(unique(rv$selectedDataSummary$MonitoringLocationIdentifier)), " sites.</strong> Review your selection in the 'Summary of Selected Data' and 'Summary of Selected Characteristics' tabs. <br><br>Selected monitoring sites are shown as larger, white-outlined circles on the map.", 
              switch((input$sel_SelectMethod == "methodDist")+1, "", "The ORIGIN SITE is outlined in RED. The selected streamlines upstream of the origin are shown in white; downstream, in brown."),
              "<br><br>Select gage and weather stations (if available), then press the <strong>DOWNLOAD SELECTED DATA</strong> button to import the water quality data."))
))
  
  if(!is.null(rv$meteoStations)|!is.null(rv$gageStations)) {
    shiny::req(!is.null(rv$selectedDataSummary))
    shinyjs::showElement("new_data_P3")
    shinyjs::showElement("new_data_P4")
    cat("line3006")
  }
})
  }, ignoreInit = TRUE) # end of observeEvent
```

```{r action_button_downloadData}
# Action to download WQP data ----
observeEvent(eventExpr = input$button_downloadData, { 

    if(length(input$sel_Organization) == 0) { # make sure organization(s) have been selected
    showModal(modalDialog(
      title = "No organizations selected",
      "Please select (from the checklist) at least one organization from which you would like water quality data."
    ))
    }
  shiny::req(length(input$sel_Organization) > 0)
  
  if(length(input$sel_CharType) == 0) { # make sure characteristic group(s) have been selected
    showModal(modalDialog(
      title = "No characteristic groups selected",
      "Please select (from the checklist) at least one characteristic group of data to import."
    ))
    }
  shiny::req(length(input$sel_CharType) > 0)
  
  # if(is.null(rv$selectedStations) | length(rv$selectedStations$MonitoringLocationIdentifier) == 0 | is.null(rv$wqp_url_list)) {
    if(is.null(rv$selectedStations) | length(rv$selectedStations$MonitoringLocationIdentifier) == 0 | is.null(rv$wqp_url)) {
    showModal(modalDialog(
      title = "No monitoring sites selected",
      "Please select monitoring sites from which you would like to import data (filter sites by HUC or by distance from origin, then click the 'Summarize Selected Sites' button)."
    ))
  }
  # shiny::req(!is.null(rv$selectedStations), !is.null(rv$sitesPointsSub), !is.null(rv$wqp_url_list))
  shiny::req(!is.null(rv$selectedStations), !is.null(rv$sitesPointsSub), !is.null(rv$wqp_url))
  shiny::req(length(rv$selectedStations$MonitoringLocationIdentifier) > 0)

    withProgress(message = "Processing data request...", detail = "Importing data from Water Quality Portal (please be patient!)", value = 0, {
      
      showModal(tags$div(id = "gif_modal", modalDialog(
        HTML('<img src="https://media.giphy.com/media/33zX3zllJBGY8/source.gif"><br><center>I am just your entertainment.<br><center>The progress bar is below.'), # custom loading gif--running elephant
        easyClose = TRUE,
        footer = NULL
      )))
      
  # temp_dat_list <- lapply(rv$wqp_url_list, FUN = function(wqp_url) {
      # temp_dat_list <- list()
      # for(i in 1:length(rv$wqp_url_list)) {
      #   wqp_url <- rv$wqp_url_list[[i]]
      
 #            saveRDS(isolate(reactiveValuesToList(rv)), here::here(
 #   "TEMP_rv.RDS"))
 # saveRDS(isolate(reactiveValuesToList(rv_param_temp)), here::here("TEMP_rv_param_temp.RDS"))
 # saveRDS(isolate(reactiveValuesToList(input)), here::here("TEMP_input.RDS"))
   
      if(httr::http_status(GET(rv$wqp_url))$category!="Success") { # make sure the service call is valid
      showModal(
        urlModal(rv$wqp_url, title = "Data Retrieval Error", subtitle = htmltools::HTML(paste0("Error retrieving data from the Water Quality Portal for the requested query. The message from the web service is: `", httr::http_status(GET(rv$wqp_url))$message, "`.<br><br><strong>To confirm this is a problem with the web service (and not the dashboard), enter the above URL in a browser and see if data successfully downloads.</strong> If an error results, email WQP support (wqx@epa.gov) for assistance. If this is an issue with the dashboard, help us improve this dashboard by reporting the problem via the project GitHub page: https://github.com/nationalparkservice/WQdash_public<br><br>")))
        )
      }

  shiny::validate(need(httr::http_status(GET(rv$wqp_url))$category=="Success", message = FALSE)) # if not a valid service call, abort
  
  cat(rv$wqp_url)
  download.file(rv$wqp_url, "tempDat.csv", mode = "w") # in Windows, mode = "w" when opening text files and "wb" for other types, such as .jpg
 
  # temp_dat_list[[i]] <- read.csv("tempDat.csv") # use read.csv instead of read_csv so will convert '/' in column names to '.'
 tempDat <- read.csv("tempDat.csv") %>%
   dplyr::filter(CharacteristicName %in% unique(rv$selectedDataSummary$CharacteristicName)) # use read.csv instead of read_csv so will convert '/' in column names to '.' <<<<<<<<<<<< TEMPORARILY FILTER IT AFTER DOWNLOAD DUE TO WQP ISSUES WITH FILTERING BY CHARACTERISTIC
  # cat("next set of sites to download")
  # }
  
  # tempDat <- do.call(rbind.data.frame, temp_dat_list)
  # rm(temp_dat_list)
  # unlink("tempSites.csv")
 unlink("tempDat.csv")

# Format WQP data ----
  setProgress(1/4, detail = "Formatting data")
  
  # Convert to NA, any records with no data reported
  no_data_strings <- c("Not Reported", "No Data", "UNK", "Unknown")
  tempDat$ResultMeasureValue[grep(paste(no_data_strings, collapse = "|"), tempDat$ResultMeasureValue)] <- NA # <<<< ERROR CHECK

  # Detected and Quantified
  tempDat[tempDat==""] <- NA
  tempDat$ResultMeasure.MeasureUnitCode[is.na(tempDat$ResultMeasure.MeasureUnitCode) & !is.na(tempDat$DetectionQuantitationLimitMeasure.MeasureUnitCode)] <- tempDat$DetectionQuantitationLimitMeasure.MeasureUnitCode[is.na(tempDat$ResultMeasure.MeasureUnitCode) & !is.na(tempDat$DetectionQuantitationLimitMeasure.MeasureUnitCode)]
  tempDat$ResultDetectionConditionText[is.na(tempDat$ResultDetectionConditionText)] <- "Detected and Quantified"
 cat("line2918")
 
  # Split survey date
  tempDat$ActivityStartDate = base::as.Date(tempDat$ActivityStartDate)
  tempDat2 <- FuncBreakDates(tempDat) %>%
    dplyr::mutate(CharacteristicSet = paste(OrganizationIdentifier, CharacteristicName, ResultSampleFractionText, ResultMeasure.MeasureUnitCode, ResultAnalyticalMethod.MethodIdentifier, sep = "_")) %>% # this is the column for identifying comparable records (also optionally consider OrganizationIdentifier and LaboratoryName)
    dplyr::arrange(CharacteristicName, MonitoringLocationIdentifier, ActivityStartDate)
 cat("line3327")
  # Remove characteristics with string class values
  paramText <- unique(tempDat2$CharacteristicName[grepl(pattern="(text)", x=tempDat2$CharacteristicName)])
  tempDat2 %<>%
    dplyr::filter(!CharacteristicName %in% paramText)

  convert_factors <- c("OrganizationIdentifier", "OrganizationFormalName", "ActivityTypeCode", "ActivityStartTime.TimeZoneCode", "MonitoringLocationIdentifier", "HydrologicCondition", "HydrologicEvent", "ResultDetectionConditionText", "CharacteristicName", "ResultSampleFractionText", "ResultStatusIdentifier", "ResultValueTypeName", "DetectionQuantitationLimitTypeName", "CharacteristicSet")
  tempDat2[convert_factors] <- sapply(tempDat2[convert_factors], as.factor) # convert these to factor class so they can be searched with drop-down lists
  
  rv$dat <- tempDat2 %>%
    dplyr::ungroup() %>%
    dplyr::mutate(CharSampleType = paste0(CharacteristicName, " (", ifelse(is.na(ResultSampleFractionText), ResultMeasure.MeasureUnitCode, paste(ResultSampleFractionText, ResultMeasure.MeasureUnitCode, sep = "; ")), ")")) %>% # add CharSampleType column--this includes characteristic name, sample fraction, and measurement unit
    dplyr::select(OrganizationIdentifier, OrganizationFormalName, MonitoringLocationIdentifier, ActivityStartDate, ActivityTypeCode, CharacteristicName, CharSampleType, ResultSampleFractionText, ResultMeasureValue, ResultMeasure.MeasureUnitCode, ResultDetectionConditionText, everything()) # Most important variables first, followed by everything else
  rm(tempDat, tempDat2, paramText)
  unlink("tempDat.csv")
  cat("Line3342")
  # Get organization information for WQP data ----
  shiny::req(!is.null(rv$dat))
    # Limited to specified date range and minimum activities number
  allOrgs <- paste(paste0("organization=", unique(rv$dat$OrganizationIdentifier)), collapse = "&")
    orgURL <- paste0("https://www.waterqualitydata.us/data/Organization/search?", allOrgs, "&mimeType=csv&zip=no&providers=NWIS&providers=STEWARDS&providers=STORET")
cat("Line3348")
  if(httr::http_status(GET(orgURL))$category!="Success") { # make sure the service call is valid
    showModal(
      urlModal(orgURL, title = "Data Retrieval Error", subtitle = htmltools::HTML(paste0("Error retrieving organization information from the Water Quality Portal. The message from the web service is: `", httr::http_status(GET(orgURL))$message, "`.<br><br><strong>To confirm this is a problem with the web service (and not the dashboard), enter the above URL in a browser and see if data successfully downloads.</strong> If this is an issue with the dashboard, help us improve this dashboard by reporting the problem via the project GitHub page: https://github.com/nationalparkservice/WQdash_public<br><br>")))
      )
  }
    
  shiny::req(httr::http_status(GET(orgURL))$category=="Success") # if not a valid service call, abort

    download.file(orgURL, "tempOrg.csv", mode = "w")
  
  rv$orgs <- read_csv("tempOrg.csv") %>%
    dplyr::select(OrganizationFormalName, Description = OrganizationDescriptionText, `Email/Web` = ElectronicAddress, Phone = Telephonic) %>%
    dplyr::mutate(Selected = TRUE) %>%
    arrange(OrganizationFormalName) %>%
    as.data.frame
  
  rm(orgURL, allOrgs)
  unlink("tempOrg.csv")
  
  # Get streamflow data from selected gage stations ----
  # Waiting to hear back about getting info on Federal Priority Streamgages
  if(all(!is.null(rv$gageStations), !is.null(rv$selectedGages))) {
    if(all(nrow(rv$gageStations) > 0, length(rv$selectedGages) > 0)) {
  setProgress(2/4, detail = "Getting streamflow data from selected USGS gage stations")
      
  # gagesDatURL <- paste0("https://waterservices.usgs.gov/nwis/dv/?format=rdb,1.0&sites=", paste(rv$selectedGages$GageID, collapse = ","), "&startDT=", format(input$sel_ImportStartDate,"%Y-%m-%d"), "&endDT=", format(input$sel_ImportEndDate,"%Y-%m-%d"), "&siteStatus=all")
  
  gagesDatURL <- paste0("https://waterservices.usgs.gov/nwis/dv/?format=rdb,1.0&sites=", paste(rv$selectedGages$GageID, collapse = ","), "&startDT=",range(rv$dat$ActivityStartDate)[1], "&endDT=", range(rv$dat$ActivityStartDate)[2], "&siteStatus=all") # <<<< GOT RID OF START STOP AND END DATE OPTION HERE
  
  if(httr::http_status(GET(gagesDatURL))$category!="Success") { # make sure the service call is valid
    rv$gagesDat <- NULL
    showModal(modalDialog(
      title = "No Streamflow Data",
      "Error retrieving data for selected stream gages."
      ))
    } else {
      download.file(gagesDatURL, "tempGagesDat.txt", mode = "w")
      
      gagesDat <- tryCatch(read.delim("tempGagesDat.txt", comment.char = '#'), error=function(e) print("Error retrieving USGS streamflow data")) # These daily data are  'Discharge, cubic feet per second (Mean)'. QC: 'A' means approved for publication, processing and review completed; 'e' means value has been estimated
     
    shiny::req(!is.null(gagesDat))
    names(gagesDat) <- c("Agency", "GageID", "ActivityStartDate", "MeanDailyDischarge", "MeanDailyDischargeQC")
    gagesDat <- subset(gagesDat, Agency == "USGS") %>%
      dplyr::select(Agency, GageID, ActivityStartDate, MeanDailyDischarge, MeanDailyDischargeQC) %>%
      left_join(unique(rv$selectedGages[c("GageName", "GageID")]), by = "GageID")
    gagesDat$ActivityStartDate<- base::as.Date(gagesDat$ActivityStartDate)
    gagesDat$MeanDailyDischarge <- as.integer(gagesDat$MeanDailyDischarge)
    rv$gagesDat <- FuncBreakDates(gagesDat)
    rm(gagesDat, gagesDatURL)
    unlink("tempGagesDat.txt")
    }
    }
  }
  
  # Get precipitation data from selected weather stations ----

rv$meteoDat <- NULL
# if(all(!is.null(rv$meteoStations), !is.null(rv$selectedMeteo))) {
#   if(all(nrow(rv$meteoStations) > 0, length(rv$selectedMeteo) > 0)) {
#     setProgress(3/4, detail = "Getting precipitation data from selected weather stations")
# 
#     tempMeteoDat <- NULL
# 
#     tryCatch({
#       # Create spatial points from selected weather stations
#       # rv$selectedMeteo has longitude/latitude columns
#       stations_sf <- rv$selectedMeteo %>%
#         # Make sure have coordinates - adjust column names as needed
#         filter(!is.na(longitude), !is.na(latitude)) %>%
#         st_as_sf(coords = c("longitude", "latitude"), crs = 4326)
# 
#       if(nrow(stations_sf) > 0) {
#         # Get precipitation data using climateR (no token needed!)
#         precip_raw <- getGridMET(
#           AOI = stations_sf,
#           param = "pr",  # precipitation
#           startDate = as.Date(range(rv$dat$ActivityStartDate)[1]),
#           endDate = as.Date(range(rv$dat$ActivityStartDate)[2])
#         )
# 
#         # Transform to match existing data structure
#         if(!is.null(precip_raw) && nrow(precip_raw) > 0) {
#           tempMeteoDat <- precip_raw %>%
#             # Adjust column names based on what climateR returns
#             select(
#               ActivityStartDate = date,
#               prcp = pr,  # precipitation in mm
#               station_id = id  # or whatever identifier climateR provides
#             ) %>%
#             filter(!is.na(prcp)) %>%
#             mutate(
#               prcp = as.numeric(prcp),
#               PRCP_cm = prcp / 10,  # Convert mm to cm
#               qflag_prcp = " ",  # climateR data is quality controlled
#               # Match with station metadata
#               MeteoShortID = station_id
#             ) %>%
#             # Join with station names
#             left_join(
#               rv$selectedMeteo %>% select(MeteoName, MeteoShortID),
#               by = "MeteoShortID"
#             ) %>%
#             select(MeteoShortID, ActivityStartDate, PRCP_cm, MeteoName)
# 
#           # Clean and process as before
#           tempMeteoDat2 <- tempMeteoDat[complete.cases(tempMeteoDat), ]
#           tempMeteoDat2$ActivityStartDate <- base::as.Date(tempMeteoDat2$ActivityStartDate)
#           rv$meteoDat <- FuncBreakDates(tempMeteoDat2)
#           rm(tempMeteoDat, tempMeteoDat2)
#         }
#       }
#     }, error = function(e) {
#       warning("Failed to get precipitation data: ", e$message)
#       rv$meteoDat <- NULL
#       rv$meteoStations <- NULL
#       rv$selectedMeteo <- NULL
#     })
#   }
# }
  
      # Fallback if no data retrieved
    if(is.null(rv$meteoDat)) {
      rv$meteoStations <- NULL
      rv$selectedMeteo <- NULL
    }
  ### Save query
  cat("line3496")
  # Update rv$importSettings with the import settings
  import_input <- c("sel_UnitCode", "sel_SiteType", "sel_HUClevel", "sel_SelectMethod", "sel_OriginStationID", "sel_DiskKmUpstream", "sel_IncludeTribs", "sel_DistKmDownstream", "sel_IncludeDiversions", "sel_Organization", "sel_Gages", "sel_Meteo", "sel_CharType") 
  FuncUpdateImportSettings(inputs_to_update = import_input) 
  cat("line3500")
    rv$orgs$Selected <- FALSE
    rv$orgs$Selected[rv$orgs$OrganizationFormalName %in% input$sel_Organization] <- TRUE # identify if each organization was selected for import or not
    
    # Initial data filter
    shiny::req(!is.null(rv$dat))
    FuncInitFilter() # calculate default filter inputs based on rv$dat
    rv_param_temp$newImport <- TRUE
    cat("line3508--set new import to true")
    FuncUpdateFilterInputs() 
    cat("line3510")
    FuncRefreshFilter(sel_MinYrs = rv_param_temp$defaultInputs$sel_MinYrs, sel_SummaryParam = rv_param_temp$selectCharSampleType, sel_SummaryOrg = rv_param_temp$defaultInputs$sel_SummaryOrg, sel_YrRange = rv_param_temp$defaultInputs$sel_YrRange, sel_ActivityType = rv_param_temp$defaultInputs$sel_ActivityType, sel_ResultStatus = rv_param_temp$defaultInputs$sel_ResultStatus, sel_DefineSeasons = rv_param_temp$defaultInputs$sel_DefineSeasons) # generate the initial filtered data based on default filters. Also call this filter when action button clicked for refreshing filter
cat("line3512")

  rv_param_temp$subDat <- NULL
  rv_param_temp$plotDat <- NULL # Just to make doubly sure everything is cleared out
  rv_param_temp$threshList <- NULL
  rv_param_temp$threshDF <- NULL
  rv_param_temp$categLevelsPlot <- NULL
 cat("line3522")
    showModal(modalDialog(
      title = "Done",
      HTML(paste0("Data import SUCCESSFUL. OPTIONAL: To download the formatted data file (.RDS) to your computer, press the <strong>`Save RDS to Computer` </strong> button in the left side panel. You may now navigate to the other dashboard pages. ")) 
    ))
    cat("line3527")
  })
}, ignoreInit = TRUE) # end of observeEvent
```

```{r events_import_page}
observeEvent(eventExpr = input$dismiss_discharge_modal, {
  removeModal()
  })

observeEvent(eventExpr = input$dismiss_weather_modal, {
  removeModal()
  })

observeEvent(eventExpr = input$dismiss_gages_modal, {
  removeModal()
  })
  
# renderUI({
#   print("line3119")
#   shiny::req(!is.null(rv$meteoStations), !is.null(input$sel_GetData), is.null(rv$dat))
#   shiny::req(input$sel_GetData == "new_data")
#   print("line3122")
#   rv$selectedMeteo <- switch(is.null(input$sel_Meteo)+1, rv$meteoStations[rv$meteoStations$MeteoName %in% input$sel_Meteo,], NULL)
#   print("line3124")
# })

# renderUI({
observe({
  shiny::req(!is.null(rv$gageStations), !is.null(input$sel_GetData), is.null(rv$dat))
  shiny::req(input$sel_GetData == "new_data")

  rv$selectedGages <- switch(is.null(input$sel_Gages)+1, rv$gageStations[rv$gageStations$GageName %in% input$sel_Gages,], NULL)
  # Sys.sleep(1)
})
```

```{r events_filter_page}
# Show or hide the well panels based on checkbox selection, but enable them as soon as rv$dat is available ----

# Action to attach a thresholds file ----
observeEvent(eventExpr = input$button_getThreshFile, {
  if(is.null(rv$dat)) { # can't print validation message within observeEvent, so use modalDialogs
    rv_param_temp$threshList <- NULL
    showModal(modalDialog(
      title = "No Data",
      "Could not find any water quality data to associate with a threshold limits file. To import or load water quality data, use the dashboard page titled 'Get WQP Data'."
    ))
  }

  # if(is.null(rv_param_temp$subDat)) {
  #   showModal(modalDialog(
  #     title = "No Filter Selection",
  #     "From the left sidebar, please choose a subset of data to work with."
  #   ))
  #   }

  # shiny::req(!is.null(input$sel_GetThreshFile))
  # if (input$sel_GetThreshFile == "existing_data") {
    showModal(modalDialog(
      fileInput("saved_thresh_file", label = "Attach a threshold limits file ('csv' extension)", placeholder = "Click 'Browse...' button then navigate to file", accept = c('.csv'), width = "100%"),
               footer = tagList(
                 modalButton("Cancel")
               )
    ))
  # }
}) # end observeEvent

# Action to load threshold limits .csv file ----
# These will be the default threshold values used with these data, but user can override
observeEvent(eventExpr = input$saved_thresh_file, {
  shiny::req(!is.null(input$saved_thresh_file$datapath), !is.null(rv$dat), !is.null(rv_param_temp$subDat))
  
  if(!tools::file_ext(input$saved_thresh_file$datapath) == "csv") {
    showModal(modalDialog(
    title = "Error",
    "File must have .csv extension. Please select a different file."
    ))
  } else {

    tryCatch(out_thresh_file <- read_csv(input$saved_thresh_file$datapath),
             error = function(e) {out_categ_file <- NULL; print("Cannot import the selected file")})

  shiny::req(!is.null(out_thresh_file))

#   out_thresh_file[] <- lapply(out_thresh_file, as.character) # convert all cols to character.
#   tempThresh_df <- out_thresh_file %>%
#       dplyr::mutate(CharSampleType = paste0(CharacteristicName, " (", ifelse(is.na(SampleFraction), MeasureUnit, paste(SampleFraction, MeasureUnit, sep = "; ")), ")")) # unique characteristic ID, for user choice
# 
#     tempThresh_list <- list()
#     for (i in 1:nrow(tempThresh_df)) {
#       threshID <- unlist(tempThresh_df[i, "CharSampleType"])
#       tempThresh_list[[threshID]]$CharacteristicName <- tempThresh_df$CharacteristicName[i]
#       tempThresh_list[[threshID]]$ResultSampleFractionText <- tempThresh_df$SampleFraction[i]
#       tempThresh_list[[threshID]]$ResultMeasure.MeasureUnitCode <- tempThresh_df$MeasureUnit[i]
#       tempThresh_list[[threshID]]$Notes <- tempThresh_df$Notes[i]
#       tempThresh_list[[threshID]]$cut_breaks <- as.numeric(unlist(base::strsplit(stringr::str_replace_all(tempThresh_df$ThreshBreaks[i], "[()]", ""), split="//")))
#       tempThresh_list[[threshID]]$cut_categ <- unlist(base::strsplit(stringr::str_replace_all(tempThresh_df$ThreshCateg[i], "[()]", ""), split="//"))
#     }
#     
#     rv_param_temp$threshList <- tempThresh_list
# >>>>>>>>>>>>> NEW BELOW
  cat("line3623")

out_thresh_file[] <- lapply(out_thresh_file, as.character) # convert all cols to character.
tempThresh_df <- out_thresh_file %>%
    dplyr::mutate(CharSampleType = paste0(CharacteristicName, " (", ifelse(is.na(SampleFraction), MeasureUnit, paste(SampleFraction, MeasureUnit, sep = "; ")), ")")) %>% # unique characteristic ID, for user choice
    dplyr::mutate(
      # Vectorized creation of cut_categ_label
      cut_categ_label = purrr::map2(ThreshBreaks, ThreshCateg, function(breaks_str, categ_str) {
        # Parse breaks and categories
        breaks <- as.numeric(unlist(base::strsplit(stringr::str_replace_all(breaks_str, "[()]", ""), split="//")))
        categ <- unlist(base::strsplit(stringr::str_replace_all(categ_str, "[()]", ""), split="//"))
        
        # Create custom labels for each interval
        custom_labels <- character(length(categ))
        
        for (i in seq_along(categ)) {
          lower <- breaks[i]
          upper <- breaks[i + 1]
          
          if (is.infinite(lower) && lower < 0) {
            # -Inf to upper
            custom_labels[i] <- paste0(tools::toTitleCase(categ[i]), " (≤", upper, ")")
          } else if (is.infinite(upper) && upper > 0) {
            # lower to +Inf  
            custom_labels[i] <- paste0(tools::toTitleCase(categ[i]), " (>", lower, ")")
          } else {
            # finite range
            custom_labels[i] <- paste0(tools::toTitleCase(categ[i]), " (>", lower, " to ", upper, ")")
          }
        }
        
        return(custom_labels)
      })
    )
cat("line3656")
tempThresh_list <- list()
for (i in 1:nrow(tempThresh_df)) {
  threshID <- unlist(tempThresh_df[i, "CharSampleType"])
  tempThresh_list[[threshID]]$CharacteristicName <- tempThresh_df$CharacteristicName[i]
  tempThresh_list[[threshID]]$ResultSampleFractionText <- tempThresh_df$SampleFraction[i]
  tempThresh_list[[threshID]]$ResultMeasure.MeasureUnitCode <- tempThresh_df$MeasureUnit[i]
  tempThresh_list[[threshID]]$Notes <- tempThresh_df$Notes[i]
  tempThresh_list[[threshID]]$cut_breaks <- as.numeric(unlist(base::strsplit(stringr::str_replace_all(tempThresh_df$ThreshBreaks[i], "[()]", ""), split="//")))
  tempThresh_list[[threshID]]$cut_categ <- unlist(base::strsplit(stringr::str_replace_all(tempThresh_df$ThreshCateg[i], "[()]", ""), split="//"))
  tempThresh_list[[threshID]]$cut_categ_label <- tempThresh_df$cut_categ_label[[i]]
}
cat("line3668")
rv_param_temp$threshList <- tempThresh_list
#>>>>>>>>>>>>>>>>>>>> NEW ABOVE
    
    showModal(modalDialog(
      title = "Done",
      "Threshold limits file has been imported"
    ))
  }
}, ignoreInit = TRUE) # end of observeEvent

# Reactively update whenever rv_param_temp$subDat or rv_param_temp$threshList change
observe({
  shiny::req(!is.null(rv_param_temp$subDat))
  
           saveRDS(isolate(reactiveValuesToList(rv)), here::here("TEMP_rv.RDS"))
  saveRDS(isolate(reactiveValuesToList(rv_param_temp)), here::here("TEMP_rv_param_temp.RDS"))
  saveRDS(isolate(reactiveValuesToList(input)), here::here("TEMP_input.RDS"))
  
  if(!is.null(rv_param_temp$threshList)) {
      for (t in names(rv_param_temp$threshList)) {
    which_rows <- which(tolower(rv_param_temp$subDat$CharacteristicName) == tolower(t)) # Don't require case to match
    if(length(which_rows) > 0) {
      rv_param_temp$subDat$ThreshCateg[which_rows] <- as.character(cut(as.numeric(rv_param_temp$subDat$ResultMeasureValue_replaced[which_rows]), breaks = rv_param_temp$threshList[[t]]$cut_breaks, labels = rv_param_temp$threshList[[t]]$cut_categ)) # assign the threshold category to each record
    }
  }
  
  # Calculate threshold counts with labels
    if(is.logical(rv_param_temp$subDat$ThreshCateg)) {rv_param_temp$subDat$ThreshCateg <- as.character(rv_param_temp$subDat$ThreshCateg)} # <<<<<<<<<<<<<<<<<
  rv_param_temp$threshDF <- rv_param_temp$subDat %>%
  dplyr::filter(!is.na(ResultMeasureValue_replaced) & !is.na(ThreshCateg)) %>%
  dplyr::group_by(MonitoringLocationIdentifier, CharSampleType, ResultMeasure.MeasureUnitCode, ThreshCateg) %>%
  dplyr::summarise(n = n(), .groups = 'drop') %>%
  dplyr::mutate(threshold_key = paste0(CharSampleType, " (", ResultMeasure.MeasureUnitCode, ")")) %>%
  dplyr::left_join(
    # Create lookup table from threshList
    do.call(rbind, lapply(names(rv_param_temp$threshList), function(key) {
      if (!is.null(rv_param_temp$threshList[[key]]$cut_categ_label)) {
        data.frame(
          threshold_key = key,
          ThreshCateg = rv_param_temp$threshList[[key]]$cut_categ,
          ThreshCateg_Label = rv_param_temp$threshList[[key]]$cut_categ_label,
          stringsAsFactors = FALSE
        )
      }
    })),
    by = c("threshold_key", "ThreshCateg")
  ) %>%
  dplyr::mutate(ThreshCateg_Label = ifelse(is.na(ThreshCateg_Label), tools::toTitleCase(ThreshCateg), ThreshCateg_Label)) %>%
  dplyr::select(Site = MonitoringLocationIdentifier, Characteristic = CharSampleType, Unit = ResultMeasure.MeasureUnitCode, ThreshCateg, ThreshCateg_Label, n)
  }


  # Create pop-up table for map clicks
  rv_param_temp$popupSiteSummary <- rv_param_temp$subDat %>% 
    dplyr::select(MonitoringLocationIdentifier, CharSampleType, Yr, ActivityStartDate, ResultMeasureValue_replaced, ResultMeasure.MeasureUnitCode, ResultDetectionConditionText, ThreshCateg) %>%
    dplyr::filter(!is.na(ResultMeasureValue_replaced)) %>%
    dplyr::group_by(MonitoringLocationIdentifier, CharSampleType, ResultMeasure.MeasureUnitCode) %>%
    dplyr::arrange(MonitoringLocationIdentifier, CharSampleType, desc(ActivityStartDate)) %>%
    dplyr::summarise(
      Sample_Size = n(),
      Year_Range = if(min(Yr, na.rm = TRUE) == max(Yr, na.rm = TRUE)) {
        as.character(min(Yr, na.rm = TRUE))
      } else {
        paste0(min(Yr, na.rm = TRUE), "–", max(Yr, na.rm = TRUE))
      },
        Lowest_Value_Numeric = min(ResultMeasureValue_replaced, na.rm = TRUE),   
  Highest_Value_Numeric = max(ResultMeasureValue_replaced, na.rm = TRUE),  
      Lowest_Value = {
        min_val <- min(ResultMeasureValue_replaced, na.rm = TRUE)
        min_conditions <- unique(ResultDetectionConditionText[ResultMeasureValue_replaced == min_val & !is.na(ResultDetectionConditionText)])
        min_conditions <- min_conditions[min_conditions != ""]
        if(length(min_conditions) > 0) {
          paste0(min_val, " (", paste(min_conditions, collapse = "/"), ")")
        } else {
          as.character(min_val)
        }
      },
      Highest_Value = {
        max_val <- max(ResultMeasureValue_replaced, na.rm = TRUE)
        max_conditions <- unique(ResultDetectionConditionText[ResultMeasureValue_replaced == max_val & !is.na(ResultDetectionConditionText)])
        max_conditions <- max_conditions[max_conditions != ""]
        if(length(max_conditions) > 0) {
          paste0(max_val, " (", paste(max_conditions, collapse = "/"), ")")
        } else {
          as.character(max_val)
        }
      },
      
      Most_Recent_Value = first(ResultMeasureValue_replaced),
      Most_Recent_Sample_Date = first(ActivityStartDate),
      
      Recent_Values = {
        recent_vals <- head(ResultMeasureValue_replaced, 5)
        paste(recent_vals[!is.na(recent_vals)], collapse = ",")
      },
      
      Recent_Dates = {
        recent_dates <- head(ActivityStartDate, 5)
        paste(format(recent_dates[!is.na(recent_dates)], "%Y-%m-%d"), collapse = ",")
      },
      
      Recent_Detection_Conditions = {
        recent_conditions <- head(ResultDetectionConditionText, 5)
        recent_conditions <- recent_conditions[!is.na(recent_conditions) & recent_conditions != ""]
        paste(recent_conditions, collapse = ",")
      },
      
      .groups = 'drop'
    ) %>%
    
    select(
      Site = MonitoringLocationIdentifier,
      Characteristic = CharSampleType,
      Unit = ResultMeasure.MeasureUnitCode,
      Sample_Size,
      Year_Range,
      Lowest_Value_Numeric,
      Highest_Value_Numeric,
      Lowest_Value,
      Highest_Value,
      Most_Recent_Value,
      Most_Recent_Sample_Date,
      Recent_Values,
      Recent_Dates,
      Recent_Detection_Conditions
    )
})
```

```{r events_categfiles_page}
# Action to define categorical characteristics ----
observeEvent(eventExpr = input$button_getCategFile, { 
  # initiate categorical levels data frame
  if(is.null(rv$dat)) { # can't print validation message within observeEvent, so use modalDialogs
    rv_param_temp$categLevelsPlot <- NULL
    showModal(modalDialog(
      title = "No Data",
      "Could not find any water quality data to associate with a color coding file. To import or load water quality data, use the dashboard page titled 'Get WQP Data'."
    ))
  }
  cat("line3364")
  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$subDatTypes))
  cat("line3366")
  if(length(rv_param_temp$subDatTypes$CharSampleType[rv_param_temp$subDatTypes$DataType == "categorical"])==0) { # can't print validation message within observeEvent, so use modalDialogs
    rv_param_temp$categLevelsPlot <- NULL
    showModal(modalDialog(
      title = "No categorical parameters",
      "Could not find any categorical parameters among the filtered water quality data."
    ))
    }
  shiny::req(length(rv_param_temp$subDatTypes$CharSampleType[rv_param_temp$subDatTypes$DataType == "categorical"]) > 0)
  cat("line3375")
    rv_param_temp$categLevelsPlot <- tibble("CharSampleType" = as.character(), "CategOrder" = as.character(), "CategColor" = as.character())
  cat("line3377")
shiny::req(!is.null(input$sel_GetCategFile))
cat("line3379")
  if (input$sel_GetCategFile == "new_data" & !is.null(rv_param_temp$categLevelsPlot)) { # if user chooses to create a new file...
    cat("line3381")
    shinyjs::showElement("create_categfile_P1")
    shinyjs::showElement("create_categfile_P2")
    shinyjs::showElement("create_categfile_P3")
    shinyjs::showElement("create_categfile_P4")
    cat("line3385")
    } else { # if user chooses to load existing data...
      shinyjs::hideElement("create_categfile_P1")
      shinyjs::hideElement("create_categfile_P2")
      shinyjs::hideElement("create_categfile_P3")
      shinyjs::hideElement("create_categfile_P4")
      
      showModal(modalDialog(
        fileInput("saved_categ_file", label = "Attach a categorical definitions file ('csv' extension)", placeholder = "Click 'Browse...' button then navigate to file", accept = c('.csv'), width = "100%"),
               footer = tagList(
                 modalButton("Cancel")
               )
             ))
           }
         }) # end observeEvent

# Action to load optional color-coding .csv file ----
observeEvent(eventExpr = input$saved_categ_file, {
  shiny::req(!is.null(input$saved_categ_file$datapath))
  if(!tools::file_ext(input$saved_categ_file$datapath) == "csv") {
    showModal(modalDialog(
    title = "Error",
    "File must have .csv extension. Please select a different file."
    ))
  } else {

    tryCatch(out_categ_file <- read_csv(input$saved_categ_file$datapath),
             error = function(e) {out_categ_file <- NULL; print("Cannot import the selected file")})
    
  shiny::req(!is.null(out_categ_file))
  rv_param_temp$categLevelsPlot <- out_categ_file
  showModal(modalDialog(
    title = "Done",
    "Categorical definitions have been imported"
    ))
  }
  })

# Action to add category level ----
observeEvent(eventExpr = input$button_addCategLevel, {
  showModal(
    modalDialog(
      textInput("new_categlevel_text", "Enter a new level for the categorical characteristic: "),
      footer = tagList(
        div(style="display:inline-block; width:100px; margin-right:10px;", actionButton("button_cancelModal", "Cancel")),
        div(style="display:inline-block; width:180px;", actionButton("button_okAddCategLevelsModal", "Add to List"))
        ) # end footer tagList
      )
    )
  })

observeEvent(eventExpr = input$button_okAddCategLevelsModal, {
  shiny::req(!is.null(rv_param_temp$categLevels), !is.null(input$new_categlevel_text), nzchar(input$new_categlevel_text))
  rv_param_temp$categLevels <- data.frame(ResultMeasureValue = c(input$categ_ranked, input$new_categlevel_text)) # append the new category level, preserving the user-defined rank order
  removeModal()

  })

# Action to delete category level ----
observeEvent(eventExpr = input$button_deleteCategLevel, {
  shiny::req(!is.null(rv_param_temp$categLevels))
  if(nrow(rv_param_temp$categLevels)==0) { # can't print validation message within observeEvent, so use modalDialogs
    showModal(modalDialog(
      title = "No Data",
      "No categorical levels in list."
    ))
    }
  
  shiny::req(nrow(rv_param_temp$categLevels) > 0)
  showModal( 
    modalDialog(
      renderUI({
        selectInput("remove_categ_level",
                    label = "Categorical level to remove from list (will be color-coded as NA): ",
                    choices = rv_param_temp$categLevels$ResultMeasureValue,
                    selected = rv_param_temp$categLevels$ResultMeasureValue[1]
                    )
        }),
      footer = tagList(
        div(style="display:inline-block; width:100px; margin-right:10px;",
            
            actionButton("button_cancelModal", "Cancel")), # use actionButton instead of modalButton to ensure consistent sizing with other actionButton
        div(style="display:inline-block; width:180px;",
            actionButton("button_okDeleteCategLevelsModal", "Remove From List"))
        ) # end footer tagList
      )
    )
  })

observeEvent(eventExpr = input$button_okDeleteCategLevelsModal, {
  shiny::req(nrow(rv_param_temp$categLevels) > 0, !is.null(input$remove_categ_level))
  rv_param_temp$categLevels <- data.frame(ResultMeasureValue = setdiff(input$categ_ranked, input$remove_categ_level)) # remove the category level
  removeModal()
  })

# Action to show color palette options ----

observeEvent(input$button_showPalettes, {
  shinyjs::show("palette_popup")
})

observeEvent(input$close_palette_popup, {
  shinyjs::hide("palette_popup")
})

output$palette_plot <- renderPlot({
  display.brewer.all()
})

# Action to update the categorical definitions file ----
observeEvent(eventExpr = input$button_updateCategFile, {

  shiny::req(!is.null(rv_param_temp$categLevelsPlot), !is.null(input$sel_CategParam), !is.null(input$categ_ranked), !is.null(input$sel_CategPalette))  
  cat("line3494")
  rv_param_temp$categLevelsPlot %<>%
    add_row(
      CharSampleType = input$sel_CategParam, # characteristic type
      CategOrder = paste0("(", paste(input$categ_ranked, collapse = "//"), ")"), # categ order
      CategColor = paste0("(", paste(get_brewer_pal(input$sel_CategPalette, length(input$categ_ranked), plot = FALSE), collapse = "//"), ")") # categ color
    )
  })             
              
# Action to edit table cells ----
observeEvent(input$categDT_cell_edit, {
info = input$categDT_cell_edit
i = info$row
j = info$col
v = info$val
rv_param_temp$categLevelsPlot[i, j] <<- DT::coerceValue(v, rv_param_temp$categLevelsPlot[i, j])
replaceData(proxyDT, rv_param_temp$categLevelsPlot, resetPaging = FALSE)
})

# Action to delete table row ----
observeEvent(input$button_categDeleteRow, {
  shiny::req(!is.null(rv_param_temp$categLevelsPlot), !is.null(input$categDT_rows_selected))
    i = input$categDT_rows_selected
    rv_param_temp$categLevelsPlot <- rv_param_temp$categLevelsPlot[-i,]
    replaceData(proxyDT, rv_param_temp$categLevelsPlot, resetPaging = FALSE)
})

# # Action to add table row ----
# observeEvent(input$button_categAddRow, {
#   shiny::req(!is.null(rv_param_temp$categLevelsPlot))
#   rv_param_temp$categLevelsPlot %<>% 
#     add_row()
#   replaceData(proxyDT, rv_param_temp$categLevelsPlot, resetPaging = FALSE)
# })
```

```{r events_plots_page}

# Action to select all parameters for filter----
observeEvent(eventExpr = input$button_allSummaryParam, {
  shiny::req(!is.null(rv_param_temp$selectCharSampleType))
  
  rv_param_temp$currentInputs$sel_SummaryParam <- sort(rv_param_temp$selectCharSampleType)
  # updateCheckboxGroupInput(session,
  #                          "sel_SummaryParam",
  #                          selected = sort(rv_param_temp$selectCharSampleType))
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select no parameters for filter ----
observeEvent(eventExpr = input$button_noSummaryParam, {
  # shiny::req(!is.null(rv_param_temp$selectCharSampleType))
  
  rv_param_temp$currentInputs$sel_SummaryParam <- character(0)

  # updateCheckboxGroupInput(session,
  #                          "sel_SummaryParam",
  #                          selected = character(0))
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select all stations ----
observeEvent(eventExpr = input$button_allStations, {
  shiny::req(!is.null(rv_param_temp$subDat), input$sel_SummarizeBy == "by_chartype")
  updateCheckboxGroupInput(session,
                           "sel_ShowStations",
                           selected = sort(unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharSampleType %in% input$sel_ShowCharType])))
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select no stations ----
observeEvent(eventExpr = input$button_noStations, {
  shiny::req(!is.null(rv_param_temp$subDat), input$sel_SummarizeBy == "by_chartype")
  updateCheckboxGroupInput(session,
                           "sel_ShowStations",
                           selected = character(0))
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select all characteristics ----
observeEvent(eventExpr = input$button_allStationChars, {
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
  updateCheckboxGroupInput(session,
                           "sel_ShowStationCharTypes",
                           selected = sort(intersect(unique(rv_param_temp$subDat$CharSampleType[rv_param_temp$subDat$MonitoringLocationIdentifier == input$sel_ShowOneStation]), rv_param_temp$subDatTypes$CharSampleType[rv_param_temp$subDatTypes$DataType == "numeric"]))
  )
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select no characteristics ----
observeEvent(eventExpr = input$button_noStationChars, {
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
  updateCheckboxGroupInput(session,
                           "sel_ShowStationCharTypes",
                           # label = h6("Select characteristic(s):"),
                           selected = character(0))
  }, ignoreInit = TRUE) # end of observeEvent
      



```

```{r action_click_map_popup}
# Action to show summary statistics for map site on right click----
observeEvent(input$param_map_right_click, {
  shiny::req(!is.null(rv_param_temp$popupSiteSummary))
  cat("OBSERVE RIGHT CLICK")
  site <- input$param_map_right_click$MonitoringLocationIdentifier
  df <- isolate(rv_param_temp$popupSiteSummary) %>% dplyr::filter(Site == site) 
  site_threshold_df <- switch(is.null(isolate(rv_param_temp$threshDF))+1, isolate(rv_param_temp$threshDF) %>% dplyr::filter(Site == site), data.frame())

shiny::showModal(
  shiny::modalDialog(
    title = div(
      paste("Summary for", site),
      div(style = "float: right;", 
          actionButton("dismiss_modal", "Dismiss", class = "btn btn-secondary btn-sm",
                      onclick = "$('.modal').modal('hide');"))
    ),
        tags$style(HTML(".modal-dialog { max-width: 2400px !important; }")),
    FuncParamTable(
      df = df,
      threshold_df = site_threshold_df,
      MonitoringLocationIdentifier = site
    ),
    easyClose = TRUE,
    size = "l",
    footer = NULL  
  )
)
})


```

```{r action_button_update_param_map}
# Action to update data parameter map ----
# User selects stations by CLICKING MAP (to show data plots)
observeEvent(input$param_map_marker_click, {
  isolate({

  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(input$param_map_marker_click$id))# the last one keeps the map from aborting when user clicks on a marker that is not a site marker
shiny::req(any(is.null(input$sel_ParamMapShow), input$sel_ParamMapShow == "show"))  

    clicked_site <- input$param_map_marker_click$id
    print("GRABBED CLICKED SITE\n")

    if(clicked_site %in% isolate(rv_param_temp$param_map_highlight)) { # if the click is in a selected site
      print("WAS ALREADY SELECTED\n")

      if(all(input$sel_SummarizeBy == "by_station", length(isolate(rv_param_temp$param_map_highlight)) == 1, identical(clicked_site, isolate(rv_param_temp$param_map_highlight)))) {
        showModal(modalDialog(
          title = "Cannot de-select station",
          "You must highlight at least one station to summarize."
        ))
            } else {
              isolate(rv_param_temp$param_map_highlight <- rv_param_temp$param_map_highlight[rv_param_temp$param_map_highlight != clicked_site]) # then remove it from the list of selected sites
        print("REMOVED CLICKED SITE FROM VECTOR\n")
            }
      
        
        } else { # if the click is in an unselected site
          print("CLICKED SITE IS NEW\n")
          if(input$sel_SummarizeBy == "by_station") { # if summarizing by station
            rv_param_temp$param_map_highlight <- clicked_site
            print("UPDATED VECTOR WITH ONLY CLICKED SITE\n")
          } 
          if(input$sel_SummarizeBy == "by_chartype") {# if summarizing by characteristic
            rv_param_temp$param_map_highlight <- c(rv_param_temp$param_map_highlight, clicked_site) # append the ID of clicked site
            print("UPDATED VECTOR BY APPENDING CLICKED SITE\n")
          }

           print("ADDED CLICKED SITE ON MAP\n")
      }
    
    # Also update the user select in left side panel

    if(input$sel_SummarizeBy == "by_chartype") {
      updateCheckboxGroupInput(session,
                               "sel_ShowStations",
                               selected = rv_param_temp$param_map_highlight)
    }

    if(input$sel_SummarizeBy == "by_station") {
      updateSelectInput(session,
                        "sel_ShowOneStation",
                        selected = rv_param_temp$param_map_highlight)

    }
      
    # rv_param_temp$update_from_sidebar <- TRUE 
}) # end isolate


    }, ignoreInit = TRUE) # end of observeEvent

```

```{r action_button_refreshFilter}
observeEvent(eventExpr = input$button_refreshFilter, { 
# Returns rv_param_temp$subDat, rv_param_temp$subDatYears

  shiny::req(!is.null(rv$dat))
  
  FuncRefreshFilter(sel_MinYrs = input$sel_MinYrs, sel_SummaryParam = input$sel_SummaryParam, sel_SummaryOrg = input$sel_SummaryOrg, sel_YrRange = input$sel_YrRange, sel_ActivityType = input$sel_ActivityType, sel_ResultStatus = input$sel_ResultStatus, sel_DefineSeasons = input$sel_DefineSeasons)
})
```
  
```{r action_button_refreshPlotData}
# Action to update data summaries with current user inputs----

observeEvent(eventExpr = input$button_refreshPlotData, { 
  
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_SummarizeBy))
  

  # These are the user inputs that should only update when plots are refreshed.
  rv_param_temp$sel_summarize_by <- isolate(input$sel_SummarizeBy)

rv_param_temp$sel_show_thresholds <- isolate(input$sel_ShowThresholds) # save the input setting so plots don't change unless the plot data has been refreshed

  if(isolate(rv_param_temp$sel_summarize_by) == "by_chartype") {
    rv_param_temp$showStations <- isolate(input$sel_ShowStations)
    rv_param_temp$showCharTypes <- isolate(input$sel_ShowCharType)
  }

  rv_param_temp$sel_add_gage_precip <- isolate(input$sel_AddGagePrecip)
  rv_param_temp$sel_gage_station <- isolate(input$sel_GageStation)
  rv_param_temp$sel_gage_yscale <- isolate(input$sel_gage_YScale)
  rv_param_temp$sel_precip_station <- isolate(input$sel_PrecipStation)
  rv_param_temp$sel_precip_yscale <- isolate(input$sel_precip_YScale)

  if(rv_param_temp$sel_summarize_by == "by_station") {
    rv_param_temp$showStations <- isolate(input$sel_ShowOneStation)
    rv_param_temp$showCharTypes <- isolate(input$sel_ShowStationCharTypes)
   }

  
  if(is.null(rv_param_temp$showStations)) {
    showModal(modalDialog(
      title = "No Monitoring Sites Selected",
      "From the left sidebar, please select at least one monitoring site to plot"
      ))
    }
  shiny::req(!is.null(rv_param_temp$showStations))
  
  if(is.null(rv_param_temp$showCharTypes)) {
    showModal(modalDialog(
      title = "No Characteristics Selected",
      "From the left sidebar, please select at least one characteristic to plot"
      ))
    }
  shiny::req(!is.null(rv_param_temp$showCharTypes))
      rv_param_temp$finalPlot <- rv_param_temp$seasonalPlot <- list(plotly_page = NULL, shared_legend = NULL)

# Format plot data for time series plot tab
  if(any(is.null(rv_param_temp$subDat),  is.null(rv_param_temp$showStations), is.null(rv_param_temp$showCharTypes), is.null(rv_param_temp$sel_summarize_by))) {
   
    rv_param_temp$plotDat <- NULL

  } else {          

      withProgress(message = "Formatting plot data...", value = 0, {
        
        if(is.null(rv_param_temp$sel_add_gage_precip)) {rv_param_temp$sel_add_gage_precip <- "none"}
        if(is.null(rv_param_temp$sel_show_thresholds)) {rv_param_temp$sel_show_thresholds <- "showthresh_none"}

          rv_param_temp$plotDat <- FuncPlotDat() # this function also assigns data to rv_param_temp$quantDat
      })
  }
})
```

```{r map_card}
output$param_map <- renderLeaflet({

  FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = FALSE) # make sure data have been imported and filtered, and plot data have been generated
  print("line3730")
    shiny::req(!is.null(rv_param_temp$subDat), !is.null(rv$sitesPointsSub), !is.null(rv$unitPoly), !is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$palOrg))
  
print("RENDERING ENTIRE MAP AGAIN\n") 

sel_param_map_show <- switch(is.null(input$sel_ParamMapShow)+1, input$sel_ParamMapShow, "show")

map_point_size <- switch(is.null(input$sel_MapPointSize)+1, input$sel_MapPointSize, 0)

  iconGages = makeAwesomeIcon(
    text = fa("water"),
    iconColor = "black",
    markerColor = "blue")
  
  iconGagesSelected = makeAwesomeIcon(
    text = fa("water"),
    iconColor = "black",
    markerColor = "orange")
  
  iconMeteo = makeAwesomeIcon(icon= "fa-cloud", library = "fa", squareMarker = TRUE, markerColor = "white")
  
  iconMeteoSelected = makeAwesomeIcon(icon= "fa-cloud", library = "fa", squareMarker = TRUE, markerColor = "orange") #
  
  iconCWA = makeAwesomeIcon(icon= "fa-building", library = "fa", markerColor = "lightgray")

    param_map <- leaflet(options = leafletOptions(zoomControl = FALSE, zoomSnap = 0.25)) %>%
    addMapPane("pane_param_selectedStations", zIndex = 250) %>% # higher index is on top
    addMapPane("pane_param_importedStations", zIndex = 245) %>%
    addMapPane("pane_param_polylines", zIndex = 230) %>%
    addMapPane("pane_param_facilitiesPointsSub", zIndex = 226) %>%
    addMapPane("pane_param_gageStations_selected", zIndex = 227) %>%
    addMapPane("pane_param_meteoStations_selected", zIndex = 227) %>%
    addMapPane("pane_param_HUC", zIndex = 220) %>%
    addMapPane("pane_param_unitPoly", zIndex = 210) %>%
    addTiles(options = tileOptions(noWrap = TRUE), group = "Street") %>%
    addProviderTiles("Esri.WorldImagery", options = providerTileOptions(noWrap = TRUE), group="Satellite") %>%
    addPolygons(data = rv$unitPoly, group = "NPS unit", color = "black", fillColor = "yellow", fillOpacity = 1, weight = 1, options = pathOptions(pane = "pane_param_unitPoly")) %>% # park unit outline
    addPolygons(data = rv[[rv$importSettings$sel_HUClevel]], group = paste0(rv$importSettings$sel_HUClevel, " boundaries"), color = "blue", fillColor = "lightblue", fillOpacity = 0.3, weight = 0.7, options = pathOptions(pane = "pane_param_HUC")) %>% # HUC polygons
    addScaleBar() %>%
    addControl(rv$parkID, position = "topleft", className="map-unitcode") # add 4-letter UNIT code on map

  

print("DONE WITH STANDARD MAP")

  # Done with the standard mapping. Now to conditional layers.

  show_layers <- data.frame(layer = c(paste0(rv$importSettings$sel_HUClevel, " boundaries"), "Imported monitoring sites", "Selected monitoring sites", "Imported stream lines", "Discharge facilities", "Selected gage stations", "Selected weather stations"), show = c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, TRUE)) # dataframe to track what layers to show
  print("line1796")
  if(input$sel_SummarizeBy == "by_chartype") { # if multiple sites per characteristic, then available sites are only those that actually have the selected characteristic
    shiny::req(!is.null(input$sel_ShowCharType))
    avail_sites_data <- rv$sitesPointsSub[rv$sitesPointsSub$MonitoringLocationIdentifier %in% unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharSampleType %in% input$sel_ShowCharType]),]
  } else {
    avail_sites_data <- rv$sitesPointsSub[rv$sitesPointsSub$MonitoringLocationIdentifier %in% unique(rv_param_temp$subDat$MonitoringLocationIdentifier),]
  }
print("line1803")
print("RENDERING AVAILABLE SITES IN FULL MAP\n")
  param_map %<>%
    addCircleMarkers(data = avail_sites_data, group = "Imported monitoring sites", layerId = ~MonitoringLocationIdentifier, label = ~SITELAB, radius = 12 + 3*map_point_size, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 0.8, stroke = TRUE, color = ~rv_param_temp$palOrg(OrganizationFormalName), opacity = 0.7, options = pathOptions(pane = "pane_param_importedStations")) # WQ stations for which data (for selected parameter) are available  
print("line1988")
# })
  

  # If UP-DOWN selection, show stream lines
  if(rv$importSettings$sel_SelectMethod=="methodDist") {
    show_layers$show[show_layers$layer == "Imported stream lines"] <- TRUE
  print("line2693")
    if(!is.null(rv$selectedDownstreamLines)) { # add selected downstreams in brown
      param_map %<>%
        addPolylines(data = rv$selectedDownstreamLines, color = "brown", weight = 2, opacity = 1, options = pathOptions(pane = "pane_param_polylines"), group = "Imported stream lines")
    }
  print("line2698")
        if(!is.null(rv$selectedUpstreamLines)) { # add selected upstreams in blue
      param_map %<>%
        addPolylines(data = rv$selectedUpstreamLines, color = "blue", weight = 2, opacity = 1, options = pathOptions(pane = "pane_param_polylines"), group = "Imported stream lines")
    }

  } else {
    show_layers$show[show_layers$layer == "Imported stream lines"] <- FALSE
  }

  print("line2707")
  
  # Show selected stream gages
  if(all(!is.null(rv$gageStations), !is.null(rv$selectedGages), rv$selectedGages$GageID %in% rv$gageStations$GageID)) {
    show_layers$show[show_layers$layer == "Selected gage stations"] <- TRUE
    
    param_map %<>%
      addAwesomeMarkers(icon = iconGagesSelected, data = rv$selectedGages, group = "Selected gage stations", label = ~GAGELAB, popup = ~GAGEPOP, options = pathOptions(pane = "pane_param_gageStations_selected")) # selected stream gage stations
  } else {
      show_layers$show[show_layers$layer == "Selected gage stations"] <- FALSE
    }
  
 
   # If weather stations have been found
  if(all(!is.null(rv$meteoStations), !is.null(rv$selectedMeteo), rv$selectedMeteo$MeteoID %in% rv$meteoStations$MeteoID)) {
    show_layers$show[show_layers$layer == "Selected weather stations"] <- TRUE
    
    param_map %<>%
      addAwesomeMarkers(icon = iconMeteoSelected, data = rv$selectedMeteo, group = "Selected weather stations", label = ~METEOLAB, popup = ~METEOPOP, options = pathOptions(pane = "pane_param_meteoStations_selected")) # selected weather stations
    } else {
      show_layers$show[show_layers$layer == "Selected weather stations"] <- FALSE
      }
 

  # If Discharge facilities have been found <<<<<<< DECIDE WHAT TO DO HERE
  if(!is.null(rv$facilitiesPointsSub)) {
    param_map %<>%
      addAwesomeMarkers(icon = iconCWA, data = rv$facilitiesPointsSub, group = "Discharge facilities", label = ~FACLAB, popup = ~FACPOP, options = pathOptions(pane = "pane_param_facilitiesPointsSub"))
    show_layers$show[show_layers$layer == "Discharge facilities"] <- TRUE
  } else {
    show_layers$show[show_layers$layer == "Discharge facilities"] <- FALSE
  }
  print("line2745")
  #

  print("line3098")
  
# Summarize selected sites
print("START OF SUMMARIZE SELECTED")

if(sel_param_map_show == "show") {

    # Need to do this on first go-around because don't yet have a param_map to update with proxy.
      sel_sites <- switch((input$sel_SummarizeBy == "by_chartype") + 1, input$sel_ShowOneStation, input$sel_ShowStations)

        rv_param_temp$param_map_highlight <- sel_sites
        
      print("START CHANGING MAP")
      if(length(sel_sites) > 0) {
        # Add white border on selected stations
        param_map %<>%
      addCircleMarkers(data = rv$sitesPointsSub[rv$sitesPointsSub$MonitoringLocationIdentifier %in% sel_sites,], group = "Selected monitoring sites", layerId = ~MonitoringLocationIdentifier, label = ~SITELAB, radius = 15 + 3*map_point_size, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 1, stroke = TRUE, weight = 4, color = "white", opacity = 1, options = pathOptions(pane = "pane_param_selectedStations"))
      }

    print("RENDERING SELECTED SITES IN FULL MAP\n")
          # }
}
  
print("line3881")
  # If summarizing by characteristic, then additional summary options are available
  if(all(input$sel_SummarizeBy == "by_chartype", !is.null(input$sel_MapByYr))) {

    # summarize stations by a single characteristic, user can choose from several summary functions...
    
    ## MEDIAN
    if(sel_param_map_show == "median") {
      shiny::validate(need(sum(!is.na(rv_param_temp$plotDat$ResultMeasureValue)) > 0, message = "No monitoring results available for these data"))
      
      pie_median <- rv_param_temp$plotDat %>%
        dplyr::filter(!is.na(ResultMeasureValue))
      
      if(input$sel_MapByYr == TRUE) {
        pie_median %<>% 
      dplyr::group_by(MonitoringLocationIdentifier, Yr)
  } else {
    pie_median %<>%
      dplyr::group_by(MonitoringLocationIdentifier)
  }

      pie_median %<>%
        dplyr::summarise(
          N = n(),
          median_val = round(median(ResultMeasureValue), 2))
      
      palNumeric <- colorNumeric(
        palette = "Reds",
        domain = pie_median$median_val) # Do this before filtering to site, because want same color range across all sites
            
      median_sf <- rv$sitesPointsSub %>%
        dplyr::filter(MonitoringLocationIdentifier %in% pie_median$MonitoringLocationIdentifier) %>%
        dplyr::select(MonitoringLocationIdentifier, SITELAB) %>%
        dplyr::left_join(pie_median, by = "MonitoringLocationIdentifier")
      
      if(input$sel_MapByYr == TRUE) {
        median_sf %<>%
          filter(Yr == as.numeric(input$sel_SurvYr)) %>%
        dplyr::mutate(SITEPOP = paste0("Site: ", MonitoringLocationIdentifier, "<br>Year: ", Yr, "<br># of Samples: ", N, "<br><font size ='+.5'><b>Median Value: ", median_val, "</b></font>")) # Median value show as larger bold font
      } else {
       
        median_sf %<>%
          dplyr::mutate(SITEPOP = paste0("Site: ", MonitoringLocationIdentifier, "<br># of Samples: ", N, "<br><font size ='+.5'><b>Median Value: ", median_val, "</b></font>"))
      }
      
      param_map %<>%
        addControl(tags$div(tag.map.title, HTML(input$sel_ShowCharType, " in Year ", input$sel_SurvYr)), position = "topleft", className="map-title") %>%
        addCircleMarkers(data = median_sf, label = ~SITELAB, popup = ~SITEPOP, radius = 12, fillColor = ~palNumeric(median_val), fillOpacity = 1, color = ~palNumeric(median_val), stroke = TRUE, opacity = 1, options = pathOptions(pane = "pane_param_selectedStations")) %>%
        addLegend(pal = palNumeric, values = pie_median$median_val, position = "topleft", title = input$sel_ShowCharType) %>%
        hideGroup("Imported monitoring sites") %>%
        hideGroup("Selected monitoring sites")
    }

   
    ## THRESHOLDS
      if(sel_param_map_show == "thresh") {
      shiny::validate(need(sum(!is.na(rv_param_temp$plotDat$ThreshCateg)) > 0, message = "No threshold limits defined for these data"))
        
      param_map <- FuncPieMap(pie_map = param_map, limit_type = "ThreshCateg", limit_name = "threshold categories", pie_size = 30+(10*map_point_size))
      }
        
    ## PERCENTILE
    if(sel_param_map_show == "perc") {
      shiny::validate(need(sum(!is.na(rv_param_temp$plotDat$PercCateg)) > 0, message = "No percentile limits set for these data"))
      
      param_map <- FuncPieMap(pie_map = param_map, limit_type = "PercCateg", limit_name = "percentile categories", pie_size = 30+(10*map_point_size))
    }
  }

# FINISH OFF for all map types
  param_map %<>%
    hideGroup("Selected gage stations") %>%
    hideGroup("Selected weather stations") %>%
    hideGroup("Discharge facilities") %>%
    addLayersControl(
      baseGroups = c("Street", "Satellite"),
      overlayGroups = show_layers$layer[show_layers$show == TRUE],
      options = layersControlOptions(collapsed = TRUE)) %>% # set map view at current settings or, if initial map viewing, set to initial defaults. Irritating that it blinks every time, but it seems this can't be easily addressed with leaflet (html-based) outputs
    setView(lng = switch(any(is.null(isolate(input$param_map_center$lng)), isolate(input$param_map_center$lng) == 0, isolate(input$param_map_center$lng) > st_bbox(rv[["HUC10"]])$xmax, isolate(input$param_map_center$lng) < st_bbox(rv[["HUC10"]])$xmin)+1, isolate(input$param_map_center$lng), mean(c(st_bbox(rv$sitesPointsSub)$xmin, st_bbox(rv$sitesPointsSub)$xmax))), lat = switch(any(is.null(isolate(input$param_map_center$lat)), isolate(input$param_map_center$lat) == 0, isolate(input$param_map_center$lat) > st_bbox(rv[["HUC10"]])$ymax, isolate(input$param_map_center$lat) < st_bbox(rv[["HUC10"]])$ymin)+1, isolate(input$param_map_center$lat), mean(c(st_bbox(rv$sitesPointsSub)$ymin, st_bbox(rv$sitesPointsSub)$ymax))), zoom = input$sel_ParamMapZoom) %>% 
    htmlwidgets::onRender("
      function(el, x) {
        this.on('contextmenu', function(e) {
          var clicked = null;
          // Only check layers in the specified groups
          if (this._layers) {
          Object.values(this._layers).forEach(function(layer) {console.log('Checking layer:', layer.options);
          if (layer.options && (layer.options.group === 'Imported monitoring sites'||layer.options.group ==='Selected monitoring sites') && layer.options.layerId) {
          console.log('Found matching layer with layerId:', layer.options.layerId);
              var latlng = layer.getLatLng();
              var dist = Math.sqrt(
                Math.pow(e.latlng.lat - latlng.lat, 2) +
                Math.pow(e.latlng.lng - latlng.lng, 2)
              );
              console.log('Distance:', dist);
              if (dist < 0.01) {
              clicked = layer.options.layerId;
              console.log('Clicked site:', clicked);
              }
            }
          });
          }
          if (clicked) {
            Shiny.setInputValue('param_map_right_click', {
              MonitoringLocationIdentifier: clicked,
              nonce: Math.random()
            });
          } else {
          console.log('No clicked site found');
          }
        });
      }
    ") # end of renderLeaflet
}) 

tags$style("#param_map {height: calc(100vh - 210px) !important;}") # expand map to fill screen
```

```{r ts_cards}
output$out_ts_plots <- renderPlotly({ # separate validation statements so they are checked in sequence

  FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = FALSE)
print("line5039")

  shiny::validate(
    need(!is.null(rv_param_temp$showCharTypes) & !is.null(rv_param_temp$showStations), message = "From the left sidebar, please select characteristic(s) and monitoring site(s) to plot, then click the green 'REFRESH PLOT DATA' button"))
  
  if(all(!is.null(input$sel_CombineSites), !is.null(rv_param_temp$showStations))) {
    shiny::validate(need(length(rv_param_temp$showStations) < 6 | input$sel_CombineSites == FALSE, message = "The maximum number of monitoring sites to display in a single plot is FIVE. From the left sidebar, please either UNSELECT 'Combine sites in one plot' or reduce the number of sites to display."))
  }
  
  # shiny::req(!is.null(input$sel_PlotType),!is.null(rv_param_temp$plotDat), !is.null(input$sel_SeasonalTimeUnit), !is.null(input$sel_FreeY), !is.null(input$sel_CombineSites))
  
  shiny::req(!is.null(input$sel_PlotType),!is.null(rv_param_temp$plotDat), !is.null(input$sel_SeasonalTimeUnit))

  rv_param_temp$ggplot_ts_list <- FuncPlotList(time_unit = "ActivityStartDate")

  rv_param_temp$finalPlot <- FuncPlotPage(plot_list = rv_param_temp$ggplot_ts_list, time_unit = "ActivityStartDate")
  shiny::req(!is.null(rv_param_temp$finalPlot$plotly_page))
  
  rv_param_temp$finalPlot$plotly_page
  })

unlink("Rplots.pdf")
tags$style("#out_ts_plots{height: calc(95vh - 260px) !important;}")

# I actually need these forced overflow scrollbars for when the expanded card doesn't show all the plots

output$out_season_plots <- renderPlotly({
  
    FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = FALSE)
  
  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$subDat),  !is.null(rv_param_temp$subDatTypes))

  shiny::validate(
    need(!is.null(rv_param_temp$showCharTypes) & !is.null(rv_param_temp$showStations), message = "From the left sidebar, please select characteristic(s) and monitoring site(s) to plot, then click the green 'REFRESH PLOT DATA' button"))

  if(!is.null(input$sel_CombineSites) & !is.null(rv_param_temp$showStations)) {
    shiny::validate(need(length(rv_param_temp$showStations) < 6 | input$sel_CombineSites == FALSE, message = "The maximum number of monitoring sites to display in a single plot is FIVE. From the left sidebar, please either UNSELECT 'Combine sites in one plot' or reduce the number of sites to display."))
  }
  
  # shiny::req(!is.null(input$sel_PlotType),!is.null(rv_param_temp$plotDat), !is.null(input$sel_SeasonalTimeUnit), !is.null(input$sel_FreeY), !is.null(input$sel_CombineSites))
  
  shiny::req(!is.null(input$sel_PlotType),!is.null(rv_param_temp$plotDat), !is.null(input$sel_SeasonalTimeUnit))
  
  rv_param_temp$ggplot_season_list <- FuncPlotList(time_unit = switch(is.null(input$sel_SeasonalTimeUnit)+1, input$sel_SeasonalTimeUnit, "Wk"))
  
  # # Highlight year
  # if(all(input$sel_PlotType %in% c("points", "points_smooth"), !is.null(input$sel_HighlightSurvYr), input$sel_HighlightSurvYr != "None", !is.null(rv_param_temp$plotDat), !is.null(rv_param_temp$ggplot_season_list), as.integer(input$sel_HighlightSurvYr) %in% unique(rv_param_temp$plotDat$Yr))) {
  #   rv_param_temp$ggplot_season_list[[1]] <- FuncHighlightYr(rv_param_temp$ggplot_season_list[[1]]) 
  # }
  
  rv_param_temp$seasonalPlot <- FuncPlotPage(plot_list = rv_param_temp$ggplot_season_list, time_unit = switch(is.null(input$sel_SeasonalTimeUnit)+1, input$sel_SeasonalTimeUnit, "Wk"))
    
  shiny::req(!is.null(rv_param_temp$seasonalPlot$plotly_page))
  
  rv_param_temp$seasonalPlot$plotly_page
})

unlink("Rplots.pdf")
tags$style("#out_season_plots{height: calc(95vh - 350px) !important;}")

output$out_thresh_plots <- renderPlotly({

  # FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = TRUE)

  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$subDat),  !is.null(rv_param_temp$subDatTypes), !is.null(rv_param_temp$plotDat))
shiny::req(!is.null(rv_param_temp$sel_summarize_by))

shiny::req(!is.null(rv_param_temp$sel_show_thresholds))
shiny::validate(need(!is.null(rv_param_temp$sel_show_thresholds != "showthresh_none"), "In the left sidebar, choose to define custom threshold limits or import limits from a file, then click the green 'REFRESH PLOT DATA' button"))

shiny::validate(need(length(na.omit(rv_param_temp$plotDat$ThreshCateg)) > 0, message = "No threshold limits defined for the selected characteristics"))

  threshPieDat <- FuncPieDat(limit_type = "ThreshCateg")

  shiny::validate(
    need(!is.null(threshPieDat), message = "No threshold limits defined for the selected characteristics"))
  
  thresh_plot_title <- paste0("Threshold levels by ", switch((rv_param_temp$sel_summarize_by == "by_chartype")+1, "water characteristic", "monitoring site"), " (rows) and year (cols) for ", switch((rv_param_temp$sel_summarize_by == "by_chartype")+1, unique(rv_param_temp$plotDat$MonitoringLocationIdentifier), unique(rv_param_temp$plotDat$CharSampleType)))
  
  thresh_pie <- FuncPlotlyPieMatrix(dat = threshPieDat %>% dplyr::filter(!is.na(CategVar)), discrete_cols = rv_param_temp$threshColors, discrete_levels = c("good", "caution", "poor"), plot_title = thresh_plot_title)
  })
tags$style("#out_thresh_plots{height: calc(100vh - 245px) !important;overflow-x:scroll;overflow-y:scroll}")

output$out_perc_plots <- renderPlotly({
  # FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = TRUE)
  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$subDat),  !is.null(rv_param_temp$subDatTypes), !is.null(rv_param_temp$plotDat))
  
  shiny::validate(need(length(na.omit(rv_param_temp$plotDat$PercCateg)) > 0, message = "No percentile limits defined. Make sure you have 'Add Percentile Lines to Plots' checkmarked on left sidepanel, then REFRESH PLOT DATA."))
          
  percPieDat <- FuncPieDat(limit_type = "PercCateg")
  
  shiny::validate(
    need(!is.null(percPieDat), message = "No percentile data calculated. Make sure you have 'Add Percentile Lines to Plots' checkmarked on left sidepanel."))
  shiny::req(!is.null(rv_param_temp$sel_summarize_by), !is.null(input$sel_AddQuantile))

  perc_named_colors <- c("lightgray", "#56B4E9", "orange")

  perc_named_levels <- c("below", "between", "above")

  perc_plot_title <- paste0("Percentile levels by ", switch((rv_param_temp$sel_summarize_by == "by_chartype")+1, "water characteristic", "monitoring site"), " (rows) and year (cols) for ", switch((rv_param_temp$sel_summarize_by == "by_chartype")+1, unique(rv_param_temp$plotDat$MonitoringLocationIdentifier), unique(rv_param_temp$plotDat$CharSampleType)))

  perc_pie <- FuncPlotlyPieMatrix(dat = percPieDat %>% dplyr::filter(!is.na(CategVar)), discrete_cols = perc_named_colors, discrete_levels = perc_named_levels, plot_title = perc_plot_title)
  })
tags$style("#out_perc_plots{height: calc(100vh - 245px) !important;overflow-x:scroll;overflow-y:scroll}")
```

```{r plot_summary_table}

output$table_plot_summary <- DT::renderDT({
  
  shiny::req(!is.null(rv_param_temp$sel_summarize_by), !is.null(rv_param_temp$plotDat))
  
  print("sTARTING FUNCSUMMARYSTATS")
  plotSummary <- FuncSummaryStats(dat = rv_param_temp$plotDat, plot_summarize_by = rv_param_temp$sel_summarize_by)
  
  shiny::req(!is.null(plotSummary))
  
print("CREATING DT")
  DT::datatable(
    plotSummary,
    rownames = FALSE,
    filter = "top",
    selection = "none",
    class="compact stripe",
    extensions=c('Buttons','ColReorder'),
    options = list(
          dom = 'Blrtp',
          buttons = list('csv', 'excel'),
          # lengthMenu = list(c(20,30,40,-1),
          #                 c(20,30,40,"All")),
          colReorder=TRUE,
          # pageLength = -1,
        columnDefs = list(list(className = 'dt_center', targets = "_all")),
          autoWidth = FALSE
        )
  )
  })
  
observeEvent(input$button_plotTable, {
  showModal(
    tags$div(
      id = "plot_tab",
      modalDialog(
        title = div(
          "Summary statistics for plot data",
          actionButton("dismiss_view_table", "Dismiss", class = "btn btn-danger", style = "float: right; margin-left: 10px;")
        ),
        div(
          DTOutput("table_plot_summary"),
          style = "font-size: 80%; overflow-y: auto; height: auto; max-height: none;"
        ),
        footer = NULL,
        size = "l",
        easyClose = TRUE
      ),
      # ✅ Cleaned-up styles
      tags$head(tags$style(HTML("
        #plot_tab .modal-footer { display: none; }
        #plot_tab .modal-lg {
          min-width: 90%;
          margin: 0;
          height: auto;
        }
      ")))
    )
  )
})

observeEvent(input$dismiss_view_table, {
  removeModal()
})
```
HOME
====================================== 
Spacer Column {data-width=5}
-------------------------------------

Column {data-width=750}
-------------------------------------

###

```{r}
htmltools::img(src="Images/secchi_transparent.png", width = "7%", style="position:absolute; top:20px; right:25px;")
```
<br>

#### <font size="2">**Quick-Start Instructions**</font>

* <font size="1">To import water quality data from Water Quality Portal (or load an existing .RDS file), follow the red-font instructions on the 'Get WQP Data' page.</font>

* <font size="1">Then (optionally) proceed to the 'Filter WQP Data' page to examine sample sizes and filter a subset of data to summarize on the 'Explore Data' page. Alternatively, use the default filter criteria.</font>

* <font size="1">The 'Explore Data' page presents maps, time series plots, threshold exceedence plots, and other summaries of the filtered WQP data.</font>

<br>

#### <font size="2">**About This Dashboard**</font>

<font size="1">This dashboard is an interactive tool for you to explore water quality trends in and around national park units. Use it to:</font>

* <font size="1">See what water monitoring sites, weather stations, and EPA-regulated facilities occur in and near our parks</font>

* <font size="1">Examine scatterplots, boxplots, and line graphs of water quality and precipitation data</font>

* <font size="1">Identify unusually high or low water quality measurements and examine the underlying data records</font>

* <font size="1">Use a map time slider to see how water quality patterns change over space and time</font>

<br>

#### <font size="2">**About The Data**</font>

<font size="1">Click on the links below to learn more about each data source and the data used in this dashboard:</font>

* <font size="1">[Administrative Boundaries of National Park System Units](https://irma.nps.gov/DataStore/Reference/Profile/2224545?lnv=True) (NPS) </font>

* <font size="1">[National Watershed Boundary Dataset](https://www.usgs.gov/national-hydrography/watershed-boundary-dataset) (USGS), for watershed (HUC10) and subwatershed (HUC12) boundaries</font>

* <font size="1">[Water Quality Portal](https://www.waterqualitydata.us/) (a cooperative service sponsored by the USGS, EPA, and NWQMC), for water quality data</font> 

* <font size="1">[National Climatic Data Center](https://www.ncei.noaa.gov/cdo-web/) (NOAA), for precipitation data</font>

* <font size="1">[Enforcement and Compliance History Online](https://echo.epa.gov/) (EPA), for compliance information for facilities regulated under the Clean Water Act</font>

Spacer Column {data-width=5}
-------------------------------------

Data Sources {data-width=200}
-------------------------------------
```{r images}
htmltools::img(src="Images/US-NationalParkService-Logo.svg", width = "50%",  style="display:block; margin:auto; padding:15px")
  
htmltools::img(src="Images/USGS_logo.png",width = "75%",  style="display:block; margin:auto; padding:15px")

htmltools::img(src="Images/waterquality_logo.jpg", width = "100%", style="display:block; margin:auto; padding:15px")

htmltools::img(src="Images/ncei_icon_550px.jpg", width = "81%", style="display:block; margin:auto; padding:15px")

htmltools::img(src="Images/epa-seal-large.png", width = "52%", style="display:block; margin:auto; padding:15px") # height = "25%", 
```

Spacer Column {data-width=5}
-------------------------------------

Get WQP Data
====================================== 
Inputs {.sidebar data-width=300}
-------------------------------------
```{r main_data_sidebar}  

useShinyjs(rmd = TRUE)

FuncAboutButton(nam = "button_aboutGetData")
observeEvent(eventExpr = input$button_aboutGetData, {
  browseURL(here::here("About_files", "aboutGetData.html"))})

br()

br()

# UI panel to import or load data----
wellPanel(
  id = "new_data_P0",
  p(strong("Choose data source")),
  
  br(),
  
  radioButtons("sel_GetData",
               label = NULL,
               choices = c("Load data file (.RDS) from computer"  = "existing_data",
                           "Download data from web services" = "new_data")),
  
  
  actionButton("button_beginSearch", "BEGIN DATA SEARCH", width = "100%", style="color:black; background-color: lightgreen; display:inline-block; border:1px; margin:5px")
) # end import-load-data panel


# UI panel to show WQP stations ----
shinyjs::hidden( # initially hide this well panel, show only if user wants to import data from WQP
  wellPanel(
    id = "new_data_P1",
    p(strong("1. Show monitoring sites for selected park unit and date range")),
    
    selectInput("sel_UnitCode", label = h6("Enter a park name or 4-digit park code (e.g., BITH): "), choices = c("Choose a park" = "", unique_parks_df$unit_name_combined), selectize = TRUE),
    
    numericInput("sel_ActiveWithinYrs",
                 label = h6("Limit to sites that have been sampled within the past [ENTER AN INTEGER] years: "),
                 value = 8,
                 min = 1),
    
    actionButton("button_showStations", "Show Monitoring Sites", width = "100%", style="color:black; background-color: lightgreen; display:inline-block; border:1px; margin:5px")
    ) # end show-stations panel
) # end hide for show-stations panel

conditionalPanel(
  condition = "rv_param_temp.loadMap == true", # show map zoom slider only after map data have been uploaded,
  renderUI({
    shiny::req(!is.null(rv[["HUC10"]]))
    map_zoom <- min(RgoogleMaps::MaxZoom(lonrange = c(st_bbox(rv[["HUC10"]])$xmin, st_bbox(rv[["HUC10"]])$xmax), latrange = c(st_bbox(rv[["HUC10"]])$ymin, st_bbox(rv[["HUC10"]])$ymax)))
    sliderInput("sel_MapZoom", label = h6("Set map zoom:"), min = max(1, map_zoom - 6), max = 15, value = map_zoom, step = 0.5, ticks = FALSE, dragRange = FALSE, width = "100%")
    })
)
  
# UI panel to select subset of WQP stations ----
shinyjs::hidden( # initially hide this well panel
  wellPanel(
    id = "new_data_P2",
    p(strong("2. Filter sites to download")),
    
    renderUI({
    shiny::req(!is.null(rv))
    huc_vec <- c("HUC10" = "HUC10 (watershed)", "HUC12" = "HUC12 (subwatershed)")
    huc_choice_names <- huc_vec[intersect(c("HUC10", "HUC12"), names(isolate(reactiveValuesToList(rv)) %>% purrr::discard(is.null)))]
    
    radioButtons("sel_HUClevel", label = h6("On map, display HUC level: "),
                 choiceNames = unname(huc_choice_names),
                 choiceValues = names(huc_choice_names),
                 selected = names(huc_choice_names)[1])
    }),
    
    radioButtons("sel_SelectMethod", label = h6("Select WQP monitoring sites based on: "),
                 choiceNames = c("Park (include all data collected within the park unit)", "HUCs (click on map to select)", "Distance from origin site (enter query filters below)"),
                 choiceValues = c("methodPark", "methodHuc", "methodDist"),
                 selected = "methodHuc"),
    
    renderUI({ # conditional panel if user selects from origin station
      shiny::req(!is.null(input$sel_SelectMethod))
      shiny::req(input$sel_SelectMethod == "methodDist")
      conditionalPanel(
        condition = "input.sel_SelectMethod == 'methodDist'",
        textInput("sel_OriginStationID",
                  label = "Enter an origin WQP monitoring site ID (e.g., USGS-08041745)",
                  value = ""),
        numericInput("sel_DistKmUpstream",
                     label = "How many km upstream of origin?",
                     value = 0,
                     min = 0),
        checkboxInput("sel_IncludeTribs",
                      label = "Include upstream tributaries",
                      value = FALSE),
        numericInput("sel_DistKmDownstream",
                     label = "How many km downstream of origin?",
                     value = 0,
                     min = 0),
        checkboxInput("sel_IncludeDiversions",
                      label = "Include downstream diversions",
                      value = FALSE)
      )
      }),
    
    renderUI({
      shiny::req(!is.null(rv$sitesPointsSub))
      checkboxGroupInput("sel_Organization",
                         label = h6("Import data only from these organizations: "),
                         choices = sort(unique(rv$sitesPointsSub$OrganizationFormalName)),
                         selected = unique(rv$sitesPointsSub$OrganizationFormalName)
                         )
      }),
    
        renderUI({
      shiny::req(!is.null(rv$sitesPointsSub))
      checkboxGroupInput("sel_SiteType",
             label = h6("Import data only from these water body types: "),
             choices = sort(unique(rv$sitesPointsSub$MonitoringLocationTypeName)),
             selected = unique(rv$sitesPointsSub$MonitoringLocationTypeName))
    }),
    
    checkboxGroupInput("sel_CharType",
                       label = h6("Import data only from these characteristic groups: "),
                       choices = c("Biological",
                                   "Inorganics, Major, Metals",
                                   "Inorganics, Major, Non-metals",
                                   "Microbiological",
                                   "Nutrient",
                                   "Organics, Other",
                                   "Organics, PCBs",
                                   "Organics, Pesticide",
                                   "Physical",
                                   "Sediment",
                                   "Toxicity"),
                       selected = c("Microbiological", "Nutrient", "Physical")),
    
    actionButton("button_summarizeStations", "Summarize Selected Sites", width = "100%", style="color:black; background-color: lightgreen; display:inline-block; border:1px; margin:5px")
    ) # end subset-stations panel
  ) # end hide for subset-stations panel

# UI panel to select subset of Meteo stations ----
shinyjs::hidden( # initially hide this well panel
  wellPanel(
    id = "new_data_P3",
    # p(strong("3. Filter stream gage and weather station data to download")),
    # p("Data will download only for selected gage and weather stations. When selected, these stations will show as orange-colored on the map."),
    
        p(strong("3. Filter stream gage data to download")),
    p("Data will download only for selected gage stations. When selected, these stations will show as orange-colored on the map."),
    
    renderUI({
      shiny::req(!is.null(rv$gageStations))
      checkboxGroupInput("sel_Gages",
                         label = h6("Import data only from these USGS gage stations: "),
                         choices = sort(unique(rv$gageStations$GageName)))
      }) #,
    
    # renderUI({
      # shiny::req(!is.null(rv$meteoStations))

# print("line4218")
#       checkboxGroupInput("sel_Meteo",
#                          label = h6("Import data only from these weather stations: "),
#                          choices = sort(unique(rv$meteoStations$MeteoName)))
# })
    ) # end subset-Meteo panel
  ) # end hide for subset-Meteo panel

# UI panel for finer data filter and to import the data ----
shinyjs::hidden( # initially hide this well panel
  wellPanel(
    id = "new_data_P4",
    actionButton("button_downloadData", "DOWNLOAD SELECTED DATA", width = "100%", style="color:black; background-color: lightgreen; display:inline-block; border:1px; margin:5px"),
    
    br(),
    
    renderUI({
    shiny::req(rv_param_temp$newImport == TRUE)
    
    download_button(
    outputId = "download_RDS",
    label = "   Save RDS to Computer",
    style = "width: 100%; background-color: #e97451; 
             display: inline-block; border: 1px solid black; margin: 5px;")
    })
    
    ) # end filter-import panel
  ) # end hide for filter-import panel

# Download RDS to user location ----


output$download_RDS <- downloadHandler(
  shiny::req(!is.null(rv)),
  filename = function() {
    paste0("WQdash_", rv$parkID, "_", paste0(gsub(pattern = "-", replacement = "", x = Sys.Date()), ".RDS"))
    },
    content = function(file) {
      saveRDS(isolate(reactiveValuesToList(rv)), file)
    }
  )

```

Data for Import {.tabset .tabset-fade}
-------------------------------------
<center>*NOTE:  Data collected by NPS Inventory & Monitoring are listed as 'National Park Service Water Resources Division'*</center>

### Map
```{r initial_map}
# conditionalPanel(
#   condition = "typeof output.map === null", # these conditionals are not working
  # condition = "rv_param_temp.loadMap == true", 
  htmltools::tags$div(
    style = "text-align: center; margin: 5px 0;",
    htmltools::tags$button(
      "🔄 Refresh Map", 
      onclick = "refreshMap()",
      style = "padding: 6px 12px; background: #5a9fd4; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;"
    ),
    htmltools::tags$script(htmltools::HTML("
      function refreshMap() {
        var maps = HTMLWidgets.findAll('.leaflet');
        if (maps.length > 0) {
          maps[0].getMap().invalidateSize();
        }
      }
    "))
  )
# )

output$map <- renderLeaflet({
  shiny::req(!is.null(rv_param_temp$loadMap))
  
  shiny::validate(
      need(rv_param_temp$loadMap == TRUE, message = "No data to show. From the left sidebar, please choose to load a data file or download data from web services and then click the green 'BEGIN DATA SEARCH' button"))
  
  print("RENDER INITIAL MAP AGAIN")
  
  shiny::req(!is.null(input$sel_GetData))
  if(input$sel_GetData == "new_data"){
      rv$importSettings <- list(sel_SelectMethod = input$sel_SelectMethod, sel_HUClevel = input$sel_HUClevel, sel_Organization = input$sel_Organization, sel_SiteType = input$sel_SiteType)} # make sure the map will show even if WQP data have not yet been imported
  
  shiny::req(!is.null(rv$parkID))
  
  if(any(is.null(rv$importSettings$sel_SelectMethod), is.null(rv$importSettings$sel_HUClevel), is.null(rv$importSettings$sel_Organization), is.null(rv$importSettings$sel_SiteType), is.null(rv$unitPoly), is.null(rv$HUC10), is.null(rv$sitesPointsSub), rv$parkID=="", !rv$importSettings$sel_Organization %in% rv$sitesPointsSub$OrganizationFormalName)) {
      map <- leaflet()
      } else {
        print("CALLING FUNCBASEMAP")
  
        map <- FuncBaseMap(maptype = "initial") # Base map, which will not react to user selections
        
        # Initial map controls
        print("BACK TO INITIAL MAP CONTROLS")
        map %<>%
          addLegend(title = "Data source for water quality monitoring data", pal = rv_param_temp$palOrg, values = sort(rv$importSettings$sel_Organization), group = "Map legend", position = "bottomleft") %>%
          addLayersControl(
            baseGroups = c("Street", "Satellite"),
            overlayGroups = na.omit(c("NPS unit", rv$importSettings$sel_HUClevel, "Available monitoring sites", ifelse(!is.null(rv$selectedStations), "Selected monitoring sites", NA), ifelse(!is.null(rv$facilitiesPointsSub), "Discharge facilities", NA), ifelse(!is.null(rv$gageStations), "Gage stations", NA), ifelse(!is.null(rv$meteoStations), "Weather stations", NA), "Map legend")),
            options = layersControlOptions(collapsed = TRUE)) %>%
          setView(lng = ifelse(any(is.null(isolate(input$map_center$lng)), isolate(input$map_center$lng) == 0), mean(c(st_bbox(rv[["HUC10"]])$xmin, st_bbox(rv[["HUC10"]])$xmax)), isolate(input$map_center$lng)), lat = ifelse(any(is.null(isolate(input$map_center$lat)), isolate(input$map_center$lat) == 0), mean(c(st_bbox(rv[["HUC10"]])$ymin, st_bbox(rv[["HUC10"]])$ymax)), isolate(input$map_center$lat)), zoom = input$sel_MapZoom)
        
        print("FINISHED INITIAL MAP")
      }
  map
})

leafletOutput("map", width = "100%")
  
  # User selects HUCs by clicking (when new data imported) ----
observeEvent(input$map_shape_click, {
  shiny::req(rv$importSettings$sel_SelectMethod=="methodHuc", !is.null(rv), !is.null(rv$importSettings$sel_HUClevel), !is.null(input$sel_GetData))
  shiny::req(input$sel_GetData=="new_data")
    click <- input$map_shape_click

      if(click$id %in% rv$selectedHucs) { # check if the click is in a selected HUC
          rv$selectedHucs <- rv$selectedHucs[rv$selectedHucs != click$id] # then remove it from the list of selected HUCs
      leafletProxy("map") %>% addPolygons(data = rv[[rv$importSettings$sel_HUClevel]][rv[[rv$importSettings$sel_HUClevel]]$HUC==click$id,], group = rv$importSettings$sel_HUClevel, color = "blue", fillColor = "lightblue", fillOpacity = 0.4, weight = 0.5, layerId = ~HUC, options = pathOptions(pane = "pane_HUC")) # and change the polygon to unselected color
      } else { # if the click is in an unselected HUC
        rv$selectedHucs <- c(rv$selectedHucs, click$id) # append the ID of clicked HUC polygon
        leafletProxy("map") %>% addPolygons(data = rv[[rv$importSettings$sel_HUClevel]][rv[[rv$importSettings$sel_HUClevel]]$HUC==click$id,], group = rv$importSettings$sel_HUClevel, color = "blue", fillColor = "lightblue", fillOpacity = 0.8, opacity = 1, weight = 1.5, layerId = ~HUC, options = pathOptions(pane = "pane_HUC"))
      } # and change the polygon to selected color
  }, ignoreInit = TRUE) # end of observeEvent
```

### Summary of Selected Data

```{r}
output$table_import_summary <- DT::renderDT({
    shiny::validate(
    need(!is.null(rv$selectedDataSummary), message = "No data selected. Follow prompts on the left to select data for import, then click the click <strong>'Summarize Selected Sites'</strong> button."))

  DT::datatable(
    rv$selectedDataSummary %>%
      dplyr::group_by(OrganizationFormalName, MonitoringLocationIdentifier, MonitoringLocationTypeName, CharacteristicType, CharacteristicName) %>%
      dplyr::summarize(`First Yr` = min(YearSummarized, na.rm = TRUE), `Most Recent Yr` = max(YearSummarized, na.rm = TRUE), `# of Records` = sum(ResultCount, na.rm = TRUE), .groups = "drop") %>%
      dplyr::rename(Organization = OrganizationFormalName, Site = MonitoringLocationIdentifier, `Site Type` = MonitoringLocationTypeName, `Characteristic Type` = CharacteristicType, Characteristic = CharacteristicName),
    rownames = FALSE,
    filter = "top",
    selection = "none",
    class="compact stripe",
    extensions=c('Buttons','ColReorder'),
    options = list(
          # Modified dom structure: B = buttons, l = length menu, p = pagination, r = processing, t = table
          dom = '<"top"<"left"Bl><"right"pi>>rt',
          buttons = list('csv', 'excel'),
          lengthMenu = list(c(15,30,40,-1),
                          c(15,30,40,"All")),
          colReorder=TRUE,
          autoWidth = FALSE,
          columnDefs = list(list(className = 'dt_center', targets = "_all"))
        )
  ) %>%
  DT::formatStyle(columns = c(1:8), width = "auto")
  })

DTOutput("table_import_summary")
```

### Summary of Selected Characteristics

```{r}
output$table_char_summary <- DT::renderDT({
  shiny::validate(
    need(!is.null(rv$selectedDataSummary), message = "No data selected. Follow prompts on the left to select data for import, then click the click <strong>'Summarize Selected Sites'</strong> button."))

  shiny::req(!is.null(rv$selectedDataSummary))

  DT::datatable(
    rv$selectedDataSummary %>% dplyr::group_by(CharacteristicType, CharacteristicName) %>% dplyr::rename(`Characteristic Type` = CharacteristicType, `Characteristic Name` = CharacteristicName) %>% dplyr::summarize(`# of Records` = sum(ResultCount, na.rm = TRUE), .groups = "drop"),
    rownames = FALSE,
    filter = "top",
    selection = "none",
    class="compact stripe",
    extensions=c('Buttons','ColReorder'),
options = list(
          dom = '<"top"<"left"Bl><"right"pi>>rt',
          buttons = list('csv', 'excel'),
          lengthMenu = list(c(15,30,40,-1),
                          c(15,30,40,"All")),
          colReorder=TRUE,
          autoWidth = FALSE,
          columnDefs = list(list(className = 'dt_center', targets = "_all"))
        )
  ) %>%
  DT::formatStyle(columns = c(1:3), width = "auto")
  })

DTOutput("table_char_summary")
```

### Summary of Imported Data, by Site

```{r summarize_locations}
output$table_selected_orgs <- renderReactable({
  shiny::validate(
  need(!is.null(rv$dat), message = "No data available. Please first import or load water quality data.")) # can't call FuncOrderCheck from in here
  shiny::req(!is.null(rv$dat), !is.null(rv$sitesPointsSub), !is.null(rv$importSettings$sel_Organization))
      print("Line4336")
  df_site <- rv$sitesPointsSub %>%
    dplyr::filter(MonitoringLocationIdentifier %in% rv$selectedStations$MonitoringLocationIdentifier & OrganizationFormalName %in% rv$importSettings$sel_Organization) %>%
    dplyr::mutate(Longitude = sf::st_coordinates(.)[,1],
                Latitude = sf::st_coordinates(.)[,2]) %>%
        sf::st_drop_geometry() %>%
    dplyr::select(OrganizationFormalName, MonitoringLocationIdentifier, MonitoringLocationName, MonitoringLocationTypeName, Latitude, Longitude) %>%
    dplyr::inner_join(rv$dat %>% dplyr::select(MonitoringLocationIdentifier, MeteoYr, CharacteristicName), by = "MonitoringLocationIdentifier") %>%
    dplyr::distinct() %>%
    dplyr::group_by(across(c(-MeteoYr, -CharacteristicName))) %>%
    dplyr::mutate(SiteStartYr = min(MeteoYr, na.rm = TRUE),
           SiteEndYr = max(MeteoYr, na.rm = TRUE),
           TotalSurveyYrs = dplyr::n_distinct(MeteoYr)) %>%
    dplyr::group_by(across(c(-MeteoYr))) %>%
    dplyr::mutate(PercParamYrs = n()/TotalSurveyYrs) %>%
    dplyr::filter(PercParamYrs >=.8) %>% # only keep parameters that were surveyed in at least 80% of years the site was surveyed
    dplyr::select(-MeteoYr, -PercParamYrs) %>%
    dplyr::distinct() %>%
    dplyr::arrange(CharacteristicName) %>%
    dplyr::group_by(across(c(-CharacteristicName))) %>%
    dplyr::summarise(across(everything(), ~paste(na.omit(.), collapse = " // "))) %>% # for each site, the characteristics surveyed in at least 80% of survey years
    dplyr::rename(TopCharacteristics = CharacteristicName)

  df_site$TopCharacteristics[df_site$TotalSurveyYrs < 3] <- NA # if a site was surveyed less than 3 years, TopCharacteristics is NA (otherwise can get, e.g., huge list of characteristics surveyed only once because site surveyed only once)
  print("Line4360")
    df_org <- rv$orgs %>% # alternatively, these column calculations can all be done within reactable()
      dplyr::filter(OrganizationFormalName %in% rv$importSettings$sel_Organization) %>%
      dplyr::select(-Selected) %>%
      left_join(df_site %>% ungroup() %>% dplyr::select(OrganizationFormalName, TotalSurveyYrs), by = "OrganizationFormalName") %>%
      dplyr::add_count(OrganizationFormalName) %>%
      dplyr::rename(NumSites = n) %>%
      dplyr::group_by(across(c(-TotalSurveyYrs))) %>%
      dplyr::mutate(MinYrsSiteSurveyed = min(TotalSurveyYrs, na.rm = TRUE),
                    MedianYrsSiteSurveyed = median(TotalSurveyYrs, na.rm = TRUE),
                    MaxYrsSiteSurveyed = max(TotalSurveyYrs, na.rm = TRUE)) %>%
      dplyr::select(-TotalSurveyYrs) %>%
      dplyr::distinct() %>%
      arrange(OrganizationFormalName)

  reactable(
    df_org,
    columns = list(
      OrganizationFormalName = colDef(name = "Organization", minWidth = 200),
      Description = colDef(show = FALSE),
      Phone = colDef(minWidth = 170),
      NumSites = colDef(header = with_tooltip("# of Sites", "# of sites with data imported (based on user-defined import filters)"), width = 100, align = "center"),
      MinYrsSiteSurveyed = colDef(header = with_tooltip("Min", "Minimum # of years surveyed at a site"), width = 70, align = "center"),
      MedianYrsSiteSurveyed = colDef(header = with_tooltip("Median", "Median # of years surveyed at a site (50% of sites have been surveyed for longer)"), width = 75, align = "center"),
      MaxYrsSiteSurveyed = colDef(header = with_tooltip("Max", "Maximum # of years surveyed at a site"), width = 70, align = "center")
      ),
    columnGroups = list(
      colGroup(name = "# of Years Surveyed", columns = c("MinYrsSiteSurveyed", "MedianYrsSiteSurveyed", "MaxYrsSiteSurveyed"))
      ),
    details = function(index) {
      site_info <- df_site[df_site$OrganizationFormalName == df_org$OrganizationFormalName[index], ]
      htmltools::div(style = "padding: 50px",
                     reactable(site_info,
                               columns = list(
                                 OrganizationFormalName = colDef(show = FALSE),
                                 MonitoringLocationIdentifier = colDef(name = "Site ID", minWidth = 110),
                                 MonitoringLocationName = colDef(name = "Site", minWidth = 140),
                                 MonitoringLocationTypeName = colDef(name = "Type", width = 110, align = "center"),
                                 Latitude = colDef(show = FALSE),
                                 Longitude = colDef(show = FALSE),
                                 SiteStartYr = colDef(name = "Start", width = 85, align = "center"),
                                 SiteEndYr = colDef(name = "End", width = 85, align = "center"),
                                 TotalSurveyYrs = colDef(
                                   header = with_tooltip("# of Years Site Surveyed", "Full (gray) bar length is maximum # of years among all (imported) sites surveyed by the organization, red bar length is # of years this site surveyed (a site may not be surveyed every year)"),
                                   align = "center",
                                   width = 150,
                                   cell = function(value) {
                                     width <- paste0(value * 100 / max(site_info$TotalSurveyYrs), "%")
                                     bar_chart(value, width = width, fill = "#fc5185", background = "#e1e1e1")
                                     }),
                                 TopCharacteristics = colDef(
                                   header = with_tooltip("Top Characteristics Surveyed", "These characteristics were surveyed in at least 80% of site's survey years. If site has been surveyed less than 3 years, then characteristics are not listed"),
                                   minWidth = 250)
                               ),
                               columnGroups = list(
                                 colGroup(name = "Calendar Years Surveyed", columns = c("SiteStartYr", "SiteEndYr"))),
                               defaultSorted = list(TotalSurveyYrs = "desc"),
                               defaultExpanded = TRUE, # <<<<<<<<<<<<<<< ADDED THIS
                               resizable = TRUE,
                               filterable = TRUE,
                               striped = FALSE,
                               highlight = TRUE,
                               showSortIcon = TRUE,
                               compact = TRUE,
                               pagination = FALSE,
                               outlined = FALSE,
                               bordered = FALSE,
                               theme = reactableTheme(backgroundColor = "hsl(186, 56%, 94%)")
                               )
      )
    },
    resizable = TRUE,
    filterable = FALSE,
    striped = FALSE,
    highlight = TRUE,
    showSortIcon = TRUE,
    compact = FALSE,
    bordered = TRUE,
    defaultExpanded = TRUE, 
    # showPageSizeOptions = TRUE,
    onClick = "select")
})

reactableOutput("table_selected_orgs")
# tags$style("#table_selected_orgs{height:100vh;overflow-x:scroll;overflow-y:scroll}")
```

Filter WQP Data
======================================

Inputs {.sidebar data-width=320}
-------------------------------------

```{r define_filter_sidebar}
FuncAboutButton(nam = "button_aboutFilterData")
observeEvent(eventExpr = input$button_aboutFilterData, {
  browseURL(here::here("About_files", "aboutFilterData.html"))})

br()

br()

wellPanel(
    id = "wp_define_categ",
    p(strong("Define categorical data")),
    
    actionButton("button_defineCategs", "Define Categorical Characters", 
             style = "color: black; background-color: lightblue; border: 1px solid black;width:100%;")
) # end of 'wp_filter_`threshfile`'

  wellPanel(
    id = "wp_filter_yr_season",
    p(strong("Filter data to summarize")),
  
  actionButton("button_refreshFilter", "REFRESH FILTER", style="border-color:black; background-color: lightgreen; width:100%; border:0px; margin:0px"), # filters data
        
    renderUI({
      shiny::req(!is.null(rv$dat$MeteoYr), !is.null(rv_param_temp$defaultInputs$sel_YrRange))
      sliderInput("sel_YrRange",
                  label = h6("Select range of years to summarize:"),
                  min = min(rv$dat$MeteoYr, na.rm = TRUE),
                  max = max(rv$dat$MeteoYr, na.rm = TRUE), 
                  step = 1, 
                  sep="", 
                  value = rv_param_temp$defaultInputs$sel_YrRange,
                  dragRange = TRUE, 
                  width = "100%")
      }),
    
    renderUI({
      shiny::req(!is.null(rv_param_temp$defaultInputs$sel_MinYrs))
      numericInput("sel_MinYrs",
                 h6("Only show site-characteristic combinations with number of survey years at least: "), 
                 min = 0, 
                 step = 1, 
                 value = rv_param_temp$defaultInputs$sel_MinYrs)
    }),
    
        renderUI({
          shiny::req(!is.null(rv_param_temp$defaultInputs$sel_DefineSeasons))
      radioButtons("sel_DefineSeasons",
                 label = h6("Define seasons as: "),
                 choiceNames = c("Meteorological seasons (calendar year)", "USGS water year seasons (starts Oct. 1)", "Custom seasons (up to 4)"),
                 choiceValues = c("MeteoSeasons", "WaterSeasons", "CustomSeasons"),
                 selected = switch(is.null(input$sel_DefineSeasons)+1, input$sel_DefineSeasons, rv_param_temp$defaultInputs$sel_DefineSeasons))
      }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons")
      
      sliderInput("sel_SeasonsStart", 
                  label = "Starting day for season LEVEL 1:", 
                  min = as.Date("2018-01-01"), # avoid leap year
                  max = as.Date("2018-12-31"), 
                  value = switch(is.null(input$sel_SeasonsStart)+1, input$sel_SeasonsStart, as.Date("2018-01-01")), 
                  timeFormat = "%b-%d")
      }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", !is.null(input$sel_SeasonsStart))
      textInput("sel_Season1Name",
                label = "LEVEL 1 name:",
                value = "CustomSeason1",
                placeholder = "E.g., Wet Season")
    }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", !is.null(input$sel_SeasonsStart))
      sliderInput("sel_Season1Range",
                  label = "LEVEL 1 cutoff (end):",
                  min = input$sel_SeasonsStart, 
                  max = input$sel_SeasonsStart + 364,
                  step = 1,
                  value = c(input$sel_SeasonsStart, input$sel_SeasonsStart + 364), 
                  timeFormat = "%b-%d")
    }),
  
  # br(),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons), !is.null(input$sel_SeasonsStart), !is.null(input$sel_Season1Range[2]))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", input$sel_Season1Range[2] < (input$sel_SeasonsStart + 364))
      br()
      textInput("sel_Season2Name",
                label = "LEVEL 2 name:",
                placeholder = "E.g., Wet Season")
    }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons), !is.null(input$sel_SeasonsStart), !is.null(input$sel_Season1Range[2]))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", input$sel_Season1Range[2] < (input$sel_SeasonsStart + 364))
      sliderInput("sel_Season2Range",
                  label = "LEVEL 2 cutoff (end):",
                  min = input$sel_SeasonsStart, 
                  max = input$sel_SeasonsStart + 364,
                  step = 1,
                  value = c(input$sel_Season1Range[2] + 1, input$sel_SeasonsStart + 364), 
                  timeFormat = "%b-%d")
    }),
  
  # br(),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons), !is.null(input$sel_SeasonsStart), !is.null(input$sel_Season2Range[2]))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", input$sel_Season2Range[2] < (input$sel_SeasonsStart + 364))
      br()
      textInput("sel_Season3Name",
                label = "LEVEL 3 name:",
                placeholder = "E.g., Wet Season")
    }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons), !is.null(input$sel_SeasonsStart), !is.null(input$sel_Season2Range[2]))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", input$sel_Season2Range[2] < (input$sel_SeasonsStart + 364))
      sliderInput("sel_Season3Range",
                  label = "LEVEL 3 cutoff (end):",
                  min = input$sel_SeasonsStart, 
                  max = input$sel_SeasonsStart + 364,
                  step = 1,
                  value = c(input$sel_Season2Range[2] + 1, input$sel_SeasonsStart + 364), 
                  timeFormat = "%b-%d")
    }),
  
  # br(),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons), !is.null(input$sel_SeasonsStart), !is.null(input$sel_Season3Range[2]))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", input$sel_Season3Range[2] < (input$sel_SeasonsStart + 364))
      br()
      textInput("sel_Season4Name",
                label = "LEVEL 4 name:",
                placeholder = "E.g., Wet Season")
    }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons), !is.null(input$sel_SeasonsStart), !is.null(input$sel_Season3Range[2]))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", input$sel_Season3Range[2] < (input$sel_SeasonsStart + 364))
      sliderInput("sel_Season4Range",
                  label = "LEVEL 4 cutoff (end):",
                  min = input$sel_SeasonsStart, 
                  max = input$sel_SeasonsStart + 364, 
                  step = 1,
                  value = c(input$sel_Season3Range[2] + 1, input$sel_SeasonsStart + 364), 
                  timeFormat = "%b-%d")
    })
)  # end of 'wp_filter_yr_season'

  wellPanel(
    id = "wp_filter_org",
    
    renderUI({
      shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$defaultInputs$sel_SummaryOrg))
      checkboxGroupInput("sel_SummaryOrg",
                         label = h6("Include data from these organizations: "),
                         choices = sort(unique(rv$dat$OrganizationFormalName)),
                         selected = switch(is.null(input$sel_SummaryOrg)+1, input$sel_SummaryOrg, rv_param_temp$defaultInputs$sel_SummaryOrg))
    })
    )
  
# shinyjs::hidden( # initially hide this well panel
  wellPanel(
    id = "wp_filter_wqchar",

    renderUI({
      shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$defaultInputs$sel_NPSparam))

      checkboxInput("sel_NPSparam",
                    "Only show characteristics reported by NPS for the imported monitoring sites",
                    value = rv_param_temp$defaultInputs$sel_NPSparam)
    }),
    
    renderUI({
      shiny::req(!is.null(rv$dat), !is.null(input$sel_NPSparam), !is.null(input$sel_YrRange), !is.null(input$sel_SummaryOrg), !is.null(input$sel_ActivityType), !is.null(input$sel_ResultStatus), !is.null(input$sel_MinYrs))
      
      rv_param_temp$selectCharSampleType <- FuncFilterSelectCharSampleType(
    sel_NPSparam = input$sel_NPSparam, 
    sel_YrRange = input$sel_YrRange, 
    sel_SummaryOrg = input$sel_SummaryOrg, 
    sel_ActivityType = input$sel_ActivityType, 
    sel_ResultStatus = input$sel_ResultStatus, 
    sel_MinYrs = input$sel_MinYrs)  

      checkboxGroupInput("sel_SummaryParam",
                         label = h6("Water quality characteristic types to summarize: "),
                         choices = sort(rv_param_temp$selectCharSampleType),
                         selected = rv_param_temp$currentInputs$sel_SummaryParam
                         # selected = switch(all(is.null(input$sel_SummaryParam), !identical(input$sel_SummaryParam, character(0)))+1, input$sel_SummaryParam, rv_param_temp$selectCharSampleType[rv_param_temp$selectCharSampleType %in% c("Dissolved oxygen (DO)", "Escherichia coli", "Flow, severity (choice list)", "Flow, stream stage (choice list)", "Nitrate + Nitrite", "pH", "Specific conductance", "Temperature, water", "Total Phosphorus, mixed forms", "Turbidity")])
                         # selected = switch(is.null(input$sel_SummaryParam)+1, input$sel_SummaryParam, init_match)
      )
    }),

renderUI({
  shiny::req(!is.null(rv_param_temp$selectCharSampleType))

      FuncAllNoneButtons(cond = "input.sel_SummaryParam", name_all = "button_allSummaryParam", name_none = "button_noSummaryParam")
})
)
# ) # end of 'wp_filter_wqchar'

# Filter data by sampling characteristics
  wellPanel(
    id = "wp_filter_sampling_chars",
    
    renderUI({
      shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$defaultInputs$sel_ActivityType))
      checkboxGroupInput("sel_ActivityType",
                         label = h6("Include these activity types: "),
                         choices = sort(unique(rv$dat$ActivityTypeCode)),
                         # selected = sort(intersect(unique(rv$dat$ActivityTypeCode), c("Field Msr/Obs", "Field Msr/Obs-Portable Data Logger",  "Sample", "Sample-Routine"))))
                         selected = rv_param_temp$defaultInputs$sel_ActivityType)
      }),
    
    renderUI({
      shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$defaultInputs$sel_ResultStatus))
      checkboxGroupInput("sel_ResultStatus",
                         label = h6("Include these result statuses: "),
                         choices = sort(unique(rv$dat$ResultStatusIdentifier)),
                         selected = rv_param_temp$defaultInputs$sel_ResultStatus)
      })
  )


br()
```


Define & Filter Data {.tabset .tabset-fade}
-------------------------------------
### Filtered Data Summary

#### <font size="1.25">**Sites and survey years by parameter, for filtered data**</font>

* <font size="0.75"> The full list of characteristics for the filtered data are shown under 'Water quality characteristics to summarize', in the left sidebar. Only 'checked' characteristics are shown in this table.</font> 

* <font size="0.75"> The filtered data shown here will be used on the Explore Filtered Data page.</font>

* <font size="0.75"> Years and seasons are defined by the user as meteorological seasons (calendar year), USGS water year seasons (starts Oct. 1), or custom-defined seasons (see 'Define seasons as:' in left sidebar). These year and season definitions will be used on all subsequent pages of the dashboard.</font>

```{r filter_summary}
output$table_filtered_chars <- renderReactable({
  shiny::validate(
     need(!is.null(rv$dat), message = "No data available. Please use the 'Get WQP Data' tab to first import or load water quality data."))
  shiny::validate(
    need(!is.null(rv_param_temp$subDat) & !is.null(rv_param_temp$subDatTypes), message = "From the left sidebar, select new filter criteria (or use default settings) and then click the green 'REFRESH FILTER' button"))
  
    shiny::req(!is.null(rv_param_temp$subDatTypes), !is.null(rv_param_temp$subDatYears))
    
    df_char <- rv_param_temp$subDatTypes %>%
      dplyr::left_join(rv_param_temp$subDatYears %>% ungroup() %>% dplyr::select(CharSampleType, TotalSurveyYrs), by = "CharSampleType") %>%
  dplyr::add_count(CharSampleType) %>%
  dplyr::rename(NumSites = n) %>%
  dplyr::group_by(across(c(-TotalSurveyYrs))) %>%
  dplyr::mutate(MinYrsSiteSurveyed = min(TotalSurveyYrs, na.rm = TRUE),
                MedianYrsSiteSurveyed = median(TotalSurveyYrs, na.rm = TRUE),
                MaxYrsSiteSurveyed = max(TotalSurveyYrs, na.rm = TRUE)) %>%
  dplyr::select(-TotalSurveyYrs) %>%
  dplyr::distinct() %>%
  arrange(CharSampleType)
                
  reactable(
    df_char,
    columns = list(
      CharacteristicName = colDef(show = FALSE),
      CharSampleType = colDef(header = with_tooltip("Characteristic Type", "Water quality parameter, with sample fraction (e.g., total or dissolved, if applicable) and measurement unit (e.g., mg/L) in parentheses"), width = 200, align = "left"),
      DataType = colDef(header = with_tooltip("Data Type", "The characteristic is classified as 'categorical' if any entry is non-numeric (excluding missing data)"), width = 100, align = "center"),
      NonNumericEntries = colDef(header = with_tooltip("Non-Numeric Entries", "Lists all non-numeric entries for a characteristic classified as 'categorical'. Includes entries with mathematical symbols, e.g., '< 2.5', because these cannot be interpreted as a number (if these values are detection thresholds, the Water Quality Portal defines an appropriate way for such data to be entered, so they can be used in analyses)"), width = 200),
      NumSites = colDef(header = with_tooltip("# of Sites", "# of sites with data imported (based on user-defined import filters)"), width = 100, align = "center"),
    MinYrsSiteSurveyed = colDef(header = with_tooltip("Min", "Minimum # of years surveyed at a site"), width = 70, align = "center"),
    MedianYrsSiteSurveyed = colDef(header = with_tooltip("Median", "Median # of years surveyed at a site (50% of sites have been surveyed for longer)"), width = 75, align = "center"),
    MaxYrsSiteSurveyed = colDef(header = with_tooltip("Max", "Maximum # of years surveyed at a site"), width = 70, align = "center"),
      NumRecords = colDef(header = with_tooltip("# of Records", "Total number of data records for this characteristic"), width = 80, align = "center")
    ),
    columnGroups = list(
    colGroup(name = paste0("# of ", rv_param_temp$seasonType, " Surveyed"), columns = c("MinYrsSiteSurveyed", "MedianYrsSiteSurveyed", "MaxYrsSiteSurveyed"))
  ),
    details = function(index) {
      site_info <- rv_param_temp$subDatYears[rv_param_temp$subDatYears$CharSampleType == df_char$CharSampleType[index], ]
      htmltools::div(style = "padding: 20px",
                     reactable(site_info,
                               columns = list(
                                 CharacteristicName = colDef(show = FALSE),
                                 CharSampleType = colDef(show = FALSE),
                                 MonitoringLocationIdentifier = colDef(name = "Site ID"),
                                 StartYr = colDef(name = "Start", width = 90, align = "center"),
                               EndYr = colDef(name = "End", width = 90, align = "center"),
                               TotalSurveyYrs = colDef(
                                 header = with_tooltip("# of Years Site Surveyed", "Full (gray) bar length is maximum # of years among all (filtered) sites that data have been collected on this characteristic, red bar length is # of years this site  has collected data on this characteristic"),
                                 width = 150,
                                 cell = function(value) {
                                   width <- paste0(value * 100 / max(site_info$TotalSurveyYrs), "%")
                                   bar_chart(value, width = width, fill = "#fc5185", background = "#e1e1e1")
                                 }),
                               NumRecords = colDef(name = "# of Records", width = 80, align = "center")),
                               columnGroups = list(
                               colGroup(name = paste0(rv_param_temp$seasonType, " Surveyed"), columns = c("StartYr", "EndYr"))),
                               defaultSorted = list(TotalSurveyYrs = "desc"),
                     resizable = TRUE,
                     filterable = TRUE,
                     striped = FALSE,
                     highlight = TRUE,
                     showSortIcon = TRUE,
                     compact = TRUE,
                     pagination = FALSE,
                     outlined = FALSE,
                     bordered = FALSE,
                     theme = reactableTheme(backgroundColor = "hsl(186, 56%, 94%)")
      )
  )
      },
  defaultSorted = list(CharacteristicName = "asc"),
    resizable = TRUE, 
    filterable = FALSE,
    striped = FALSE,
    highlight = TRUE,
    showSortIcon = TRUE,
    compact = FALSE,
    bordered = TRUE,
    showPageSizeOptions = TRUE,
  defaultPageSize = 50)

  })
reactableOutput("table_filtered_chars")


```

### Sample Size Matrix

####

```{r sample_size_input}

renderUI({
      shiny::req(!is.null(rv_param_temp$subDat))
      awesomeRadio("sel_TimeSubunit",
               label = strong("Time unit for 'Sample Size Matrix'"),
               choices = c("Month" = "Mnth", "Season" = "Season"),
               selected = switch(is.null(input$sel_TimeSubunit)+1, input$sel_TimeSubunit, "Season"))
    })

renderUI({
  shiny::req(!is.null(rv_param_temp$subDat))
  
  char_choices <- sort(unique(rv_param_temp$subDat$CharSampleType))

  shinyWidgets::radioGroupButtons("sel_SampleSizeCharType",
              label = strong("Select a characteristic type to display:"),
              choices = char_choices,
              selected = char_choices[1],
              individual = TRUE,
              status = "primary",
              size = "xs"
              )
})
```

####

```{r sample_sizes}
output$out_SamplePlots <- renderPlot({ 
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_TimeSubunit), !is.null(input$sel_SampleSizeCharType))
  
  withProgress(message = "Generating plots", detail = "...calculating sample sizes", value = 0, {
  # Create sample size matrix for the selected char, but use a consistent color legend across all chars
  
          N_dat <- rv_param_temp$subDat %>%
            dplyr::rename(TimeUnit = input$sel_TimeSubunit) %>%

            dplyr::group_by(CharSampleType, MonitoringLocationIdentifier, TimeUnit, Yr) %>%
            dplyr::summarise(FillCol = n()) %>%
            dplyr::ungroup()
          
          legend_range <- range(N_dat$FillCol, na.rm = FALSE) # make sure all plots use same legend range
          
          N_dat %<>% 
            dplyr::filter(CharSampleType == input$sel_SampleSizeCharType)
          
          # Fill missing values
          heatmap_dat <- merge(
            N_dat %>%
              dplyr::select(CharSampleType, MonitoringLocationIdentifier) %>%
    dplyr::distinct(), expand_grid(TimeUnit = levels(N_dat$TimeUnit), Yr = min(N_dat$Yr, na.rm = TRUE):max(N_dat$Yr, na.rm = TRUE))) %>%
            left_join(N_dat, by = c("CharSampleType", "MonitoringLocationIdentifier", "TimeUnit", "Yr")) %>%
            dplyr::mutate(TimeUnit = factor(TimeUnit, levels = levels(rv_param_temp$subDat[[input$sel_TimeSubunit]]))) %>%
            dplyr::arrange(CharSampleType, MonitoringLocationIdentifier, TimeUnit, Yr)
          shiny::req(!is.null(heatmap_dat)) 

          suppressWarnings(rv_param_temp$filterNPlot <- FuncPlotHeatMap(dat = heatmap_dat, y_name = input$sel_TimeSubunit,  legend_range = legend_range, legend_name = "# of Survey Events"))
          
  })
          suppressWarnings(rv_param_temp$filterNPlot)
  },
  height = reactive({suppressWarnings(switch(is.null(rv_param_temp$filterNPlot)+1, 250+30*nrow(rv_param_temp$subDat %>% dplyr::filter(CharSampleType == input$sel_SampleSizeCharType) %>% dplyr::select(CharSampleType, MonitoringLocationIdentifier) %>% dplyr::distinct())*(1+length(levels(rv_param_temp$subDat[[input$sel_TimeSubunit]]))), 400))}),
                    width = reactive({suppressWarnings(switch(is.null(rv_param_temp$filterNPlot)+1, max(800, 25*(max(subset(rv_param_temp$subDat, CharSampleType == input$sel_SampleSizeCharType)$Yr, na.rm = TRUE)-min(subset(rv_param_temp$subDat, CharSampleType == input$sel_SampleSizeCharType)$Yr, na.rm = TRUE)+1)+100), 800))})
)

plotOutput("out_SamplePlots", height="85%", width = "100%")
# tags$style("#out_SamplePlots{height:100vh;overflow-x:scroll;overflow-y:scroll}")
```

```{r define_categ, echo = FALSE}
### Define Categorical Characters----
# This is a pop-up table that shows only when the button is clicked
observeEvent(input$button_defineCategs, {
showModal(modalDialog(
  title = "Define Categorical Characters",
  useShinyjs(rmd = TRUE),
  fluidRow(
    # Leftside Panel to select a categorical characteristic
    column(3, style = "height: 100%;",
      strong("File for defining categorical data"),
      radioButtons("sel_GetCategFile",
                   label = h6("Method for generating file:"),
                   choices = c("Attach file from computer" = "existing_data",
                               "Follow steps to create a file" = "new_data"),
                   selected = "new_data"),
      actionButton("button_getCategFile", "Create Definitions File",
                   width = "100%",
                   style="color:black; background-color: lightgreen; display:inline-block; border:1px; margin:5px"),
      br(), br(),
      shinyjs::hidden(
        wellPanel(
          id = "create_categfile_P1",
          p(strong("1. Identify a categorical characteristic")),
            renderUI({
    shiny::req(!is.null(rv_param_temp$subDatTypes))
    shiny::req(input$sel_GetCategFile == "new_data")
    conditionalPanel(
      condition = "input.sel_GetCategFile == 'new_data'",

      selectInput("sel_CategParam",
                  label = "",
                  choices = rv_param_temp$subDatTypes$CharSampleType[rv_param_temp$subDatTypes$DataType == "categorical"],
                  selected = switch(is.null(input$sel_CategParam)+1, input$sel_CategParam, rv_param_temp$subDatTypes$CharSampleType[rv_param_temp$subDatTypes$DataType == "categorical"][1]))
      )
    })
  ) # end create_categfile_P1
), # end hidden
# Leftside Panel to set categorical levels (and, if applicable, their order)
      shinyjs::hidden(
        wellPanel(
          id = "create_categfile_P2",
          p(strong("2. Specify category levels")),
         renderUI({
           shiny::req(!is.null(input$sel_GetCategFile), !is.null(input$sel_CategParam))

              rv_param_temp$categLevels <- rv$dat %>% dplyr::filter(CharSampleType == input$sel_CategParam, !is.na(ResultMeasureValue)) %>% dplyr::select(ResultMeasureValue) %>% dplyr::mutate(ResultMeasureValue = toupper(ResultMeasureValue)) %>% distinct() %>% arrange() # can't just assign a vector to a reactive value initially assigned as NULL because it's expecting a dataframe or a single variable

              shiny::req(input$sel_GetCategFile == "new_data")
           conditionalPanel(
             condition = "input.sel_GetCategFile == 'new_data'",
div(style = "display: flex; gap: 6px;",
             actionButton("button_addCategLevel", "Add a Level",
             style = "font-size: 10pt; padding: 4px 8px;"), # user can add a category level that is not present in the data
             actionButton("button_deleteCategLevel", "Delete a Level",
             style = "font-size: 10pt; padding: 4px 8px;"), # user can set category levels to NA)
),

             renderUI({rank_list( # wrap in renderUI to update when user adds or deletes a level
               text = "List of category levels (drag to rearrange order)",
               labels = rv_param_temp$categLevels$ResultMeasureValue,
               input_id = "categ_ranked") # this is the ID for the ranked category vector
             })
           )
         })
) # end create_categfile_P2
) # end hidden
    ), # end column 1

    # Middle Panel to assign colors to category levels
    column(4, style = "height: 100%;",
      shinyjs::hidden(
        wellPanel(
          id = "create_categfile_P3",
          p(strong("3. Assign colors to category levels")),
          actionButton("button_showPalettes", "Show Color Palettes",
             style = "font-size: 10pt; padding: 4px 8px;", width = "100%"),
          shinyjs::hidden(
  div(id = "palette_popup",
      wellPanel(
        p(strong("Available Color Palettes")),
        plotOutput("palette_plot", height = "600px"),
        div(style = "text-align: center;",
            actionButton("close_palette_popup", "Close Palette Viewer",
                         style = "margin-top: 10px; font-size: 10pt; padding: 4px 8px;")
        )
      )
  )
),
br(),
          selectizeInput("sel_CategPalette",
                         label = h6("Select a color palette to apply"),
                         choices = c("YlGnBu", "YlGn", "RdPu", "Purples", "PuRd", "PuBuGn", "PuBu", "OrRd", "Oranges",
                                     "Greys", "Greens", "GnBu", "BuPu", "BuGn", "Blues", "Set2", "Set1", "Paired",
                                     "Dark2", "Accent", "Spectral", "RdYlGn", "RdYlBu", "RdGy", "RdBu", "PuOr",
                                     "PRGn", "PiYG", "BrBG"),
                         multiple = FALSE),
          actionButton("button_updateCategFile", "Add to Color Coding File",
                       width = "100%",
                       style="font-size: 10pt; color:black; background-color: lightgreen; display:inline-block; border:1px; margin:5px"),
          
  renderPlot({# Show the colors that will be associated with color levels
    if(any(is.null(input$sel_GetCategFile), is.null(input$sel_CategPalette), is.null(input$categ_ranked), input$sel_GetCategFile == "existing_data")) {
      # par(mar = c(1, 1, 1, 1)) 
     plot(NULL, xaxt='n', yaxt='n', bty='n', ylab='', xlab='', xlim=0:1, ylim=0:1)
    } else {
      # par(mar = c(1, 1, 1, 1)) 
      plot(NULL, xaxt='n', yaxt='n', bty='n', ylab='', xlab='', xlim=0:1, ylim=0:1)
  legend("topleft", legend = input$categ_ranked, pch=16, pt.cex=2.5, cex=1.25, bty='n', col = get_brewer_pal(input$sel_CategPalette, length(input$categ_ranked), plot = FALSE))
  mtext(input$sel_CategParam, at = 0.25, cex=1.25)
    }
  })
        ) # end of well panel
      ) # end hidden
    ), # end column 2

    # Rightside Panel for Categorical Definitions File
    column(5, style = "height: 100%;",
           shinyjs::hidden(
        wellPanel(
          id = "create_categfile_P4",
    div(style = "text-align: center;",
    em("Double-click in any cell to edit contents. To delete a row, click it once to select and then choose 'Delete Selected Row(s).'")),
  br(),
      renderUI({
  FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = FALSE)
  if(any(!rv$userSelect$sel_Organization %in% rv$sitesPointsSub$OrganizationFormalName))
    {rv_param_temp$categLevels <- tibble("CharSampleType" = as.character(), "CategOrder" =as.character(), "CategColor" = as.character())} # initiate a blank categorical levels data frame if the data have not been updated
  }),
div(
  style = "text-align: center;",
  # actionButton("button_categAddRow", "Add a Row",
               # style = "font-size: 10pt; padding: 4px 8px; margin-right: 10px;"),
  actionButton("button_categDeleteRow", "Delete Selected Row(s)",
               style = "font-size: 10pt; padding: 4px 8px;")
),
  br(),
  br(),
  dataTableOutput("categDT"),
  br(),
  br(),
  downloadLink("button_exportCateg", label = "Save table as .csv for future use")
  
  ) # end well panel
           ) # end hidden
    ) # end rightside panel
  ), # end fluidRow
  footer = modalButton("Dismiss"),
easyClose = TRUE,
  size = "l",
style = "width: 95vw; max-width: none;"  
)) # end modalDialog
  }) # end observeEvent

  output$categDT <- DT::renderDT({
  DT::datatable(
    rv_param_temp$categLevelsPlot,
    editable = TRUE,
    options = list(
      scrollY = "60vh",        # vertical scroll if needed
      scrollX = TRUE,        
      autoWidth = FALSE,       
      dom = 't'                # remove search and paging controls
    ),
    class = "stripe compact hover",
    rownames = FALSE
  )
})
proxyDT <- DT::dataTableProxy("categDT")

output$button_exportCateg <- downloadHandler(
  filename = function() {
    return(paste0("WQdash_categ_", rv$parkID, "_", paste0(gsub(pattern = "-", replacement = "", x = Sys.Date())),".csv"))
    },
  content = function(file) {
    write_csv(rv_param_temp$categLevelsPlot, file)
    }
  )

```

Explore Data
====================================== 

Inputs {.sidebar data-width=260}
-------------------------------------
```{r explore_data_input}
FuncAboutButton(nam = "button_aboutExploreData")
observeEvent(eventExpr = input$button_aboutExploreData, {
  browseURL(here::here("About_files", "aboutExploreData.html"))})

br()
br()
    
actionButton("button_getThreshFile", "Add a Threshold Limits File",
             style = "color: black; background-color: lightblue; border: 1px solid black;width:100%;")

br()
br()

actionButton("button_refreshPlotData", "REFRESH PLOT DATA", style="border-color:black; background-color: lightgreen; width:100%; border:0px; margin:0px") # updates plots

br()
br()

shinyBS::bsCollapse(
  id = "collapse_explore_input", 
  open = "Select data to plot",
  bsCollapsePanel(
    title = "Select data to plot", 
    renderUI({
      radioButtons("sel_SummarizeBy",
                   label = h6(" Summarize by:"),
                   choiceNames = list("ONE CHARACTERISTIC for many sites", "many characteristics for ONE SITE"),
                   choiceValues = list("by_chartype", "by_station"),
                   selected = "by_chartype")
      }),

# If summarizing by characteristic (ONE CHARACTERISTIC for many stations)...
renderUI({
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(rv_param_temp$subDatTypes))
  shiny::req(input$sel_SummarizeBy == "by_chartype")

  char_choices <- sort(intersect(unique(rv_param_temp$subDat$CharSampleType), rv_param_temp$subDatTypes$CharSampleType[rv_param_temp$subDatTypes$DataType == "numeric"]))

  selectInput("sel_ShowCharType",
                  label = h6("Select a characteristic to plot:"),
                  choices = char_choices,
                  selected = switch(is.null(input$sel_ShowCharType)+1, input$sel_ShowCharType, char_choices[1]))
}),

renderUI({
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowCharType))
  shiny::req(input$sel_SummarizeBy == "by_chartype")

  checkboxGroupInput("sel_ShowStations",
                          label = h6("Select monitoring site(s):"),
                          choices =  sort(unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharSampleType %in% input$sel_ShowCharType])),
                          selected = input$sel_ShowStations
  )# don't do switch here because will cause problems with select all/none

  }),

renderUI({
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowCharType))
  shiny::req(input$sel_SummarizeBy == "by_chartype")

      FuncAllNoneButtons(cond = "input.sel_ShowStations", name_all = "button_allStations", name_none = "button_noStations")
}),

# If summarizing by station (many characteristics for ONE SITE)...
renderUI({
    shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat))
  shiny::req(input$sel_SummarizeBy == "by_station")

    selectInput("sel_ShowOneStation",
                label = h6("Select a monitoring site:"),
                choices = sort(unique(rv_param_temp$subDat$MonitoringLocationIdentifier)),
                selected = input$sel_ShowOneStation)
}),

renderUI({
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(rv_param_temp$subDatTypes), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")

    checkboxGroupInput("sel_ShowStationCharTypes",
              label = h6("Select characteristic(s):"),
              choices = sort(intersect(unique(rv_param_temp$subDat$CharSampleType[rv_param_temp$subDat$MonitoringLocationIdentifier == input$sel_ShowOneStation]), rv_param_temp$subDatTypes$CharSampleType[rv_param_temp$subDatTypes$DataType == "numeric"])),
              selected = input$sel_ShowStationCharTypes
              ) # don't do switch here because will cause problems with select all/none
}),

renderUI({
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(rv_param_temp$subDatTypes), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")

    FuncAllNoneButtons(cond = "input.sel_ShowStationCharTypes", name_all = "button_allStationChars", name_none = "button_noStationChars")
}),
style = "default"
), # end of collapse panel

  bsCollapsePanel(
    title = "Thresholds & Percentiles",

  renderUI({
    shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_SummarizeBy))

    thresh_choice_values <- c("showthresh_none",
                              switch(any(is.null(rv_param_temp$threshList), nrow(rv_param_temp$threshList)==0)+1, "showthresh_file", NA),
                              switch((input$sel_SummarizeBy == "by_chartype")+1, NA, "showthresh_custom")
                              
    )
    thresh_choice_values <- thresh_choice_values[!is.na(thresh_choice_values)] # output is simpler than when using na_omit
    
    thresh_choice_names <- stringi::stri_replace_all_fixed(
      thresh_choice_values,
      pattern = c("showthresh_none", "showthresh_file", "showthresh_custom"), 
      replacement = c("Do not show", "Use threshold limits from attached file", "Use limits entered below for the selected characteristic"), 
      vectorize_all = FALSE)
    
    thresh_default <- ifelse(identical(thresh_choice_values, "showthresh_none"), "showthresh_none", ifelse("showthresh_file" %in% thresh_choice_values, "showthresh_file", "showthresh_custom"))

    radioButtons("sel_ShowThresholds",
                 label = h6("Show threshold limits on plot"),
                 choiceNames = thresh_choice_names,
                 choiceValues = thresh_choice_values,
                 selected = switch(is.null(input$sel_ShowThresholds)+1, input$sel_ShowThresholds, thresh_default)
    )
    }),
  
  # Set custom threshold limits
  conditionalPanel(
  condition = "input.sel_ShowThresholds == 'showthresh_custom'",

  renderUI({ 
    shiny::req(all(!is.null(rv_param_temp$subDat), !is.null(input$sel_ShowThresholds), input$sel_SummarizeBy == "by_chartype"))
         radioButtons("sel_NumThresh",
                      label = "Select number of thresholds:",
                      choices = c(0, 1, 2),
                      selected = 2,
                      inline = TRUE,
                      width = "280px")
  }),
    
    renderUI({
      shiny::req(all(!is.null(rv_param_temp$subDat), !is.null(input$sel_ShowThresholds), input$sel_SummarizeBy == "by_chartype"))
      shiny::req(input$sel_NumThresh > 0)
      
      numericInput("sel_ThreshLower",
                     label = "Threshold 1 (or lower cutoff value, if multiple):",
                     value = rv_param_temp$currentInputs$sel_ThreshLower,
                     min = NA,
                     max = NA,
                     step = NA)
    }),
    
    renderUI({
      shiny::req(input$sel_NumThresh == 2, !is.na(input$sel_ThreshLower), !is.null(input$sel_ThreshLower))
      numericInput("sel_ThreshUpper",
                     label = "Threshold 2 (higher than Threshold 1):",
                     value = rv_param_temp$currentInputs$sel_ThreshUpper,
                     min = input$sel_ThreshLower,
                     max = NA,
                     step = NA)
    }),
    
    renderUI({ # Classify values less than lower threshold value
      shiny::req(input$sel_NumThresh > 0, !is.null(input$sel_ThreshLower), !is.na(input$sel_ThreshLower))
      radioButtons("sel_ThreshCateg1",
                  label = paste0("Values LESS THAN ", input$sel_ThreshLower, " are classified as:"),
                  choices = c("good", "caution", "poor"),
                  inline = TRUE,
                  selected = rv_param_temp$currentInputs$sel_ThreshCateg1)
      }),
    
    renderUI({ # Classify values greater than lower threshold value
      shiny::req(input$sel_NumThresh > 0, !is.null(input$sel_ThreshLower), !is.na(input$sel_ThreshLower))
      
      if(all(input$sel_NumThresh == 2, !is.null(input$sel_ThreshUpper), !is.na(input$sel_ThreshUpper))) {
        thresh_label <- paste0("Values BETWEEN ", input$sel_ThreshLower, " and ", input$sel_ThreshUpper, " (inclusive) are classified as:")
      } else {
        thresh_label <- paste0("Values GREATER THAN ", input$sel_ThreshLower, " are classified as:")
      }
        
      radioButtons("sel_ThreshCateg2",
                  label = thresh_label,
                  choices = c("good", "caution", "poor"),
                  inline = TRUE,
                  selected = rv_param_temp$currentInputs$sel_ThreshCateg2)
    }),
  
  renderUI({ # classify values greater than upper threshold
    shiny::req(input$sel_NumThresh == 2, !is.null(input$sel_ThreshUpper), !is.na(input$sel_ThreshUpper))
    shiny::req(input$sel_ThreshLower < input$sel_ThreshUpper)
        
        radioButtons("sel_ThreshCateg3",
                    label = paste0("Values GREATER THAN ", input$sel_ThreshUpper, " are classified as:"),
                    choices = c("good", "caution", "poor"),
                    inline = TRUE,
                    selected = rv_param_temp$currentInputs$sel_ThreshCateg3)
  })
  ), # end of conditional panel for setting custom thresholds,

  hr(),

  renderUI({
  checkboxInput("sel_AddQuantile",
              label = h6("Add percentile lines to plot"),
              value = switch(is.null(input$sel_AddQuantile)+1, input$sel_AddQuantile, FALSE))
    }),
  
# Generate bold, red warning if percentile option is selected
tags$div(renderText({
  shiny::req(all(!is.null(input$sel_AddQuantile), input$sel_AddQuantile == TRUE))
  
  paste0("WARNING!! Percentiles should NOT be used to determine if values are high or low. Percentiles only indicate a typical range of values AMONG THE DATA SELECTED. To identify actual high/low values, use THRESHOLD LIMITS.")
}), style = "font-size:14px; font-weight:bold; color:red;"),

  renderUI({
    shiny::req(!is.null(input$sel_AddQuantile),
               !is.null(input$sel_SummarizeBy))
    shiny::req(input$sel_AddQuantile == TRUE)
    conditionalPanel(
      condition = "input.sel_AddQuantile == true",
      numericInput("sel_QuantileProbLower",
                 label = "Enter lower percentile limit (or 0 for no lower limit)",
                 value = 0.05,
                 min = 0.0,
                 max = 1.0,
                 step = 0.05),
      numericInput("sel_QuantileProbUpper",
                 label = "Enter upper percentile limit (or 1 for no upper limit)",
                 value = 0.95,
                 min = 0.0,
                 max = 1.0,
                 step = 0.05),
      # if(input$sel_SummarizeBy == "by_chartype") {
        selectInput("sel_QuantileGroupBy",
                 label = "Calculate percentile limits:",
                 choices = c("per site" = "quant_each",
                             "across sites" = "quant_all"),
              selected = "quant_all")
        # }
      )
    }),
style = "default"
), # end of collapse panel

  bsCollapsePanel(
    title = "Streamflow/Precip Plots",

  renderUI({
    radioButtons("sel_AddGagePrecip",
                 label = h6("Add external data plot: "),
                 choices = c("none", "streamflow", "precipitation"),
                 selected = switch(is.null(input$sel_AddGagePrecip)+1, input$sel_AddGagePrecip, "none")
                 )
  }),

  # Add streamflow plot
  renderUI({
    shiny::req(!is.null(input$sel_AddGagePrecip))
    shiny::req(input$sel_AddGagePrecip == "streamflow")
    print("line5314")
    shiny::validate(
      need(all(!is.null(rv$selectedGages), !is.null(rv$gagesDat)), message = "No streamflow data imported"))
    conditionalPanel(
      condition = "input.sel_AddGagePrecip == 'streamflow'",
      selectInput("sel_GageStation", # choose a gage station
                  label = "Select a gage station for streamflow data",
                  choices = sort(unique(rv$selectedGages$GageName)),
                  selected = switch(is.null(input$sel_GageStation)+1, input$sel_GageStation, sort(unique(rv$selectedGages$GageName))[1])),
      )
    }),

  # Add precipitation plot
  renderUI({
    shiny::req(!is.null(input$sel_AddGagePrecip))
    shiny::req(input$sel_AddGagePrecip == "precipitation")
    shiny::validate(
      need(all(!is.null(rv$selectedMeteo), !is.null(rv$meteoDat)), message = "No precipitation data imported"))
    conditionalPanel(
      condition = "input.sel_AddGagePrecip == 'precipitation'",
      selectInput("sel_PrecipStation", # choose a weather station
                  label = "Select a weather station",
                  choices = sort(unique(rv$selectedMeteo$MeteoName)),
                  selected = switch(is.null(input$sel_PrecipStation)+1, input$sel_PrecipStation, sort(unique(rv$selectedMeteo$MeteoName))[1])),
      )
    }),
  style = "default"
) # end of collapse panel
) # end of input collapse
```

Column
-------------------------------------
```{r explore_summaries}

### Explore map card----
explore_map_card <-
  bslib::card(
    style = "resize:vertical;",
    full_screen = FALSE,
    card_header(
      HTML('<span style="color: red;">Select sites via the map or sidebar, then click REFRESH PLOT DATA to generate plots. RIGHT CLICK on a site for quick-peek parameter summaries.</span>')
      ),
    card_body(
      class = "p-0",
      div(style="display:flex; flex-direction:row; max-width:98%; justify-content:center; flex-wrap: wrap; align-items: center;",
    # Left side inputs
    div(style ="flex: 1 1 30%; padding:5px; justify-content:center; align-items:left;", # padding is for spacing from div edge and each other
            renderUI({
  shiny::req(!is.null(rv$sitesPointsSub))
  param_map_zoom <- min(RgoogleMaps::MaxZoom(lonrange = c(st_bbox(rv$sitesPointsSub)$xmin, st_bbox(rv$sitesPointsSub)$xmax), latrange = c(st_bbox(rv$sitesPointsSub)$ymin, st_bbox(rv$sitesPointsSub)$ymax)))
  sliderInput("sel_ParamMapZoom", label = h6(strong("Set map zoom:")), min = max(1, param_map_zoom - 3), max = param_map_zoom + 5, value = param_map_zoom - 1, step = 0.25, ticks = FALSE, dragRange = FALSE, width = "100%")
  })
  ),

div(style ="flex: 1 1 30%; padding:5px; justify-content:center; align-items:center;", # using default flex grow-shrink-size
    
            renderUI({
          shiny::req(!is.null(rv$sitesPointsSub))
    sliderInput("sel_MapPointSize", label = h6(strong("Resize map points:")), min = -3, max = 3, value = 0, step = 1, ticks = FALSE, dragRange = FALSE, width = "100%")
    }),
    renderUI({
  shiny::req(!is.null(rv$unitPoly), !is.null(rv_param_temp$sel_summarize_by), !is.null(rv_param_temp$plotDat), !is.null(input$sel_ParamMapShow), !is.null(input$sel_MapByYr))
    shiny::req(input$sel_ParamMapShow != "show", input$sel_MapByYr == TRUE)
  sliderTextInput("sel_SurvYr", force_edges = TRUE, label = h6(strong("Choose a survey year")), choices = sort(unique(rv_param_temp$plotDat$Yr)), selected = max(rv_param_temp$plotDat$Yr, na.rm = TRUE), dragRange = FALSE, animate = TRUE, width = "100%")
  })
  ),
    
div(style ="flex: 1 1 30%; padding:5px; justify-content:center; align-items:right;", # using default flex grow-shrink-size
    renderUI({
      shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$plotDat))
        # shiny::req(identical(unique(rv_param_temp$plotDat$MonitoringLocationIdentifier), rv_param_temp$param_map_highlight)) # make sure the plots have been updated  
            
        shiny::req(identical(input$sel_SummarizeBy, rv_param_temp$sel_summarize_by))
        
        map_options_chartype_choice_names <- c("Sites", "Median", "Thresholds", "Percentiles")[c(TRUE, TRUE, sum(!is.na(rv_param_temp$plotDat["ThreshCateg"])) > 0, sum(!is.na(rv_param_temp$plotDat["PercCateg"])) > 0)]
        map_options_choice_values <- stringi::stri_replace_all_fixed(
          map_options_chartype_choice_names,
          pattern = c("Sites", "Median", "Thresholds", "Percentiles"),
          replacement = c("show", "median", "thresh", "perc"),
          vectorize_all = FALSE)
        
  shinyWidgets::radioGroupButtons("sel_ParamMapShow",
              label = h6(strong("Show on map: ")),
              choiceNames = switch((input$sel_SummarizeBy == "by_chartype")+1, c("Sites"), map_options_chartype_choice_names),
              choiceValues = switch((input$sel_SummarizeBy == "by_chartype")+1, c("Sites"), map_options_choice_values),
              status = "primary",
              size = "xs",
              selected = "show") 
  }),
      renderUI({
    shiny::req(!is.null(rv$unitPoly), !is.null(rv_param_temp$sel_summarize_by), !is.null(rv_param_temp$plotDat), !is.null(input$sel_ParamMapShow))
    shiny::req(input$sel_ParamMapShow != "show")
    checkboxInput("sel_MapByYr",
                  label = h6(strong("Show map summaries BY YEAR")),
                  value = FALSE
    )
  })
  )
),

leafletOutput('param_map', width = "100%")
  )
) # end of explore_map_card

### Explore seasonal patterns subcard----
explore_seasonal_patterns_subcard <-
  bslib::card(
    style = "resize:vertical;",
    full_screen = TRUE,
    card_header(
      shinyWidgets::radioGroupButtons("sel_SeasonalTimeUnit",
              label = h6("SEASONAL patterns time unit:"),
              choices = c("Day of Year" = "DayOfYr", "Week of Year" = "Wk", "Month of Year" = "Mnth", "Season of Year" = "Season"),
              selected = "Mnth",
              status = "primary",
              size = "xs"), 
      
      br(),

    renderPlot({ # separate validation statements so they are checked in sequence
    shiny::req(!is.null(rv$importSettings), !is.null(rv$sitesPointsSub), !is.null(rv_param_temp))
    if(any(!rv$importSettings$sel_Organization %in% rv$sitesPointsSub$OrganizationFormalName, is.null(rv_param_temp$seasonalPlot), is.null(rv_param_temp$showStations), is.null(rv_param_temp$showCharTypes), is.null(rv_param_temp$seasonalPlot$shared_legend))) { # this if-statement forces the plot to be reset to blank when these conditions apply
    seas_plotly_legend <- ggplot(dat = data.frame()) + theme_minimal()
  } else {
    seas_plotly_legend <- grid.arrange(rv_param_temp$seasonalPlot$shared_legend)
  }
  seas_plotly_legend
}, height = 70)# setting the width here or at the 'Legend' subheading seems to rescale the height too. Size of ggplot legends is absolute. Set height through the 'Legend' subheading in combination with here. Legend width will not adjust with browser window. Fixed the width issue by putting the plot notes on a white background.
), 
card_body(
  class = "p-0",
  plotlyOutput("out_season_plots")  
)
) # end explore_seasonal_patterns_subcard

### Explore plots card----
explore_plots_card <-
  bslib::card(
    gap = 0,
    card_body(
      class = "p-0",
      # div(style="display:flex; flex-direction:row; max-width:98%; justify-content:center; flex-wrap: wrap; align-items: center;",
      div(style = "display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; align-items: center; padding: 5px; max-width: 98%; margin: auto;",
    
    div(style = "display: flex; flex-direction: column; align-items: center; font-family: sans-serif;",
  tags$label("Plot Type:", style = "font-weight: bold; font-size: 80%; margin-bottom: 3px;"),
        
    shinyWidgets::radioGroupButtons("sel_PlotType",
             label = NULL, #h6(strong("Plot type:")),
             choiceNames = list("Points", "Points + Smooth", "Box Plots"),
             choiceValues = list("points", "points_smooth", "box"),
             status = "primary",
             size = "xs",
             selected = "points_smooth")
    ),
    
div(
  style = "flex: 1 1 25%; display: flex; justify-content: center; align-items: center; height: 28px;",
  div(
    style = "height: 100%; border: 1px solid #555; border-radius: 0; padding: 0 0px; display: flex; align-items: center; line-height: 1;",

    shinyWidgets::dropdownButton(
      inputId = "dropdown_options",
      label = "More Plot Options",
      circle = FALSE,
      status = "button_menu",
      size = "xs",
      icon = icon("sliders"),
      tooltip = "Additional options for user to modify plot",
    
    ## Allow different y-axes
    renderUI({
      shiny::req(all(!is.null(input$sel_SummarizeBy), input$sel_SummarizeBy == "by_chartype"), !is.null(input$sel_CombineSites), input$sel_CombineSites == FALSE)
      checkboxInput("sel_FreeY",
                        label = h6(strong("Allow y-axis to differ by plot")),
                        value = switch(is.null(input$sel_FreeY)+1, input$sel_FreeY, FALSE))
  }),
    
    ## Multiple sites in one plot
    renderUI({
      shiny::req(all(!is.null(input$sel_SummarizeBy), input$sel_SummarizeBy == "by_chartype"))
      checkboxInput("sel_CombineSites",
                        label = h6(strong("Combine sites in one plot")),
                        value = switch(is.null(input$sel_CombineSites)+1, input$sel_CombineSites, FALSE))
      }),

    ## Log-transform y-axes
    renderUI({
  shiny::req(!is.null(rv_param_temp$plotDat), !is.null(rv_param_temp$sel_add_gage_precip)) # the option to log-transform y-axes only appears after plots have been generated
  
  param_choices <- rv_param_temp$plotDat %>% dplyr::select(CharSampleType) %>% dplyr::distinct() %>% pull(CharSampleType)
  if(rv_param_temp$sel_add_gage_precip == "streamflow" & !is.null(rv_param_temp$sel_gage_station)) { # if there is a selected gage station
    param_choices <- c(param_choices, "streamflow")
  }
  if(rv_param_temp$sel_add_gage_precip == "precipitation" & !is.null(rv_param_temp$sel_precip_station)) { # if there is a selected precip station
    param_choices <- c(param_choices, "precipitation")
  }
  
  checkboxGroupInput("sel_log_y",
                     label = h6("Log-transform y-axis for:"),
                     choices = param_choices,
                     selected = NULL)
                      # a vector of the parameters for which y-axis should be log-transformed
}),
      ## Color by categorical character--only for point plots    
  renderUI({
    shiny::req(input$sel_PlotType %in% c("points", "points_smooth"))
    radioButtons("sel_Categ",
                 label = h6("Color points by a categorical characteristic:"),
                 choices = switch(all(!is.null(rv_param_temp$categLevelsPlot), !is.null(rv_param_temp$subDatTypes$CharSampleType[rv_param_temp$subDatTypes$DataType == "categorical"]))+1, "none", c("none", sort(intersect(rv_param_temp$subDatTypes$CharSampleType[rv_param_temp$subDatTypes$DataType == "categorical"], unique(rv_param_temp$categLevelsPlot$CharSampleType))))),
                 selected = "none")
    }),
    renderUI({
      sliderInput("sel_PlotHt",
                   label = h6("Change plot height:"),
                  min = -3,
                  max = 7,
                  step = 1,
                  animate = FALSE,
                  width = "100%",
                   value = 0)
    })
  ) # End Additional Plot Options
)
), 
          div(style ="flex: 1 1 15%; padding:5px; justify-content:center; align-items:left;",
    
  actionButton(inputId = "button_plotTable", label = "View Table", icon = icon("table-cells", lib = "font-awesome"), style="color:black; font-size:9pt; background-color: lightblue; display:inline-block; height: 28px; line-height:28px; padding: 0 8px; vertical-align: middle;")
  )
), # end of overall div

  navset_card_tab(
    nav_panel(
      title = "Time Series",
      bslib::card(
        style = "resize:vertical;",
        full_screen = TRUE,
        card_header(
          renderPlot({ # separate validation statements so they are checked in sequence
  shiny::req(!is.null(rv$importSettings), !is.null(rv$sitesPointsSub), !is.null(rv_param_temp))
  if(any(!rv$importSettings$sel_Organization %in% rv$sitesPointsSub$OrganizationFormalName, is.null(rv_param_temp$finalPlot), is.null(rv_param_temp$showStations), is.null(rv_param_temp$showCharTypes), is.null(rv_param_temp$finalPlot$shared_legend))) { # this if-statement forces the plot to be reset to blank when these conditions apply
    ts_plotly_legend <- ggplot(dat = data.frame()) + theme_minimal()
  } else {
    ts_plotly_legend <- grid.arrange(rv_param_temp$finalPlot$shared_legend)
  }
  ts_plotly_legend # setting the width here or at the 'Legend' subheading seems to rescale the height too. Size of ggplot legends is absolute. Set height through the 'Legend' subheading in combination with here. Legend width will not adjust with browser window. Fixed the width issue by putting the plot notes on a white background.
}, height = 70)
),
plotlyOutput("out_ts_plots")
)
),
nav_panel(
  title = "Seasonal Patterns",
  explore_seasonal_patterns_subcard
),
nav_panel(
  title = "Threshold Patterns",
  bslib::card(
    style = "resize:vertical;",
    full_screen = TRUE,
    plotlyOutput("out_thresh_plots"))
),
nav_panel(
  title = "Percentile Patterns",
  bslib::card(
    style = "resize:vertical;",
    full_screen = TRUE,
    p(plotlyOutput("out_perc_plots"))
)
  )
)
)
) # end of explore_plots_card

### Explore page setup----
bslib::layout_sidebar(
  border = FALSE,
  sidebar = sidebar(
    explore_map_card,
    position = "left",
    width = "50%",
    open = TRUE
  ),
  div(
    id = "plot-panel",
    explore_plots_card
  )
)

```

Raw Data
======================================
  
Inputs {.sidebar data-width=400}
-------------------------------------
```{r raw_data_input}
FuncAboutButton(nam = "button_aboutRawData")
observeEvent(eventExpr = input$button_aboutRawData, {
  browseURL(here::here("About_files", "aboutRawData.html"))})

br()

br()

strong("Raw Data Fields for Filtered Data")

# Raw data columns to display
em(tags$a(href="https://www.waterqualitydata.us/portal_userguide/#WQPUserGuide-Table5", target="_blank", "Click for Variable Definitions"))
renderUI({
  checkboxGroupInput("sel_RawFilteredDataCols",
                     label = h6("Raw data fields (columns) to display: "),
                     choices = sort(names(rv$dat)),
                     selected = c("OrganizationFormalName", "MonitoringLocationIdentifier", "CharacteristicName", "CharacteristicSet", "ActivityTypeCode", "ActivityStartDate", "ResultDetectionConditionText", "ResultMeasureValue", "ResultStatusIdentifier", "ResultCommentText")
  )
})
```

Raw Data
-------------------------------------

### Raw Data

<center>*For the filtered data, this table shows data records from the Water Quality Portal. Use the left sidebar to select data columns to display.*</center>

```{r raw_data}
output$table_raw_filtered <- DT::renderDT({

  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$subDat), !is.null(rv_param_temp$subDatTypes))

  output$table_raw_filtered <- DT::renderDT({

  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$subDat), !is.null(rv_param_temp$subDatTypes))

  DT::datatable(
    rv_param_temp$subDat %>%
      {if(!is.null(input$sel_RawFilteredDataCols)) dplyr::select(., input$sel_RawFilteredDataCols) else dplyr::select(., OrganizationFormalName, MonitoringLocationIdentifier, CharacteristicName, CharacteristicSet, ActivityTypeCode, ActivityStartDate, ResultDetectionConditionText, ResultMeasureValue, ResultStatusIdentifier, ResultCommentText)},
    rownames = FALSE,
    filter = "top",
    selection = "none",
    class="compact stripe",
    extensions=c('Buttons','ColReorder'),
    options = list(
          dom = 'Blrtp',
          buttons = list('csv', 'excel'),
          # lengthMenu = list(c(10, 20,30,40,-1),
          #                 c(10, 20,30,40,"All")),
          colReorder=TRUE,
          # pageLength = -1,
        columnDefs = list(list(className = 'dt_center', targets = "_all")),
          autoWidth = FALSE
        )
  )
})
})

DTOutput("table_raw_filtered")
```

Troubleshooting & FAQ's
====================================== 

Plot Data Tables {.tabset .tabset-fade}
-------------------------------------
### About the Data (placeholder to fill)
* Where do the data come from?
- [park unit boundaries - downloaded 1/9/2024] https://irma.nps.gov/DataStore/Reference/Profile/2224545?lnv=True [citation is: National Park Service (NPS), Chief Cartographer, Land Resources Division, WASO Fort Collins Land Resources Program Center. 2024. Administrative Boundaries of National Park System Units - National Geospatial Data Asset (NGDA) NPS National Parks Dataset. NPS - Land Resources Division]
- [Water Quality Portal] [citation is: Water Quality Portal. Washington (DC): National Water Quality Monitoring Council, United States Geological Survey (USGS), Environmental Protection Agency (EPA); 2021. https://doi.org/10.5066/P9QRKUVJ.]

### Troubleshooting (placeholder to fill)
* I could not import data from web services (import aborted)
* Some of the data from WQP were not in the imported data file
- APPA, etc., by HUC so needed HUC10 associated
- Default is at least 2 sampling activities within the past 6 years and a subset of site types and WQ parameters. Try custom import instead.
* I found a bug in the dashboard! How do I report it?
* I found a mistake in the data--how do I report it?

### FAQ's (placeholder to fill)
* Difference btwn fast import and custom import
* Can I import my own water quality data to display with the visualizer?
* What is a water quality "characteristic type"?
* What is "sampling activities"?
* How can I set custom seasons if I don't want to use calendar seasons?
* How can I export figures and tables from the dashboard?
* How were default threshold limits determined?
https://www.epa.gov/wqs-tech/state-specific-water-quality-standards-effective-under-clean-water-act-cwa#tb4
* How to reorder/display categorical parameters with colors?
* How to upload my own threshold limits?
* Can I set threshold limits calculated over multiple days, etc.?
* Can I download the dashboard to my own computer?
* GitHub link and contact email for questions, suggestions, reporting bugs
* What R and package versions does this dashboard use?