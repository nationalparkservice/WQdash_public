---
title: "Water in Our Parks"
output:
  flexdashboard::flex_dashboard:
    bootswatch: sandstone   # theme options: default, cosmo, bootstrap, cerulean, journal, flatly, readable, spacelab, united, lumen, paper, sandstone, simplex, yeti
orientation: columns
vertical_layout: fill
runtime: shiny
---

```{r global, include=FALSE}
# https://www.r-bloggers.com/2016/03/r-shiny-leaflet-using-observers/

# Install and load packages
rm(list=ls())

pkgs <- c("flexdashboard", "shiny", "knitr",  "here", "tidyverse", "janitor", "mgcv", "plyr", "scales", "rtf", "rmarkdown", "shinyWidgets", "leaflet", "RgoogleMaps", "plotrix", "GGally", "plotly", "httr", "jsonlite", "tidyverse", "readr", "sp", "sf", "magrittr", "leaflet.extras", "lubridate", "fontawesome", "viridisLite", "purrr",
          "bslib", # for accordian panels
          "bsicons",
          "stringr",
          "ggpubr", # for drawing separate legends
              "heatmaply", # for interactive heat plots
              "reactable", # for easy nested tables
              "htmltools", # for arranging plots in tab (browsable)
              "shinyFiles", # for user to save files in specified location
              "RColorBrewer", # to display brewer palettes
              "shinyjs", # for easy functions that use JavaScript
              "stringr", # to detect text snippets
              "sortable", # drag-and-drop rank input <<<<<<<<<<
              # "tmaptools", # for flexible color mapping
              "DT", # for interactive tables
              "zoo", # for year-month
              "cowplot", # to get legends from plots
              "gridExtra", # for arranging plots and adding plot annotations (ggplotly can't do captions or subtitles)
              "RgoogleMaps", # for MaxZoom & MinZoom
              "geojsonio", # to test for presence of features
              "rnoaa", # to get NOAA climate data
              "leaflet.minicharts") # MK analysis
       
           

installed_pkgs <- pkgs %in% installed.packages()
if (length(pkgs[!installed_pkgs]) > 0) install.packages(pkgs[!installed_pkgs], repos = "https://cloud.r-project.org", dep=TRUE) 
invisible(lapply(pkgs, library, character.only = TRUE))

options(shiny.maxRequestSize = 20*1024^2, 
        timeout = 300,
        stringsAsFactors = FALSE,
        DT.options = list(
          hover = TRUE,
          scrollX = TRUE,
          scrollY = TRUE,
          autoWidth = FALSE),
        # Header width doesn't match body width when this is set to TRUE. To fix, would need to include code to recalculate widths only after a tab is visible. If setting column widths, need to set autoWidth to TRUE
        dplyr.summarise.inform = FALSE
)

```

```{r css}
# Dropdown options color # <<<<<<<<<<<<<<<<<<<<<<<<<<<
tags$style(HTML("#dropdown_options {
                      background-color: lightgreen !important;}
                      ")
)

tags$style(".dropdown-toggle, .dropdown-menu {
  width: 100%;
  text-align: left;
}
") # dropdown menus should be full width

                      
# This sizes and positions the custom gif loading images
tags$style("#gif_modal .modal-body {padding:0px}
            #gif_modal .modal-dialog {width:auto; display:inline-block; position:absolute; top:35%;left:50%; transform:translate(-50%, -50%) !important;}
")

# This expands map to fill screen
tags$style("map param_map {
           height: calc(100vh - 80px) !important;
           }")

# Call this to force an input value to reset to NULL
tags$script("
    Shiny.addCustomMessageHandler('setNull', function(variableName) {
      Shiny.setInputValue(id = variableName, value = null);
    });
  ")

# Call this to force an input value to reset to a specified value
tags$script("
    Shiny.addCustomMessageHandler('resetValue', function(message) {
      Shiny.setInputValue(message);
    });
  ")

# # This allows renderTables to scroll when overflow
# tags$style(".chart-wrapper {
#   overflow-x:scroll;
#   overflow-y:scroll;
# }")

# When an action button is disabled, text should be gray and button color light gray
tags$style(".btn.disabled {
  color:gray;
  background-color:light-gray;
}")

tags$style(".rank-list-title {
  font-size:14px;
  padding:4px;
}")

tags$style(".rank-list-item {
  font-size:14px;
  padding:4px;
}")

tags$style("table.dataTable tbody th, table.dataTable tbody td input.form-control {
    padding: 2px 5px; 
}") # reduce padding in data tables

tags$style(HTML(".shiny-output-error-validation {
  font-size:14px;
  color: #FF0000;
}")
) # validation text is in red. Could also add 'font-weight: bold;'

tags$style(".reactable {
font-size: 13px; 
}") # font size for reactable tables

tag.map.title <- tags$style(HTML("
  .leaflet-control.map-title {
    transform: translate(-50%,20%);
    position: fixed !important;
    left: 50%;
    text-align: center;
    padding-left: 10px;
    padding-right: 10px;
    background: rgba(255,255,255,0.75);
    font-weight: bold;
    font-size: 20px;
  }
")) # add title to leaflet map

tags$style(".chart-stage-flex {
  overflow: scroll !important;
}") # Helps ensure data table bottoms don't get cut off


```

```{r generic_action_buttons}
# Action to cancel modal
observeEvent(eventExpr = input$button_cancelModal, {
  removeModal()
  })

```

```{r functions}
### FUNCTIONS ----
FuncPlotsMessage <- function(which_message) { # <<<<<<<<<<<<<<< FILL THIS IN
 
    if(which_message == "start") {
    shiny::validate(
     need(!is.null(rv$subDat), message = "To show... do this. To compare one parameter across sites...do this."))}
  if(which_message == "modify_plots") {
    shiny::validate(
    need(!is.null(rv_param_temp$plotDat), message = "To modify plots...do this"))}
  if(which_message == "show_thresh") {
    shiny::validate(
    need(!is.null(rv_param_temp$plotDat), message = "Some message about showing thresholds on the map"))}
  }

FuncAboutButton <- function(nam) {
  actionButton(nam, "   PAGE INSTRUCTIONS", icon = icon("question-sign", lib = "glyphicon"), width = "100%")
}

FuncShowWellPanel <- function(input_to_test, wp_to_toggle) {
  # Function to show or hide a well panel based on a checkbox selection
  #
  # Args:
  #   input_to_test:  The ID of the checkbox input, e.g., input$sel_ShowPanel
  #   wp_to_toggle:  ID of the well panel to toggle, e.g., wp_example
  #
  shiny::req(!is.null(rv$dat),!is.null(input_to_test))
  if(input_to_test) {
    shinyjs::showElement(wp_to_toggle)
    } else {
      shinyjs::hideElement(wp_to_toggle)
    }
  }

FuncAllNoneButtons <- function(cond, name_all, name_none) {
  # Function to create 'Select All' and 'Select None' action buttons
  #
  # Args:
  #   cond:  The input ID that needs to be defined for buttons to show (enter as input.XXX rather than as input$XXX)
  #   name_all:  ID to assign to 'Select All' button
  #   name_none:  ID to assign to 'Select None' button
  #
  conditionalPanel(
    condition = paste0("typeof ", cond, " !== 'undefined'"),
    actionButton(name_all, "Select All", style="color:black; display:inline-block; border:1px; padding:4px 12px;"),
    actionButton(name_none, "Select None", style="color:black; display:inline-block; border:1px; padding:4px 12px;")
  )
}

FuncOrderCheck <- function(import = FALSE, filter_internal = FALSE, filter_external = FALSE, plot = FALSE, MK = FALSE) {

  # Function to check if data have been imported, filtered, and plot data summarized
    if(import) {
      shiny::validate(
     need(!is.null(rv$dat), message = "No data available. Please use the 'Get WQP Data' tab to first import or load water quality data."))}
  if(filter_internal) {
    shiny::validate(
    need(!is.null(rv_param_temp$subDat) & !is.null(rv_param_temp$subDatTypes), message = "From the left sidebar, choose a subset of data to work with"))}
  if(filter_external) {
    shiny::validate(
    need(!is.null(rv_param_temp$subDat) & !is.null(rv_param_temp$subDatTypes), message = "On the 'Define & Filter Data' page, please choose a subset of data to work with"))}
  if(plot) {
    shiny::validate(
    need(!is.null(rv_param_temp$plotDat), message = "On the 'Explore Data - Time Series' page, select characteristic set(s) and monitoring site(s) to plot and then click the green 'REFRESH PLOT DATA' button."))
 if(MK) {
    shiny::validate(
    need(!is.null(rv_param_temp$trendDat), message = "From the left sidebar, please choose a trend test and then click the green 'UPDATE MK RESULTS' button"))}

  }
}

FuncUpdateUserSelect <- function(inputs_to_update) {
  shiny::req(!is.null(rv$dat))
  input_list <- isolate(reactiveValuesToList(input)) # difficulties indexing reactive list, so convert to unreactive list first
  replacement_list <- input_list[inputs_to_update]
  names(replacement_list) <- inputs_to_update # adds list element name, even for NULL elements
  rv$userSelect <- modifyList(rv$userSelect, replacement_list, keep.null = TRUE) # update only the list elements in replacement_list
}
  
FuncPlotDat <- function() {
  # Function to format plot data based on user selections on plot page
  #
  # Returns:
  #   Formatted plot data

  shiny::req(!is.null(rv_param_temp$subDat), !is.null(rv_param_temp$sel_summarize_by))
  # Filter plotting data by user inputs
  plotDat <- rv_param_temp$subDat %>%
    dplyr::select(ActivityStartDate, CharacteristicName, CharacteristicSet, DetectionQuantitationLimitMeasure.MeasureValue, MonitoringLocationIdentifier, OrganizationFormalName, ResultDetectionConditionText, DetectionQuantitationLimitTypeName, ResultMeasureValue, ResultMeasureValue_replaced, ResultMeasure.MeasureUnitCode, ResultSampleFractionText, ThreshCateg, YrDate, MnthDate, WkDate, Yr, Season, Mnth, Wk, DayOfYr) %>% # just keep these columns
    dplyr::filter(MonitoringLocationIdentifier %in% rv_param_temp$showStations & CharacteristicSet %in% rv_param_temp$showCharSets)
  plotDat$ResultMeasureValue <- as.numeric(plotDat$ResultMeasureValue)
  plotDat$DetectionQuantitationLimitMeasure.MeasureValue <- as.numeric(plotDat$DetectionQuantitationLimitMeasure.MeasureValue)
  
    # If coloring by categorical characteristics
    if(!is.null(input$sel_Categ)) {
      if(input$sel_Categ != "none") {
        if(rv_param_temp$sel_summarize_by == "by_char") {
          shiny::validate(
            need(input$sel_CombineSites == FALSE, message = "Cannot color points by a categorical characteristic when multiple monitoring sites are combined in a single plot. Please UNSELECT the checkbox for 'Combine sites in one plot'"))
        }
        shiny::req(!is.null(rv_param_temp$categLevelsPlot))
        shiny::validate(
          need(input$sel_Categ %in% unique(rv_param_temp$categLevelsPlot$CharacteristicName), message = "The selected categorical characteristic is not recognized as a categorical characteristic in the dataset. Please first add it to the categorical definitions file."))
        plotCategDat <- rv$dat %>% # pulling from the original data
          dplyr::filter(CharacteristicName == input$sel_Categ) %>%
          dplyr::select(OrganizationFormalName, ActivityStartDate, MonitoringLocationIdentifier, CategName = CharacteristicName, CategResultMeasureValue = ResultMeasureValue) %>%
          dplyr::distinct(.)

        plotDat %<>% dplyr::left_join(plotCategDat, by = c("OrganizationFormalName", "MonitoringLocationIdentifier", "ActivityStartDate"))
        plotDat$CategResultMeasureValue <- as.factor(plotDat$CategResultMeasureValue)
        cat("line1034")
      }
    }
    
    # Assign custom threshold limits
    if(!is.null(rv_param_temp$sel_show_thresholds) & !is.null(input$sel_ThreshUnit) & !is.null(input$sel_ThreshLower) & !is.null(input$sel_ThreshUpper) & !is.null(plotDat)) {
    if(rv_param_temp$sel_show_thresholds == "showthresh_custom" & rv_param_temp$sel_summarize_by == "by_char") {

      plotDat$ThreshCateg <- NA
      rv_param_temp$threshCustom <- list()
      
    if(input$sel_ThreshLower != -999 | input$sel_ThreshUpper != 999) { # if a lower or upper threshold has been entered
      thresh_ID <- paste0(unique(na.omit(rv_param_temp$plotDat$CharacteristicName)), " (", input$sel_ThreshUnit, ")")
      if(input$sel_ThreshLower == -999) { # no lower limit
        temp_cut <- c(-Inf, input$sel_ThreshUpper, Inf)
        temp_categ <- c("good", "above")
        temp_colors <- c("#56B4E9", "#E69F00")
      }
      
      if(input$sel_ThreshUpper == 999) { # no upper limit
        temp_cut <- c(-Inf, input$sel_ThreshLower, Inf)
        temp_categ <- c("below", "good")
        temp_colors <- c("lightgray", "#56B4E9")
      }
      
      if(input$sel_ThreshLower != -999 & input$sel_ThreshUpper != 999) { # has lower and upper limit
        temp_cut <- c(-Inf, input$sel_ThreshLower, input$sel_ThreshUpper, Inf)
        temp_categ <- c("below", "good", "above")
        temp_colors <- c("lightgray", "#56B4E9", "#E69F00")
      }
      
    temp_thresh_custom <- list(
      "CharacteristicName" = unique(na.omit(plotDat$CharacteristicName)),
      "ResultMeasure.MeasureUnitCode" = input$sel_ThreshUnit,
      "cut_breaks" = temp_cut,
      "cut_categ" = temp_categ,
      "cut_colors" = temp_colors
    )
    rv_param_temp$threshCustom[[thresh_ID]] <- temp_thresh_custom
    
    # Fill ThreshCateg column in plotDat
    shiny::req(!is.null(rv_param_temp$threshCustom))
    which_rows <- which(plotDat$CharacteristicName == rv_param_temp$threshCustom[[1]]$CharacteristicName & plotDat$ResultMeasure.MeasureUnitCode == rv_param_temp$threshCustom[[1]]$ResultMeasure.MeasureUnitCode)
    if(length(which_rows) > 0) {
      plotDat$ThreshCateg[which_rows] <- as.character(cut(as.numeric(plotDat$ResultMeasureValue_replaced[which_rows]), breaks = rv_param_temp$threshCustom[[1]]$cut_breaks, labels = rv_param_temp$threshCustom[[1]]$cut_categ))
        }
      }
    }
      }# end assign custom threshold limits

    # Determine quantiles for plots
    # if(any(input$sel_AddQuantile == FALSE, is.null(input$sel_QuantileProbLower), is.null(input$sel_QuantileProbUpper), is.null(input$sel_QuantileGroupBy))) { # if user specified quantile lines - I FEEL LIKE THERE MIGHT BE REDUNDANCY HERE I CAN WORK ON
  if(any(input$sel_AddQuantile == FALSE, is.null(input$sel_QuantileProbLower), is.null(input$sel_QuantileProbUpper))) {
      rv_param_temp$quantDat <- NULL
    } else {

      if(rv_param_temp$sel_summarize_by == "by_station" | (rv_param_temp$sel_summarize_by == "by_char" & input$sel_QuantileGroupBy == "quant_each"))  { # if 'by_station' or if 'by_char' and calculating separate quantile for each station, then group data by station-characteristicname
        rv_param_temp$quantDat <- plotDat %>%
          dplyr::select(MonitoringLocationIdentifier, CharacteristicName, ResultMeasureValue_replaced) %>%
          dplyr::group_by(MonitoringLocationIdentifier, CharacteristicName) %>%
          dplyr::summarise(QuantLineLower = quantile(ResultMeasureValue_replaced, probs = input$sel_QuantileProbLower, na.rm = TRUE),
                    QuantLineUpper = quantile(ResultMeasureValue_replaced, probs = input$sel_QuantileProbUpper, na.rm = TRUE)) # data frame where each row has a monitoring station ID and the value for the user-defined quantile probability
      }
      
      if(rv_param_temp$sel_summarize_by == "by_char" & input$sel_QuantileGroupBy == "quant_all") { # if 'by_char' and calculating one quantile across all stations
        rv_param_temp$quantDat <- data.frame(
          MonitoringLocationIdentifier = sort(unique(plotDat$MonitoringLocationIdentifier)),
          CharacteristicName = sort(unique(plotDat$CharacteristicName)),
          QuantLineLower = as.numeric(quantile(plotDat$ResultMeasureValue_replaced, probs = input$sel_QuantileProbLower, na.rm = TRUE)),
          QuantLineUpper = as.numeric(quantile(plotDat$ResultMeasureValue_replaced, probs = input$sel_QuantileProbUpper, na.rm = TRUE)),
          stringsAsFactors = FALSE)
      }
    }

    # Finalize the plotDat
    # Add quantDat columns
    if(!is.null(rv_param_temp$quantDat)) {
        plotDat2 <- plotDat %>%
          left_join(data.frame(rv_param_temp$quantDat), by = setdiff(names(rv_param_temp$quantDat), c("QuantLineLower", "QuantLineUpper"))) %>%
          dplyr::mutate(PercCateg = ifelse(ResultMeasureValue_replaced > QuantLineUpper, "above", ifelse(ResultMeasureValue_replaced < QuantLineLower, "below", ifelse(ResultMeasureValue_replaced >= QuantLineLower & ResultMeasureValue_replaced <= QuantLineUpper, "between", NA))))
        plotDat2$PercCateg <- factor(plotDat2$PercCateg, levels = c("below", "between", "above"))
    } else {
      plotDat2 <- plotDat %>%
        dplyr::mutate(PercCateg = NA)
    }
  
    return(plotDat2)
  }
 
FuncGageDat <- function(gage_station) {
  # Function to summarize gage data for plotting
  #
  # Args:
  #   gage_station: Name of the gage station to summarize data of
  #
  # Returns:
  #   Streamflow data for the selected gage station, and limited to the range of dates for which data will be plot

  shiny::req(!is.null(rv_param_temp$plotDat), !is.null(rv$gagesDat), !is.null(rv$userSelect$sel_DefineSeasons))
  shiny::validate(need(gage_station %in% unique(rv$gagesDat$GageName), message = "Streamflow data not available for the selected gage station"))
  gageDat <- subset(rv$gagesDat, GageName == gage_station & ActivityStartDate >= min(rv_param_temp$plotDat$ActivityStartDate, na.rm = TRUE) & ActivityStartDate <= max(rv_param_temp$plotDat$ActivityStartDate, na.rm = TRUE)) %>%
    dplyr::ungroup()
  
  # Assign custom seasons if applicable
  if(nrow(gageDat) > 0 & rv$userSelect$sel_DefineSeasons %in% c("WaterSeasons", "CustomSeasons"))
    {
    gageDat <- FuncCustomSeasons(dat_df = gageDat, seas = rv$userSelect$sel_DefineSeasons)
  }
  
  # Assign water year if applicable
  if(rv$userSelect$sel_DefineSeasons=="WaterSeasons") {
    gageDat$Yr <- gageDat$WaterYr
    gageDat$Mnth <- factor(gageDat$Mnth, levels(gageDat$Mnth)[c(10,11,12,1:9)])
    } else {
      gageDat$Yr <- gageDat$MeteoYr
      gageDat$Mnth <- factor(gageDat$Mnth, levels(rv$dat$Mnth))
    }
  
  if(!is.null(gageDat) & sum(!is.na(gageDat$MeanDailyDischarge)) == 0) {
        showModal(modalDialog(
          title = "No Data",
          "Streamflow data for the selected gage station do not overlap the timespan of water quality data."
          # , footer = modalButton("OK")
          ))
    gageDat <- NULL
        }
    
  return(gageDat)
} 

FuncPrecipDat <- function(precip_station) {
  # Function to summarize precipitation data for plotting. Use mean rather than total for each month, in case missing data
  #
  # Args:
  #   precip_station: Name of the precipitation station to summarize data of
  #
  # Returns:
  #   Precipitation data for the selected weather station, and limited to the range of dates for which data will be plot

  shiny::req(!is.null(rv_param_temp$plotDat), !is.null(rv$meteoDat), !is.null(rv$selectedMeteo))
  shiny::validate(need(precip_station %in% unique(rv$meteoDat$MeteoName), message = "Precipitation data not available for the selected weather station"))
  precipDat <- subset(rv$meteoDat, MeteoShortID == rv$selectedMeteo$MeteoShortID[rv$selectedMeteo$MeteoName == precip_station] & ActivityStartDate >= min(rv_param_temp$plotDat$ActivityStartDate, na.rm = TRUE) & ActivityStartDate <= max(rv_param_temp$plotDat$ActivityStartDate, na.rm = TRUE)) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(MeteoName = precip_station)
  
    # Assign custom seasons if applicable
  if(nrow(precipDat) > 0 & rv$userSelect$sel_DefineSeasons %in% c("WaterSeasons", "CustomSeasons"))
    {
    precipDat <- FuncCustomSeasons(dat_df = precipDat, seas = rv$userSelect$sel_DefineSeasons)
  }
  
  # Assign water year if applicable
  if(rv$userSelect$sel_DefineSeasons=="WaterSeasons") {
    precipDat$Yr <- precipDat$WaterYr
    precipDat$Mnth <- factor(precipDat$Mnth, levels(precipDat$Mnth)[c(10,11,12,1:9)])
    } else {
      precipDat$Yr <- precipDat$MeteoYr
      precipDat$Mnth <- factor(precipDat$Mnth, levels(rv$dat$Mnth))
    }

  return(precipDat)
} 

FuncPlotlyFormat <- function(plotly_list, plotly_title, subplot_titles_vec = NULL, xlab, shared_ylab = NULL, shared_ylab_position = NULL, ylab_vec = NULL, total_height, top_margin = 60, bottom_margin = 5, left_margin = 80, right_margin = 60, hover_tip = NULL, is_grouped_boxplots = FALSE) { # <<<<< CHANGE BACK TO "text" FOR HOVER_TIP
  # Function to arrange interactive plots from a list. Necessary because plotly does not format well just with grid.arrange or ggplot faceting
  #
  # Args:
  #   plotly_list: Lists of ggplots that will be generated as a set.
  #   plotly_title: Title for plot set.
  #   subplot_titles_vec: Vector of subplot titles
  #   xlab: X-axis label.
  #   shared_ylab: A single y-axis label to be shared across all subplots.
  #   shared_ylab_position: A number (usually negative) indicating location of a shared y-axis label
  #   ylab_vec: Vector of y-axis labels
  #   total_height: Total height for the plot set.
  #   top_margin...right_margin: Margin sizes that will be used for the final page
  #   hover_tip: Argument for ggplotly--what will show on hover
  #   is_grouped_boxplots: Logical--need additional code if grouped boxplots
  #
  # Returns:
  #   Formatted plotly for a set of plots
  # 
  out_list <- list()
  for(p in 1:length(plotly_list)) {
    temp_plot <- ggplotly(
      plotly_list[[p]],
      tooltip = hover_tip,
      height = total_height
      ) %>% # specify the total plot height here because this layout will be applied to the entire page
        # highlight(.,
        #           on = "plotly_click", 
        #           off = "plotly_doubleclick",
        #           color = I("red"), 
        #           selectize = TRUE,
        #           persistent = TRUE,
        #           opacityDim = .3,
        #           dynamic = FALSE,
        #           selected = attrs_selected(showlegend = FALSE)
        #           ) %>% # linked brushing
      layout(
        title = list( # this is the title for the page
          font = list(size = 20),
          text = plotly_title), # title
        margin = list(
          t=top_margin,
          b=bottom_margin,
          l= left_margin,
          r=right_margin),
        xaxis = list(
          title = xlab,
          font = list(size = 16, family = "Arial"),
          showspikes = TRUE,
          spikemode  = "across", # draw line across plots and to x-axis
          spikedash = "solid",
          spikecolor = "gray",
          spikesnap = "data",
          spikethickness = 2))
    
    # If adding a shared y-axis title...
    if(!is.null(shared_ylab)) {
      temp_plot %<>%
        layout(
          annotations = list(
            x = shared_ylab_position,
            y = 0.55,
            text = shared_ylab,
            showarrow = F, 
            xref="paper",
            yref="paper",
            xanchor="left",
            yanchor="middle",
            textangle=-90,
            font=list(size=16, family = "Arial", color="black")
          ))
      }
    
    # If adding subplot titles...
    if(!is.null(subplot_titles_vec)) {
      temp_plot %<>%
        layout(
          annotations = list(
            text = subplot_titles_vec[[p]],
            xref = "paper",
            yref = "paper",
            yanchor = "top",
            xanchor = "middle",
            x = 0.5,
            y = 1.2,
            showarrow = FALSE,
            font=list(size=16, family = "Arial", color="black")
          ))
    }
    
    # If adding individual y-axis titles...
    if(!is.null(ylab_vec)) {
      temp_plot %<>% 
        layout(
          yaxis = list(
            title = ylab_vec[p], 
            font = list(size = 16, family = "Arial")) # font size and family for y-axis
        )
    }
    
    if(is_grouped_boxplots) { # if boxplots for multiple stations, all combined
      temp_plot %<>% layout(boxmode = "group") # Will generate a false warning -- this is a known, unresolved issue with plotly (issue was closed due to low priority)
    }
    
    out_list[[p]] <- plotly::hide_legend(temp_plot) # this doesn't work for heatmap continuous colors
  }
  return(out_list)
}

FuncQuantLines <- function(quant_df, combine_sites, dat_df, p) {
  if(!is.null(quant_df)) {
    if(nrow(quant_df)>0) {
      # ...if stations will all be in a single plot and quantLine is by station...
      if(rv_param_temp$sel_summarize_by == "by_char" & combine_sites==TRUE & length(unique(dat_df$MonitoringLocationIdentifier)) > 1) {
        if(length(unique(quant_df$QuantLineLower)) > 1 | length(unique(quant_df$QuantLineUpper)) > 1) {
          showModal(modalDialog(
            title = "Percentile by Monitoring Site",
            "When combining monitoring sites in a plot, the percentile limits must be calculated across all sites rather than by individual sites"
            ))
          shiny::req(length(unique(quant_df$QuantLineLower)) == 1, length(unique(quant_df$QuantLineUpper)) == 1)
        }
        }
      p <- p +
        geom_hline(data = quant_df %>% dplyr::filter(CharacteristicName==sort(unique(dat_df$CharacteristicName)) & MonitoringLocationIdentifier==sort(unique(dat_df$MonitoringLocationIdentifier))), aes(yintercept = QuantLineLower), linetype = "dashed", color = "red") +
        geom_hline(data = quant_df %>% dplyr::filter(CharacteristicName==sort(unique(dat_df$CharacteristicName)) & MonitoringLocationIdentifier==sort(unique(dat_df$MonitoringLocationIdentifier))), aes(yintercept = QuantLineUpper), linetype = "solid", color = "red")
    }
  }
  return(p)
  }

FuncAddThresh <- function(v_char, thresh, p, xlow_temp = NULL, xhigh_temp = NULL, ylow_temp, yhigh_temp) {
  # Function to add threshold background color
  #
  # Args:
  #   v_char:  Characteristic Name
  #   thresh: NULL or the list for threshold background colors for this site-char
  #   p: Base plot
  #   xlow_temp, xhigh_temp, ylow_temp, yhigh_temp: lower/upper x/y limits for threshold box
  #
  # Returns:
  #   Plot with threshold background
  #
    for (i in 1:length(thresh$cut_categ)) {
      ylow = max(thresh$cut_breaks[i], ylow_temp)
      yhigh = min(thresh$cut_breaks[i+1], yhigh_temp)
      if(ylow <= yhigh) {
        fill_col = thresh$cut_colors[i]
        p <- p +
          geom_rect(data = data.frame(ylow, yhigh), aes(xmin = xlow_temp, xmax = xhigh_temp, ymin = ylow, ymax = yhigh), fill = fill_col, alpha = 0.15, show.legend = FALSE, inherit.aes = FALSE)
      }
    } # threshold background boxes
  return(p)
}

FuncPlotScatter <- function(plot_dat, quant_df = NULL, categ_df = NULL, x_nam = "ActivityStartDate", combine_sites, fixed_free_y = "fixed", add_loess = TRUE, incl_cens = FALSE, thresh_list = NULL, rotate_x = FALSE, gage_dat = NULL, precip_dat = NULL, month_summary = FALSE, sel_add_gage_precip = switch(is.null(rv_param_temp$sel_add_gage_precip)+1, rv_param_temp$sel_add_gage_precip, "none"), sel_categ, trans_log_y) {
  # Function to generate scatterplot of data, with censored values shown as dotted intervals
  #
  # Args:
  #   plot_dat:  A data frame with the raw data
  #   quant_df:  A data frame with quantile probability limits for each station
  #   categ_df: NULL or the imported categorical levels dataframe
  #   x_nam: Column name for x-axis variable
  #   combine_sites:  TRUE to combine multiple stations in a single plot of a characteristic
  #   fixed_free_y:  Are scales fixed or free across all plots?
  #   add_loess:  Add loess smooth? (will be biased by censored data)
  #   incl_cens: Should censored data be plot as intervals?
  #   thresh_list: NULL or the list for threshold background colors
  #   rotate_x: should x-axis labels be rotated?
  #   gage_dat: USGS gage station data, if streamflow plot should be included: otherwise, NULL
  #   precip_dat: weather station data, if precipitation plot should be included; otherwise, NULL
  #
  # Returns:
  #   List of scatterplot
  # 

  shiny::req(sum(!is.na(plot_dat$y)) > 0) # make sure there are data

  # All plots share a single x-axis. Don't need to do this for other x_nam because those are factors with specified levels.
if(x_nam == "ActivityStartDate") {
  xaxes_min = min(plot_dat$x, na.rm = TRUE)
  xaxes_max = max(plot_dat$x, na.rm = TRUE)
}

  # Create column for point shape
  plot_dat %<>% dplyr::mutate(
    pointShape = factor(ifelse(ResultDetectionConditionText == "Detected and Quantified", "quant", "censored"))) # filled circle (shape = 16) if the datum was detected and quantified, otherwise open circle (shape 1)

  # Create the water quality plot(s)
  p1_points_list <- list()
  cat("line1434")
  
  if(rv_param_temp$sel_summarize_by == "by_char" & combine_sites==TRUE) {
    unique_df <- plot_dat %>% dplyr::select(CharacteristicName) %>% dplyr::distinct()
  } else {
    unique_df <- plot_dat %>% expand(CharacteristicName, MonitoringLocationIdentifier) %>% arrange(CharacteristicName, MonitoringLocationIdentifier) # data frame of unique characteristic-sites
  cat("line586")
  }
  
  char_vec <- unique_df$CharacteristicName
  cat("line588")
  for (v in 1:nrow(unique_df)) { # for each characteristic-site
    dat_df <- plot_dat %>%
      dplyr::filter(CharacteristicName == unique_df$CharacteristicName[v])
    
    trans_y <- ifelse(all(!is.null(trans_log_y), unique_df$CharacteristicName[v] %in% trans_log_y), "log", "identity")
    
    if("MonitoringLocationIdentifier" %in% names(unique_df)) {
      dat_df %<>% 
        dplyr::filter(MonitoringLocationIdentifier == unique_df$MonitoringLocationIdentifier[v])
    }
               
    cat("line592")
    # Shared y-axes range
    yaxes_min_temp = switch(all(fixed_free_y=="fixed", length(unique(unique_df$CharacteristicName)) < 2)+1, min(dat_df$y, dat_df$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE), min(plot_dat$y, plot_dat$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE)) # y axis limits. If only one characteristic name and free_fixed_y=="fixed", calculate y-axis limits from the full plot_dat
    shiny::req(!is.null(yaxes_min_temp))
    yaxes_min = switch((yaxes_min_temp <= 0)+1, 0.9*yaxes_min_temp, yaxes_min_temp - 0.1)
    yaxes_max = switch(all(fixed_free_y=="fixed", length(unique(unique_df$CharacteristicName)) < 2)+1, 1.1*max(dat_df$y, dat_df$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE), 1.1*max(plot_dat$y, plot_dat$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE))
    cat("line1448")
    
    # Set up the plot...
    if(x_nam=="ActivityStartDate") {
      # p_points <- ggplot(data = dat_df %>% plotly::highlight_key(~Yr), aes(x = x, y = y)) + 
      p_points <- ggplot(data = dat_df, aes(x = x, y = y)) +
        scale_x_date(date_breaks = "1 year", date_labels = "%Y", limits = c(xaxes_min, xaxes_max))
    } else { # if seasonal plot, the time unit will be factor class
      dat_df$x <- as.numeric(dat_df$x)
      # p_points <- ggplot(data = dat_df %>% plotly::highlight_key(~Yr), aes(x = x, y = y)) 
      p_points <- ggplot(data = dat_df, aes(x = x, y = y))
      
      # if(x_nam=="DayOfYr") {
      if(x_nam %in% c("DayOfYr", "Wk")) {
        p_points <- p_points +
        # scale_x_continuous(breaks = seq(from = 0, to = 366, by = 20))
        scale_x_continuous(breaks = scales::breaks_pretty())
      } else {
        p_points <- p_points +
          scale_x_continuous(breaks = 1:length(levels(plot_dat$x)), labels = levels(plot_dat$x))
      }
      }
   cat("line1465") 
    # If adding threshold background...
  if(!is.null(thresh_list)) {

    thresh_ID <- paste0(unique_df$CharacteristicName[v], " (", unique(na.omit(dat_df$ResultMeasure.MeasureUnitCode)), ")")
    if(!is.null(thresh_list[[thresh_ID]])) {
    p_points <- FuncAddThresh(v_char = unique_df$CharacteristicName[v], thresh = thresh_list[[thresh_ID]], p = p_points, xlow_temp = switch((x_nam=="ActivityStartDate")+1, 0.5, xaxes_min), xhigh_temp = switch((x_nam=="ActivityStartDate")+1, length(levels(plot_dat$x)) + 0.5, xaxes_max), ylow_temp = yaxes_min, yhigh_temp = yaxes_max)}
  }
    cat("line623")
    # ...if coloring by a categorical characteristic, set up the data...
  if(sel_categ != "none" & !is.null(categ_df)) {
    levs <- unlist(base::strsplit(str_replace_all(categ_df$CategOrder[categ_df$CharacteristicName == sel_categ], "[()]", ""), split="//")) # these are the categorical levels from the category import file--pull from there rather than from data to ensure no levels are omitted just because they were not in the data
    levels_ok <- all(na.exclude(unique(plot_dat$CategResultMeasureValue[plot_dat$CategName == sel_categ])) %in% levs)
    shiny::req(!is.null(levels_ok))
     if(!levels_ok) { # Discontinue if category levels in data don't match levels in imported category file
        showModal(modalDialog(
          title = "Categorical levels mismatch",
          paste0("At least one categorical level found in the data (", paste(sort(na.exclude(unique(plot_dat$CategResultMeasureValue[plot_dat$CategName == sel_categ]))), collapse = ", "), ") is not included in the levels imported from the  category file (", paste(sort(levs), collapse = ", "), "). Please amend the category file to match the data."))
        )}
    dat_df$CategResultMeasureValue <- factor(dat_df$CategResultMeasureValue, levels = levs)
    cols <- unlist(base::strsplit(str_replace_all(categ_df$CategColor[categ_df$CharacteristicName == sel_categ], "[()]", ""), split="//"))
    names(cols) <- levs # create a named color vector to use as palette
 cat("line1488")
    p_points <- p_points +
      suppressWarnings(geom_point(aes(shape = pointShape, color = CategResultMeasureValue, fill = CategResultMeasureValue, text = paste0("Characteristic Set: ", CharacteristicSet, "<br>Monitoring Site: ", MonitoringLocationIdentifier, "<br>Survey Date: ", ActivityStartDate, "<br><br>X-value: ", x, "<br>Parameter Value: ", y, "<br>Detection Level: ", ResultDetectionConditionText, "<br>Categorical Level: ", CategResultMeasureValue)), size = 2, show.legend = c(fill = FALSE, color = TRUE, shape = FALSE))) + # aesthetic text is for ggplotly tooltip. Gives warning that it's not recognized but it still works and it's the only way to also allow geom_smooth (weird)
      scale_fill_manual(values = cols, na.value = "black", drop = FALSE) +
      scale_color_manual(name = paste0(sel_categ, "     "), limits = levs, values = cols, na.value = "black", drop = FALSE) # specifying all possible values in limits is required to make sure they are not dropped from legend when not in data
  } else {

      # ..if combining sites for a single characteristic, so coloring by monitoring site...
      if(rv_param_temp$sel_summarize_by == "by_char" & combine_sites==TRUE) { # if coloring by monitoring site, use viridis color scale
        p_points <- p_points +
          suppressWarnings(geom_point(aes(shape = pointShape, color = MonitoringLocationIdentifier, fill = MonitoringLocationIdentifier, text = paste0("Characteristic Set: ", CharacteristicSet, "<br>Monitoring Site: ", MonitoringLocationIdentifier, "<br>Survey Date: ", ActivityStartDate, "<br><br>X-value: ", x, "<br>Parameter Value: ", y, "<br>Detection Level: ", ResultDetectionConditionText)), size = 2, show.legend = c(fill = FALSE, color = TRUE, shape = FALSE))) + # this will give a false unknown aesthetics warning for 'text'
          scale_fill_viridis_d() +
          scale_color_viridis_d(name = "Site")
      } else { # ...if not coloring the points...
      p_points <- p_points +
        suppressWarnings(geom_point(aes(shape = pointShape, text = paste0("Characteristic Set: ", CharacteristicSet, "<br>Monitoring Site: ", MonitoringLocationIdentifier, "<br>Survey Date: ", ActivityStartDate, "<br><br>X-value: ", x, "<br>Parameter Value: ", y, "<br>Detection Level: ", ResultDetectionConditionText)), size = 2, color = "black", show.legend = FALSE))
      }
  }
  cat("line1506")
  # Shape the points for quantified vs. censored data
    p1_points <- p_points +
      scale_shape_manual(values = c("quant" = 16, "censored" = 1))
  
  # If including censored data...
  if(incl_cens) {
    dat_cens <- subset(dat_df, ResultDetectionConditionText %in% c("Present Below Quantification Limit", "Not Detected", "Present Above Quantification Limit"))
    if(nrow(dat_cens) > 0) {
      dat_cens$segment_start <- dat_cens$segment_end <- NA
      dat_cens$segment_start[dat_cens$ResultDetectionConditionText %in% c("Not Detected", "Present Below Quantification Limit")] <- yaxes_min # left-censored data
      dat_cens$segment_end[dat_cens$ResultDetectionConditionText %in% c("Not Detected", "Present Below Quantification Limit")] <- dat_cens[dat_cens$ResultDetectionConditionText %in% c("Not Detected", "Present Below Quantification Limit"), "DetectionQuantitationLimitMeasure.MeasureValue", drop = TRUE]
      dat_cens$segment_start[dat_cens$ResultDetectionConditionText == "Present Above Quantification Limit"] <- dat_cens[dat_cens$ResultDetectionConditionText == "Present Above Quantification Limit", "DetectionQuantitationLimitMeasure.MeasureValue", drop = TRUE]
      dat_cens$segment_end[dat_cens$ResultDetectionConditionText == "Present Above Quantification Limit"] <- yaxes_max
      p1_points <- p1_points +
        geom_segment(data = dat_cens, aes(x = x, xend = x, y = segment_start, yend = segment_end), linewidth = 0.25, linetype = "dotted")
    }
  }

  cat("line1533")  
    # If adding loess smooth...
  if(add_loess) {
    # If plotting all stations on one plot, color by station
    if(rv_param_temp$sel_summarize_by == "by_char" & combine_sites==TRUE) {
      p1_points <- p1_points + 
        geom_smooth(aes(color = MonitoringLocationIdentifier, fill = MonitoringLocationIdentifier), method = "loess", se = FALSE, size = 0.5, alpha = 0.3, show.legend = FALSE, na.rm = TRUE, fullrange = FALSE) +
        coord_cartesian(ylim = c(c(yaxes_min, yaxes_max)))

      } else {
        p1_points <- p1_points + 
          geom_smooth(method = "loess", se = FALSE, size = 0.5, alpha = 0.3, show.legend = FALSE, na.rm = TRUE, fullrange = FALSE) +
          coord_cartesian(ylim = c(c(yaxes_min, yaxes_max)))
      }
    }
    
    # If plotting percentile lines...
    p1_points <- FuncQuantLines(quant_df = quant_df, combine_sites = combine_sites, dat_df = dat_df, p = p1_points)
cat("line1551")  

  # Final formatting of plots
  p1_points <- p1_points +
    scale_y_continuous(trans = trans_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks(), limits = c(yaxes_min, yaxes_max)) + # alternatively, can use 'coord_cartesian(ylim = c(yaxes_min, yaxes_max))' to zoom in to the limits rather than "cutting off" the limits, as setting limits within scale_y_continuous() would do 
    theme_bw(base_size = 11) +
    {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
    {if(rotate_x) {theme(axis.title.x = element_text(margin = margin(t = 10, r = 0, b = 0, l = 0)))}} +
    theme(axis.title.y = element_blank(),
          legend.position = "top",
          legend.text = element_text(size = 16),
          legend.title = element_text(size = 16))
  
  # Add monitoring site as facet label if separate plot per site
  if(combine_sites==FALSE) { 
    p1_points <- p1_points +
      facet_wrap(. ~ MonitoringLocationIdentifier, drop = TRUE, ncol = 1)
  }
  
  p1_points_list[[v]] <- p1_points
  }
  
  ## If adding streamflow plot... ----
  if(sel_add_gage_precip == "streamflow" & !is.null(gage_dat)) {
    trans_gage_y <- ifelse(all(!is.null(trans_log_y), "streamflow" %in% trans_log_y), "log", "identity")
    
    if(x_nam=="ActivityStartDate") {
      if(month_summary == TRUE) {
        gage_dat <- gage_dat %>%
        dplyr::mutate(x = MnthDate + 14) %>% # plot at mid-point of month (on x-axis) for streamflow time series
        dplyr::group_by(GageName, x) %>%
        dplyr::summarise(MnthMean_MeanDailyDischarge = round(mean(MeanDailyDischarge, na.rm = TRUE), 2), # summarize mean daily discharge for each month
                MnthMax_MeanDailyDischarge = round(max(MeanDailyDischarge, na.rm = TRUE), 2)) %>%
        dplyr::ungroup()
        
        gage_plot <- ggplot(gage_dat, aes(x = x)) +
        suppressWarnings(geom_line(aes(y = MnthMean_MeanDailyDischarge, group = 1, text = paste0("Gage Name: ", GageName, "<br>Mid-month date: ", x, "<br>Mean daily discharge (cfs), MEAN for month: ", MnthMean_MeanDailyDischarge)), linetype = "solid", colour = "blue")) +
        suppressWarnings(geom_line(aes(y = MnthMax_MeanDailyDischarge, group = 1, text = paste0("Gage Name: ", GageName, "<br>Mid-month date: ", x, "<br>Mean daily discharge (cfs), MAX for month: ", MnthMax_MeanDailyDischarge)), linetype = "dashed", colour = "blue")) + # for time series point plots, present data summarized by month
          scale_x_date(date_breaks = "1 year", date_labels = "%Y", limits = c(xaxes_min, xaxes_max))
      } else { # just plot the points
        gage_plot <- ggplot(gage_dat, aes(x = ActivityStartDate, y = MeanDailyDischarge)) +
        suppressWarnings(geom_point(aes(text = paste0("Gage Name: ", GageName, "<br>Survey date: ", ActivityStartDate, "<br><br>Mean daily discharge (cfs): ", MeanDailyDischarge)))) + 
        scale_x_date(date_breaks = "1 year", date_labels = "%Y", limits = c(xaxes_min, xaxes_max))
        
        # If loess smooth and NOT monthly summary...
        if(add_loess) {
          gage_plot <- gage_plot + 
            geom_smooth(method = "loess", se = FALSE, size = 0.5, alpha = 0.3, show.legend = FALSE) +
            coord_cartesian(ylim = c(c(yaxes_min, yaxes_max)))
        } 
        }
    } else { # if seasonal plot...
        gage_dat$x <- as.numeric(gage_dat$x)
        gage_plot <- ggplot(gage_dat, aes(x = x, y = MeanDailyDischarge)) +
          suppressWarnings(geom_point(aes(text = paste0("Gage Name: ", GageName, "<br>Survey date: ", ActivityStartDate, "<br><br>X-value: ", x, "<br>Mean daily discharge (cfs): ", MeanDailyDischarge)), alpha = 0.5))
        
        # if(x_nam=="DayOfYr") {
        if(x_nam %in% c("DayOfYr", "Wk")) {
          gage_plot <- gage_plot +
            # scale_x_continuous(breaks = seq(from = 0, to = 366, by = 20))
            scale_x_continuous(breaks = scales::breaks_pretty())
          } else {
            gage_plot <- gage_plot +
          scale_x_continuous(breaks = 1:length(levels(plot_dat$x)), labels = levels(plot_dat$x))
          }
        
        # If loess smooth...
        if(add_loess) {
          gage_plot <- gage_plot + 
            stat_smooth(se = TRUE, level = 0.95, size = 0.5, alpha = 0.3, show.legend = FALSE)
        }
        }
    
    # Final formatting of streamflow plot...
    gage_plot <- gage_plot +
      scale_y_continuous(trans = trans_gage_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks()) +
        theme_bw(base_size = 11) +
        {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
        theme(axis.title.x = element_blank(),
              axis.title.y = element_blank(),
              legend.position = "none") +
        facet_wrap(. ~ GageName, ncol = 1) + # add the name as facet label
       theme(strip.background = element_rect(fill="lightblue")) # use different color facet strip background to distinguish from water characteristic plots
    } else {
    gage_plot <- NA # blank data frame
    }
  cat("line1642")
   ## If adding precipitation plot... ----
  if(sel_add_gage_precip == "precipitation" & !is.null(precip_dat)) {
    
    trans_precip_y <- ifelse(all(!is.null(trans_log_y), "precipitation" %in% trans_log_y), "log", "identity")
    
    if(x_nam=="ActivityStartDate") {
      if(month_summary == TRUE) {
      precip_dat <- precip_dat %>%
        dplyr::mutate(x = MnthDate + 14) %>% # plot at mid-point of month (on x-axis) for precipitation time series
        dplyr::group_by(MeteoName, x) %>%
        dplyr::summarise(AvgPrecip_cm = round(mean(PRCP_cm, na.rm = TRUE), 2), # summarize precipitation for each month
                MaxPrecip_cm = round(max(PRCP_cm, na.rm = TRUE), 2)) %>%
        dplyr::ungroup()

      precip_plot <- ggplot(precip_dat, aes(x = x)) +
        suppressWarnings(geom_line(aes(y = AvgPrecip_cm, group = 1, text = paste0("Weather Station Name: ", MeteoName, "<br>Mid-month date: ", x, "<br>Daily precipitation (cm), MEAN for month: ", AvgPrecip_cm)), linetype = "solid", colour = "blue")) +
        suppressWarnings(geom_line(aes(y = MaxPrecip_cm, group = 1, text = paste0("Weather Station Name: ", MeteoName, "<br>Mid-month date: ", x, "<br>Daily precipitation (cm), MAX for month: ", MaxPrecip_cm)), linetype = "dashed", colour = "blue")) + # for time series point plots, present data summarized by month
        scale_x_date(date_breaks = "1 year", date_labels = "%Y", limits = c(xaxes_min, xaxes_max))
      } else { # just plot the points
      precip_plot <- ggplot(precip_dat, aes(x = ActivityStartDate, y = PRCP_cm)) +
        suppressWarnings(geom_point(aes(text = paste0("Weather Station Name: ", MeteoName, "<br>Survey date: ", ActivityStartDate, "<br><br>Daily precipitation (cm): ", PRCP_cm)))) + 
        scale_x_date(date_breaks = "1 year", date_labels = "%Y", limits = c(xaxes_min, xaxes_max))
      
      # If loess smooth and NOT monthly summary...
      if(add_loess) {
        precip_plot <- precip_plot + 
          geom_smooth(method = "loess", se = FALSE, size = 0.5, alpha = 0.3, show.legend = FALSE)
      } 
      }
      } else { # if seasonal plot...
        precip_dat$x <- as.numeric(precip_dat$x)
        precip_plot <- ggplot(precip_dat, aes(x = x, y = PRCP_cm)) +
          suppressWarnings(geom_point(aes(text = paste0("Weather Station Name: ", MeteoName, "<br>Survey date: ", ActivityStartDate, "<br><br>X-value: ", x, "<br>Daily precipitation (cm)): ", PRCP_cm)), alpha = 0.5))
        
        # if(x_nam=="DayOfYr") {
                if(x_nam %in% c("DayOfYr", "Wk")) {
          precip_plot <- precip_plot +
            # scale_x_continuous(breaks = seq(from = 0, to = 366, by = 20))
            scale_x_continuous(breaks = scales::breaks_pretty())
          } else {
            precip_plot <- precip_plot +
              scale_x_continuous(breaks = 1:length(levels(plot_dat$x)), labels = levels(plot_dat$x))
          }
    
    # If loess smooth...
    if(add_loess) {
      precip_plot <- precip_plot +
        geom_smooth(method = "loess", se = FALSE, size = 0.5, alpha = 0.3, show.legend = FALSE)
    }
  }
    
    # Final formatting of precipitation plot...
    precip_plot <- precip_plot +
      scale_y_continuous(trans = trans_precip_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks()) +
        theme_bw(base_size = 11) +
        {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
        theme(axis.title.x = element_blank(),
              axis.title.y = element_blank(),
              legend.position = "none") +
        facet_wrap(. ~ MeteoName, ncol = 1) + # add the name as facet label
       theme(strip.background = element_rect(fill="lightblue")) # use different color facet strip background to distinguish from water characteristic plots
    } else {
    precip_plot <- NA # blank data frame
  }
  cat("line1712")
  return_list <- list(p1_points_list, char_vec, gage_plot, precip_plot)
  return(return_list)
}

FuncPlotBox <- function(plot_dat, quant_df = NULL, x_nam = "Yr", combine_sites = FALSE, fixed_free_y = "fixed", add_loess = TRUE, incl_cens = FALSE, thresh_list = NULL, rotate_x = FALSE, gage_dat = NULL, precip_dat = NULL, sel_add_gage_precip = switch(is.null(rv_param_temp$sel_add_gage_precip)+1, rv_param_temp$sel_add_gage_precip, "none"), trans_log_y) {
  # Function to generate boxplots of data, with reporting limits marked as dotted horizontal lines
  #
  # Args:
  #   plot_dat:  A data frame with the raw data
  #   quant_df:  A data frame with quantile probability limits for each station
  #   x_nam: Column name for x-axis variable. For time series, this is "Yr"
  #   combine_sites:  TRUE to combine multiple stations in a single plot of a characteristic
  #   fixed_free_y:  Are scales fixed or free across all facets?
  #   incl_cens: Should reporting limits be marked as dotted horizontal lines?
  #   thresh_list: NULL or the list for threshold background colors
  #   rotate_x: should x-axis labels be rotated?
  #   gage_dat: USGS gage station data, if streamflow plot should be included: otherwise, NULL
  #   precip_dat: weather station data, if precipitation plot should be included; otherwise, NULL
  #   
  # Returns:
  #   List of boxplots
  # 
  
  shiny::req(sum(!is.na(plot_dat$y)) > 0) # make sure there are data
  
  # Create the water quality plot(s)
  p1_box_list <- list()
  
  if(rv_param_temp$sel_summarize_by == "by_char" & combine_sites==TRUE) {
    unique_df <- plot_dat %>% dplyr::select(CharacteristicName) %>% dplyr::distinct()
  } else {
    unique_df <- plot_dat %>% expand(CharacteristicName, MonitoringLocationIdentifier) %>% arrange(CharacteristicName, MonitoringLocationIdentifier) # data frame of unique characteristic-sites
  }
  
  char_vec <- unique_df$CharacteristicName
  
  for (v in 1:nrow(unique_df)) { # for each characteristic-site
    dat_df <- plot_dat %>%
      dplyr::filter(CharacteristicName == unique_df$CharacteristicName[v])
    
    trans_y <- ifelse(all(!is.null(trans_log_y), unique_df$CharacteristicName[v] %in% trans_log_y), "log", "identity")
    
    if("MonitoringLocationIdentifier" %in% names(unique_df)) {
      dat_df %<>% 
        dplyr::filter(MonitoringLocationIdentifier == unique_df$MonitoringLocationIdentifier[v])
    }
  
  # Thresholds for detection limits--draw these lines on plot, if within the range of y axes
  y_upperQL <- ifelse(any(!is.na(dat_df$DetectionQuantitationLimitMeasure.MeasureValue[dat_df$ResultDetectionConditionText == "Present Above Quantification Limit"])),  min(dat_df$DetectionQuantitationLimitMeasure.MeasureValue[dat_df$ResultDetectionConditionText == "Present Above Quantification Limit"], na.rm = TRUE), NA) # lowest upper quantification limit -- These may change through time, and we are only going to show the most conservative value 
  
  y_lowerQL <- ifelse(any(!is.na(dat_df$DetectionQuantitationLimitMeasure.MeasureValue[dat_df$ResultDetectionConditionText %in% c("Not Detected", "Present Below Quantification Limit")])), max(dat_df$DetectionQuantitationLimitMeasure.MeasureValue[dat_df$ResultDetectionConditionText %in% c("Not Detected", "Present Below Quantification Limit")], na.rm = TRUE), NA) # highest lower quantification limit

  # Shared y-axes range
  yaxes_min_temp = switch((fixed_free_y=="fixed" & length(unique(unique_df$CharacteristicName)) < 2)+1, min(dat_df$y, dat_df$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE), min(plot_dat$y, plot_dat$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE)) # y axis limits. If only one characteristic name and free_fixed_y=="fixed", calculate y-axis limits from the full plot_dat
  yaxes_min = ifelse(yaxes_min_temp <= 0, yaxes_min_temp - 0.1, 0.9*yaxes_min_temp)
  yaxes_max = switch((fixed_free_y=="fixed" & length(unique(unique_df$CharacteristicName)) < 2)+1, 1.1*max(dat_df$y, dat_df$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE), 1.1*max(plot_dat$y, plot_dat$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE))
  
  # Set up the plot..
  p_box <- ggplot(data = dat_df, aes(x = x, y = y)) 
  
  # if(x_nam=="DayOfYr") {
  if(x_nam %in% c("DayOfYr", "Wk")) {
    p_box <- p_box +
      # scale_x_discrete(breaks = seq(from = 0, to = 366, by = 20))
    scale_x_discrete(breaks = scales::breaks_pretty())
  } else {
    p_box <- p_box +
      scale_x_discrete(drop = FALSE)
  }
  
  # If adding threshold background...
  if(!is.null(thresh_list)) {
    
    thresh_ID <- paste0(unique_df$CharacteristicName[v], " (", unique(na.omit(dat_df$ResultMeasure.MeasureUnitCode)), ")")
    if(!is.null(thresh_list[[thresh_ID]])) {
      
    p_box <- FuncAddThresh(v_char = unique_df$CharacteristicName[v], thresh = thresh_list[[thresh_ID]], p = p_box, xlow_temp = 0.5, xhigh_temp = length(levels(plot_dat$x)) + 0.5, ylow_temp = yaxes_min, yhigh_temp = yaxes_max)
    }
    }
    
  # If combining sites for a single characteristic, so coloring by monitoring site...
  if(rv_param_temp$sel_summarize_by == "by_char" & combine_sites==TRUE) { # if coloring by monitoring site, use viridis color scale
    p1_box <- p_box +
      geom_boxplot(aes(fill = MonitoringLocationIdentifier), alpha = 0.4, show.legend = c(fill = TRUE)) +
      scale_fill_viridis_d(name = "Site") + 
      guides(fill = guide_legend(direction = "horizontal")) # can't seem to turn legend horizontal with theme(legend...)
    } else {
      p1_box <- p_box + geom_boxplot()
    }
  
  # If including censored data...
  if(incl_cens) {
    if(!is.na(y_lowerQL) & y_lowerQL >= yaxes_min) { # add LQL line
      p1_box <- p1_box +
        geom_hline(yintercept = y_lowerQL, linetype = "dotted", color = "gray")
      }
    if(!is.na(y_upperQL) & y_upperQL <= yaxes_max) { # add UQL line
      p1_box <- p1_box +
        geom_hline(yintercept = y_upperQL, linetype = "dotted", color = "black")
    }
    }
  
  # If plotting percentile lines...
  p1_box <- FuncQuantLines(quant_df = quant_df, combine_sites = combine_sites, dat_df = dat_df, p = p1_box)
  
  # Final formatting of plots
  
  p1_box <- p1_box +
    scale_y_continuous(trans = trans_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks(), limits = c(yaxes_min, yaxes_max))  +
    theme_bw(base_size = 11) +
    {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
    {if(rotate_x) {theme(axis.title.x = element_text(margin = margin(t = 10, r = 0, b = 0, l = 0)))}} +
    theme(axis.title.y = element_blank())
  
  # Add monitoring site as facet label if separate plot per site
  if(combine_sites==FALSE) {
    p1_box <- p1_box +
      facet_wrap(. ~ MonitoringLocationIdentifier, drop = TRUE, ncol = 1)
    }
  
  p1_box_list[[v]] <- p1_box
  }
  
  # If adding streamflow plot...
  if(sel_add_gage_precip == "streamflow" & !is.null(gage_dat)) {
    trans_gage_y <- ifelse(all(!is.null(trans_log_y), "streamflow" %in% trans_log_y), "log", "identity")
    
    gage_box <- ggplot(gage_dat, aes(x = x, y = MeanDailyDischarge)) + 
      geom_boxplot() +
      {if(x_nam == "DayOfYr") {scale_x_discrete(breaks = seq(from = 0, to = 366, by = 20))} else {scale_x_discrete(drop = FALSE)}} +
      scale_y_continuous(trans = trans_gage_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks()) +
      theme_bw(base_size = 11) +
      {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
      theme(axis.title.x = element_blank(),
            axis.title.y = element_blank(),
            legend.position = "none") +
      facet_wrap(. ~ GageName, ncol = 1) + # add the name as facet label
      theme(strip.background = element_rect(fill="lightblue"))
    } else {
      gage_box <- NA # blank data frame
    }
  
  # If adding precipitation plot...
  if(sel_add_gage_precip == "precipitation" & !is.null(precip_dat)) {
    
    trans_precip_y <- ifelse(all(!is.null(trans_log_y), "precipitation" %in% trans_log_y), "log", "identity")
    
    precip_box <- ggplot(precip_dat, aes(x = x, y = PRCP_cm)) + 
      geom_boxplot() +
      {if(x_nam == "DayOfYr") {scale_x_discrete(breaks = seq(from = 0, to = 366, by = 20))} else {scale_x_discrete(drop = FALSE)}} +
      scale_y_continuous(trans = trans_precip_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks()) +
      theme_bw(base_size = 11) +
      {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
      theme(axis.title.x = element_blank(),
            axis.title.y = element_blank(),
            legend.position = "none") +
      facet_wrap(. ~ MeteoName, ncol = 1) + # add the name as facet label
      theme(strip.background = element_rect(fill="lightblue"))
    } else {
      precip_box <- NA # blank data frame
    }
  
  return_list <- list(p1_box_list, char_vec, gage_box, precip_box)
  return(return_list)
}
  
FuncPlotlyPieMatrix <- function(dat, discrete_cols, discrete_levels, plot_title) {
  # Function to create plotly pie chart matrix of Threshold or Percentile categories, grouped by monitoring site (row) and year (col)
  #
  # Args:
  #   dat:  Plot data with percentile/threshold classifications
  #   discrete_cols: For discrete fill, the vector of colors
  #   discrete_levels: For discrete fill, the levels corresponding with colors
  #   plot_title: Title for plot page
  #
  # Returns:
  #   Page of plotly pie charts
  #
  fig <- plot_ly(textfont = list(size = 25))
  colors_list <- split(discrete_cols, discrete_levels)
  m <- list(
    l = 300,
    r = 90,
    b = 100,
    t = 100,
    pad = 0
  )
  
  dat$Color <- dplyr::recode(dat$CategVar, !!!colors_list)
  yr_vec <- seq(from = min(dat$Yr, na.rm = TRUE), to = max(dat$Yr, na.rm = TRUE), by = 1)
  
  
  for(row_num in 1:length(unique(dat$RowLev))) {
    row_filter <- sort(unique(dat$RowLev))[row_num]
    for(yr_num in 1:length(yr_vec)) {
      this_yr <- yr_vec[yr_num]
      pie_dat = subset(dat, RowLev == row_filter & Yr == this_yr)
      if(nrow(pie_dat)>0) {  
      fig <- fig %>% 
        add_pie(data = pie_dat,
                name = paste0(row_filter, "_", this_yr),
                labels = ~CategVar, 
                values = ~n,
                textposition = 'inside',
                textinfo = 'label+percent',
                insidetextfont = list(color = switch(("yellow" %in% discrete_cols)+1, "white", "black")),
                hoverinfo = 'text',
                text = ~HoverLabel,
                marker = list(colors = ~Color, line = list(color = '#FFFFFF', width = 1)),
                domain = list(row = row_num-1, column = yr_num-1))
    }
  }
  }
  
  width_px <- 390 + (85 * length(yr_vec)) # this is the plot width (paper). The plot value used to be 110 (not 85)
  height_px <- 200 + (85 * length(unique(dat$RowLev))) # this is the plot height (paper)

  yr_seq_px <- seq(55, width_px-390, by = 85)/(85 * length(yr_vec)) # this is where year labels should align on x-axis, when reference is "paper"
  y_seq_px <- seq(55, height_px-55, length.out = length(unique(dat$RowLev)))/height_px
  title_loc <- 1 + (90/height_px) #it's into the top margin space, when reference is "container"
  legend_loc <- 1 + (50/height_px)
  yrs_loc_bottom <- -1 * (50/height_px)
  
  yr_labels_bottom <- list(
  text = as.list(as.character(yr_vec)),
  xref = "paper",
  yref = "container",
  yanchor = "center",
  xanchor = "center",
  font =list(size = 14),
  align = "right",
  x = yr_seq_px,
  y = yrs_loc_bottom,
  showarrow = FALSE)
  
  y_labels_left <- list(
    text = as.list(sort(unique(dat$RowLev), decreasing = TRUE)),
    xref = "paper",
    yref = "paper",
    xanchor = "right",
    yanchor = "center",
    font =list(size = 14),
    align = "center",
    x = -0.02,
    y = y_seq_px,
    showarrow = FALSE)
  
  fig_final <- fig %>% layout(
    margin = m,
    title = list(
      text = plot_title,
      x = 0.5,
      y = title_loc,
      xref = "container", # gets cut off if referenced to the plot only ("paper")
      yref = "paper",
      xanchor = "center",
      yanchor = "center"),
    showlegend = TRUE,
    legend = list(
      orientation = "h",
      x = 0.5,
      xref = "container",
      yref = "paper",
      xanchor = "center",
      y = legend_loc,
      yanchor = "center"),
    grid=list(
      rows=length(unique(dat$RowLev)),
      columns=length(yr_vec)),
    width = width_px,
    height = height_px,
    autosize = FALSE,
    annotations = y_labels_left) 
  
  fig_final <- fig_final %>% layout(annotations = yr_labels_bottom)

  fig_final
  return(fig_final)
}

FuncCustomSeasons <- function(dat_df, seas) {
  # Function to assign USGS water year or custom seasons to ActivityStartDate
  #
  # Args:
  #   dat_df:  A data frame to modify. One column needs to be ActivityStartDate, which is date class with format yyyy-mm-dd
  #   seas: character string, "WaterSeasons" or "CustomSeasons"
  #
  dat_df$Season <- NA
  # assign the custom season names based on dates. Can't just use cut, in case the seasons aren't consecutive
  if(seas == "WaterSeasons") {
    df_CustomSeason <- data.frame(
      Name = c("Fall(WY)", "Winter(WY)", "Spring(WY)", "Summer(WY)"),
      RangeStart = as.Date("2018-01-01")-1 + c(274, 1, 91, 182),
      RangeEnd = as.Date("2018-01-01")-1 + c(265, 90, 181, 273))
  }
  if(seas == "CustomSeasons") {
    df_CustomSeason <- data.frame(
      Name = c(input$sel_Season1Name, input$sel_Season2Name, input$sel_Season3Name, input$sel_Season4Name),
      RangeStart = c(input$sel_Season1Range[1], input$sel_Season2Range[1], input$sel_Season3Range[1], input$sel_Season4Range[1]),
      RangeEnd = c(input$sel_Season1Range[2], input$sel_Season2Range[2], input$sel_Season3Range[2], input$sel_Season4Range[2]))
  }
  
  df_CustomSeason <- df_CustomSeason[df_CustomSeason$Name != "",] # if no name assigned, then it's not a season level
  for(i in 1:nrow(df_CustomSeason)) {
    Name <- df_CustomSeason$Name[i]
    StartDate <- lubridate::yday(df_CustomSeason$RangeStart[i])
    StartDate_LY <- lubridate::yday(gsub("^.{1,4}", "2000", df_CustomSeason$RangeStart[i])) # yday count is different for leap years
    EndDate <- lubridate::yday(df_CustomSeason$RangeEnd[i])
    EndDate_LY <- lubridate::yday(gsub("^.{1,4}", "2000", df_CustomSeason$RangeEnd[i])) # yday count is different for leap years
    
    
    if(StartDate < EndDate) {
      # for leap year
      dat_df$Season[lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) >= StartDate_LY & lubridate::yday(dat_df$ActivityStartDate) <= EndDate_LY] <- Name
      # for not leap year
      dat_df$Season[!lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) >= StartDate & lubridate::yday(dat_df$ActivityStartDate) <= EndDate] <- Name
    } else { # start yday is larger than end yday, it means it spans Dec 31-Jan 1
      # for leap year
      dat_df$Season[lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) >= StartDate_LY] <- Name
      dat_df$Season[lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) <= EndDate_LY] <- Name
      # for not leap year
      dat_df$Season[!lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) >= StartDate] <- Name
      dat_df$Season[!lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) <= EndDate] <- Name
    }
  }
  
  dat_df$Season <- factor(dat_df$Season, levels = df_CustomSeason$Name)
  return(dat_df)
}

FuncPlotPage <- function(plot_type, plot_dat, quant_dat, time_unit, free_y, categLevelsPlot = rv_param_temp$categLevelsPlot, sel_add_gage_precip = switch(is.null(rv_param_temp$sel_add_gage_precip)+1, rv_param_temp$sel_add_gage_precip, "none"), sel_combine_sites, sel_plot_ht = switch(is.null(input$sel_PlotHt)+1, input$sel_PlotHt, 280), trans_log_y) {
  sel_categ = switch(is.null(input$sel_Categ)+1, input$sel_Categ, "none")
 
  plot_dat <- isolate(plot_dat)
# Includes censored data
    incl_cens <- any(c("Present Below Quantification Limit", "Not Detected", "Present Above Quantification Limit") %in% unique(plot_dat$ResultDetectionConditionText)) # TRUE if there are any reporting limits
  
    if(time_unit == "ActivityStartDate" & plot_type == "box") {time_unit <- "Yr"} # Box plots for time series are grouped by year
    
    thresh_list <- switch(rv_param_temp$sel_show_thresholds,
                          showthresh_file = rv_param_temp$threshList,
                          showthresh_custom = rv_param_temp$threshCustom,
                          showthresh_none = NULL)
    
      plot_dat$x <- plot_dat[[time_unit]]
      plot_dat$y <- round(plot_dat[["ResultMeasureValue_replaced"]], 2)
      shiny::req(sum(!is.na(plot_dat$y)) > 0) # make sure there are data!
      
      # If adding streamflow data...
        if(any(sel_add_gage_precip!="streamflow", is.null(rv_param_temp$sel_gage_station), is.null(rv$gagesDat), is.null(rv$selectedGages))) {
          gageDat <- NULL
          gage_YScale <- NULL
        } else {
          gageDat <- FuncGageDat(gage_station = rv_param_temp$sel_gage_station)
          if(!is.null(gageDat)) {
            gage_YScale <- rv_param_temp$sel_gage_yscale
            } else {
              gage_YScale <- NULL
            }
        }
      # If adding precipitation data...
        if(any(sel_add_gage_precip!="precipitation", is.null(rv_param_temp$sel_precip_station), is.null(rv$meteoDat), is.null(rv$selectedMeteo))) {
          precipDat <- NULL
          precip_YScale <- NULL
        } else {
          precipDat <- FuncPrecipDat(precip_station = rv_param_temp$sel_precip_station)
          precip_YScale <- rv_param_temp$sel_precip_yscale
        }
      
      cat("line1898")
      # For seasonal patterns...
      if(time_unit != "ActivityStartDate") {
        xseq = switch(time_unit,
                      Yr = seq(min(as.numeric(as.character(plot_dat$x)), na.rm = TRUE), max(as.numeric(as.character(plot_dat$x)), na.rm = TRUE), by = 1), # this is only for time series boxplots
                      Season = levels(plot_dat$Season), # c("Spring", "Summer", "Fall", "Winter"),
                      Mnth = levels(plot_dat$Mnth),
                      Wk = 1:53,
                      DayOfYr = 1:366 # account for leap year
                      )

        plot_dat$x <- factor(plot_dat$x, levels = xseq, labels = xseq)
        if(!is.null(gageDat)) {
          gageDat$x <- factor(gageDat[[time_unit]], levels = xseq, labels = xseq)
        }
        
        if(!is.null(precipDat)) {
          precipDat$x <- factor(precipDat[[time_unit]], levels = xseq, labels = xseq)
        }
      }
      if(!is.null(input$sel_PlotType)) {
        month_summary <- all(sel_add_gage_precip != "none", input$sel_PlotType %in% c("points", "points_smooth"))
      } else {
        month_summary <- FALSE
      }
  cat("line1921")
    if(plot_type %in% c("points", "points_smooth")) {

      ts_plot <- FuncPlotScatter(plot_dat = plot_dat, quant_df = quant_dat, categ_df = categLevelsPlot, x_nam = time_unit, combine_sites = ifelse(length(unique(plot_dat$CharacteristicName)) == 1, ifelse(sel_combine_sites, TRUE, FALSE), FALSE), fixed_free_y = ifelse(free_y, "free_y", "fixed"), add_loess = ifelse(plot_type == "points_smooth", TRUE, FALSE), incl_cens = incl_cens, thresh_list = thresh_list, rotate_x = TRUE, gage_dat = gageDat, precip_dat = precipDat, month_summary = month_summary, sel_categ = sel_categ, trans_log_y = trans_log_y)}

    if(plot_type == "box") {
      ts_plot <- FuncPlotBox(plot_dat = plot_dat, quant_df = quant_dat, x_nam = time_unit, combine_sites = ifelse(length(unique(plot_dat$CharacteristicName)) == 1, ifelse(sel_combine_sites, TRUE, FALSE), FALSE), fixed_free_y = ifelse(free_y, "free_y", "fixed"), incl_cens = incl_cens, thresh_list = thresh_list, rotate_x = TRUE, gage_dat = gageDat, precip_dat = precipDat, trans_log_y = trans_log_y)}

    # PUT THE PLOTS TOGETHER
cat("line1930")
    shiny::req(!is.null(ts_plot[[1]]))

    # Get the shared legend if it exists - getting shared legends to format properly with plotly is a PITB. Tried following many stackexchange suggestions, with no success.
      if(!is.null(get_legend(ts_plot[[1]][[1]]))) {
      shared_legend <- ggpubr::as_ggplot(get_legend(ts_plot[[1]][[1]])) # if a legend exists, extract it
    } else {
      shared_legend <- NULL
    }

    plot_ht <- sel_plot_ht # 340
    total_plot_height <- 64 + plot_ht * (length(ts_plot[[1]]) + as.integer(sel_add_gage_precip!="none")) # Final plot will take the layout of the first plot, so the first plot needs to have the height of final plot. Initially tried to account for x_axis height, but seems it was probably already adjusted for

    # First, the parameter plots
    param_plotly <- FuncPlotlyFormat(
      plotly_list = ts_plot[[1]],
      plotly_title = paste0("Data for ",  switch((length(unique(plot_dat$MonitoringLocationIdentifier)) > 1)+1, unique(plot_dat$MonitoringLocationIdentifier), "multiple sites"), ":  ", switch((length(unique(plot_dat$CharacteristicName)) > 1) + 1, unique(plot_dat$CharacteristicName), "multiple water characteristics"), " (", min(plot_dat$Yr, na.rm = TRUE), " to ", max(plot_dat$Yr, na.rm = TRUE), ") <br>"),
      xlab = switch(time_unit, ActivityStartDate = "Survey Date (time series)", DayOfYr = "Day", Wk = "Week", Mnth = "Month", Season = "Season"),
      ylab_vec = ts_plot[[2]],
      total_height = total_plot_height,
      is_grouped_boxplots = (plot_type == "box" & length(unique(plot_dat$CharacteristicName)) == 1 & length(unique(plot_dat$MonitoringLocationIdentifier)) > 1 & sel_combine_sites == TRUE) # boxplots for multiple stations, all combined in a single plot
    ) 
      
    # If there is a streamflow plot, add that in
    if(sel_add_gage_precip == "streamflow" & !is.null(gageDat) & "ggplot" %in% class(ts_plot[[3]])) {

  extra_plotly <- FuncPlotlyFormat(
    plotly_list = list(Streamflow = ts_plot[[3]]),
    plotly_title = "Mean Daily Discharge",
    xlab = switch(time_unit, ActivityStartDate = "Survey Date (time series)", DayOfYr = "Day of Year", Wk = "Week of Year", Mnth = "Month of Year", Season = "Season of Year"),
    ylab_vec = c("Mean Daily Discharge (cfs)"),
    total_height = total_plot_height,
    is_grouped_boxplots = FALSE
  )
}

  # If there is a precipitation plot, add that in
if(sel_add_gage_precip == "precipitation" & !is.null(precipDat) & "ggplot" %in% class(ts_plot[[4]])) {
 
  extra_plotly <- FuncPlotlyFormat(
    plotly_list = list(Precipitation = ts_plot[[4]]),
    plotly_title = "Precipitation",
    xlab = switch(time_unit, ActivityStartDate = "Survey Date (time series)", DayOfYr = "Day of Year", Wk = "Week of Year", Mnth = "Month of Year", Season = "Season of Year"),
    ylab_vec = c("Precip (cm)"),
    total_height = total_plot_height,
    is_grouped_boxplots = FALSE
  )
}
    cat("line1978")
    shiny::req(!is.null(param_plotly))
      
      if(exists("extra_plotly")) {
        subplot_list <- c(param_plotly, extra_plotly)
        n_plots <- length(ts_plot[[1]])+1
        } else {
          subplot_list <- param_plotly
      n_plots <- length(ts_plot[[1]])
        }

      shiny::req(!is.null(subplot_list))
      plotly_page <-
      subplot(subplot_list,
              nrows = n_plots, # add 1 for precip plot
              shareX = TRUE, # if set to FALSE, the X-axis labels will appear but will be cut off unless margin is increased. If margin is increased, plot sizes will be uneven
              shareY = FALSE,
              titleX = TRUE,
              titleY = TRUE,
              margin = c(0, 0.0, 0.02/length(subplot_list), 0.14/length(subplot_list)),
              which_layout = 1)
      return_list <- list(plotly_page = plotly_page, shared_legend = shared_legend)
    # return(plotly_page)
      return(return_list)
}

FuncPieDat <- function(limit_type) {
  shiny::req(sum(!is.na(rv_param_temp$plotDat[limit_type])) > 0)
    
    if(rv_param_temp$sel_summarize_by=="by_char") {
      temp_pie_dat <- rv_param_temp$plotDat %>%
        dplyr::filter(!is.na(get(limit_type))) %>%
        group_by(MonitoringLocationIdentifier, Yr) %>%
        summarise(N = n()) %>%
        left_join(rv_param_temp$plotDat %>%
                    dplyr::rename("CategVar" = limit_type) %>%
                    group_by(MonitoringLocationIdentifier, Yr) %>%
                    dplyr::count(CategVar), by = c("MonitoringLocationIdentifier", "Yr")) %>%
        dplyr::rename(RowLev = MonitoringLocationIdentifier) 
    } else {
      temp_pie_dat <- rv_param_temp$plotDat %>%
        dplyr::filter(!is.na(get(limit_type))) %>%
        group_by(CharacteristicName, Yr) %>%
        summarise(N = n()) %>%
        left_join(rv_param_temp$plotDat %>%
                    dplyr::rename("CategVar" = limit_type) %>%
                    group_by(CharacteristicName, Yr) %>%
                    dplyr::count(CategVar), by = c("CharacteristicName", "Yr")) %>%
        dplyr::rename(RowLev = CharacteristicName) 
    }
    temp_pie_dat %<>%
      dplyr::mutate(HoverLabel = paste0(RowLev, "<br>", rv_param_temp$seasonType, ": ", Yr, "<br>LEVEL: ", CategVar, "<br>COUNT: ", n, " out of N = ", N))
    return(temp_pie_dat)
}

FuncClearAll <- function() {
  rv <- reactiveValues(wqp_url = NULL, parkID = NULL, unitPoly = NULL, HUC10 = NULL, HUC12 = NULL, sitesPointsSub = NULL, meteoStations = NULL, selectedMeteo = NULL, meteoDat = NULL, facilitiesPointsSub = NULL, selectedHucs = NULL, selectedStations = NULL, selectedOriginStation = NULL, selectedUpstreamStations = NULL, selectedDownstreamStations = NULL, selectedUpstreamLines = NULL, selectedDownstreamLines = NULL, orgs = NULL, gageStations = NULL, selectedGages = NULL, gagesDat = NULL, dat = NULL, userSelect = list())
  
  rv_param_temp <- reactiveValues(loadMap = FALSE, resetFilter = FALSE, newImport = NULL, palOrg = NULL, selectParam = NULL, N_plotly_page = NULL, subDat = NULL, subDatTypes = NULL, subDatYears = NULL, filterNPlot = NULL, showStations = NULL, showCharSets = NULL, sel_summarize_by = NULL, sel_add_gage_precip = NULL, sel_gage_station = NULL, sel_gage_yscale = NULL, sel_precip_station = NULL, sel_precip_yscale = NULL, plotDat = NULL, quantDat = NULL, finalPlot = list(plotly_page = NULL, shared_legend = NULL), seasonalPlot = list(plotly_page = NULL, shared_legend = NULL), plotSummary = NULL, precipDat = NULL, categLevels = NULL, categLevelsPlot = NULL, categLevelsImport = NULL, threshList = NULL, threshCustom = NULL, sel_show_thresholds = NULL, percCateg= NULL, showDM = FALSE, seasonType = NULL, param_map_highlight = NULL, update_from_sidebar = NULL)# <<<<<<<<<<< ADDED STUFF
  
  # Hide filter wellPanels
  restart_panels_filter <- c("new_data_P1", "new_data_P2", "new_data_P3", "new_data_P4", "create_categfile_P1", "create_categfile_P2", "create_categfile_P3") # "wp_filter_yr_season", "wp_filter_sampling_chars", "wp_filter_org", "wp_filter_wqchar",
  lapply(restart_panels_filter, FUN = function(x) shinyjs::hideElement(x))
  
  # Update inputs
  FuncUpdateHome()
  FuncUpdateInputsOther()
}

FuncParamAvailSites <- function(sel) {
  shiny::req(!is.null(rv$sitesPointsSub), !is.null(rv_param_temp$subDat))
    cat("FUNCPARAMAVAILSITES")
  if(sel == "by_station") {
    avail_sites <- rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier %in% unique(rv_param_temp$subDat$MonitoringLocationIdentifier),]
  } 
  if(sel == "by_char") {
    shiny::req(!is.null(input$sel_ShowChar))
    avail_sites <- rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier %in% unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowChar]),]
    
  }
    cat("LEAVING FUNCPARAMAVILSITES\n")
    return(avail_sites)
}
```

```{r startup}

rv <- reactiveValues(wqp_url = NULL, parkID = NULL, unitPoly = NULL, HUC10 = NULL, HUC12 = NULL, sitesPointsSub = NULL, meteoStations = NULL, selectedMeteo = NULL, meteoDat = NULL, facilitiesPointsSub = NULL, selectedHucs = NULL, selectedStations = NULL, selectedOriginStation = NULL, selectedUpstreamStations = NULL, selectedDownstreamStations = NULL, selectedUpstreamLines = NULL, selectedDownstreamLines = NULL, orgs = NULL, gageStations = NULL, selectedGages = NULL, gagesDat = NULL, dat = NULL, userSelect = list())
  
rv_param_temp <- reactiveValues(loadMap = FALSE, resetFilter = FALSE, newImport = NULL, palOrg = NULL, selectParam = NULL, N_plotly_page = NULL, subDat = NULL, subDatTypes = NULL, subDatYears = NULL, filterNPlot = NULL, showStations = NULL, showCharSets = NULL, sel_summarize_by = NULL, sel_add_gage_precip = NULL, sel_gage_station = NULL, sel_gage_yscale = NULL, sel_precip_station = NULL, sel_precip_yscale = NULL, plotDat = NULL, quantDat = NULL, finalPlot = list(plotly_page = NULL, shared_legend = NULL), seasonalPlot = list(plotly_page = NULL, shared_legend = NULL), plotSummary = NULL, precipDat = NULL, categLevels = NULL, categLevelsPlot = NULL, categLevelsImport = NULL, threshList = NULL, threshCustom = NULL, sel_show_thresholds = NULL, percCateg= NULL, showDM = FALSE, trendDat = NULL, MK = NULL, MKHeatPlots = NULL, seasonType = NULL, param_map_highlight = NULL, update_from_sidebar = NULL) # <<<<<<<<<<< ADDED STUFF

load_rv_param_temp <- readRDS("C:/Users/echeng/Desktop/WQdash_public/TEMP_rv_param_temp.RDS")
load_rv <- readRDS("C:/Users/echeng/Desktop/WQdash_public/TEMP_rv.RDS")

for(i in names(load_rv)) {
      rv[[i]] <- load_rv[[i]] # load the data in the dashboard
}

for(i in names(load_rv_param_temp)) {
      rv_param_temp[[i]] <- load_rv_param_temp[[i]] # load the data in the dashboard
}


```
  
```{r events_plots_page}

# Action to select all parameters for filter----
observeEvent(eventExpr = input$button_allSummaryParam, {
  # shiny::req(!is.null(rv$dat), !is.null(input$sel_NPSparam), !is.null(input$sel_YrRange), !is.null(input$sel_SummaryOrg), !is.null(input$sel_ActivityType), !is.null(input$sel_ResultStatus), !is.null(input$sel_MinYrs), !is.null(input$sel_MinStations))
  
  shiny::req(!is.null(rv_param_temp$selectParam))

  updateCheckboxGroupInput(session,
                           "sel_SummaryParam",
                           # label = h6("Water quality characteristics to summarize: "),
                           # choices = sort(rv_param_temp$selectParam),
                           selected = sort(rv_param_temp$selectParam))
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select no parameters for filter ----
observeEvent(eventExpr = input$button_noSummaryParam, {
  # shiny::req(!is.null(rv$dat), !is.null(input$sel_NPSparam), !is.null(input$sel_YrRange), !is.null(input$sel_SummaryOrg), !is.null(input$sel_ActivityType), !is.null(input$sel_ResultStatus), !is.null(input$sel_MinYrs), !is.null(input$sel_MinStations))
  
  shiny::req(!is.null(rv_param_temp$selectParam))

  updateCheckboxGroupInput(session,
                           "sel_SummaryParam",
                           # label = h6("Water quality characteristics to summarize: "),
                           # choices = sort(rv_param_temp$selectParam),
                           selected = character(0))
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select all stations ----
observeEvent(eventExpr = input$button_allStations, {
  shiny::req(!is.null(rv_param_temp$subDat), input$sel_SummarizeBy == "by_char")
  updateCheckboxGroupInput(session,
                           "sel_ShowStations",
                           # label = h6("Select monitoring site(s):"),
                           # choices = switch((!is.null(input$sel_ShowChar))+1, NULL, sort(unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowChar]))),
                           selected = sort(unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowChar])))
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select no stations ----
observeEvent(eventExpr = input$button_noStations, {
  shiny::req(!is.null(rv_param_temp$subDat), input$sel_SummarizeBy == "by_char")
  updateCheckboxGroupInput(session,
                           "sel_ShowStations",
                           # label = h6("Select monitoring site(s):"),
                           # choices = switch((!is.null(input$sel_ShowChar))+1, NULL, sort(unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowChar]))),
                           selected = character(0))
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select all characteristics ----
observeEvent(eventExpr = input$button_allStationChars, {
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
  updateCheckboxGroupInput(session,
                           "sel_ShowStationChars",
                           # label = h6("Select characteristic(s):"),
                           # choices = sort(intersect(unique(rv_param_temp$subDat$CharacteristicName[rv_param_temp$subDat$MonitoringLocationIdentifier == input$sel_ShowOneStation]), rv_param_temp$subDatTypes$CharacteristicName[rv_param_temp$subDatTypes$DataType == "numeric"])),
                           selected = sort(intersect(unique(rv_param_temp$subDat$CharacteristicName[rv_param_temp$subDat$MonitoringLocationIdentifier == input$sel_ShowOneStation]), rv_param_temp$subDatTypes$CharacteristicName[rv_param_temp$subDatTypes$DataType == "numeric"]))
  )
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select no characteristics ----
observeEvent(eventExpr = input$button_noStationChars, {
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
  updateCheckboxGroupInput(session,
                           "sel_ShowStationChars",
                           # label = h6("Select characteristic(s):"),
                           # choices = sort(intersect(unique(rv_param_temp$subDat$CharacteristicName[rv_param_temp$subDat$MonitoringLocationIdentifier == input$sel_ShowOneStation]), rv_param_temp$subDatTypes$CharacteristicName[rv_param_temp$subDatTypes$DataType == "numeric"])),
                           selected = character(0))
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select all characteristic sets for one characteristic ----
observeEvent(eventExpr = input$button_allCharSets, {
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowChar), !is.null(input$sel_ShowStations))
  shiny::req(input$sel_SummarizeBy == "by_char")
  updateCheckboxGroupInput(session,
                           "sel_ShowCharSets",
                           # label = h6("Select characteristic set(s):"),
                           # choices = sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName==input$sel_ShowChar & rv_param_temp$subDat$MonitoringLocationIdentifier %in% input$sel_ShowStations])),
                           selected = sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName==input$sel_ShowChar & rv_param_temp$subDat$MonitoringLocationIdentifier %in% input$sel_ShowStations]))
  )
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select no characteristic sets for one characteristic ----
observeEvent(eventExpr = input$button_noCharSets, {
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowChar), !is.null(input$sel_ShowStations))
  shiny::req(input$sel_SummarizeBy == "by_char")
  updateCheckboxGroupInput(session,
                           "sel_ShowCharSets",
                           # label = h6("Select characteristic set(s):"),
                           # choices = sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName==input$sel_ShowChar & rv_param_temp$subDat$MonitoringLocationIdentifier %in% input$sel_ShowStations])),
                           selected = character(0)
  )
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select all characteristic sets for one station ----
observeEvent(eventExpr = input$button_allStationCharSets, {
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
  updateCheckboxGroupInput(session,
                           "sel_ShowStationCharSets",
                           # label = h6("Select characteristic set(s):"),
                           # choices = switch((!is.null(input$sel_ShowStationChars))+1, NULL, sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowStationChars & rv_param_temp$subDat$MonitoringLocationIdentifier == input$sel_ShowOneStation]))),
                           selected = switch((!is.null(input$sel_ShowStationChars))+1, NULL, sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowStationChars & rv_param_temp$subDat$MonitoringLocationIdentifier == input$sel_ShowOneStation])))
  )
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select no characteristic sets for one station ----
observeEvent(eventExpr = input$button_noStationCharSets, {
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
  updateCheckboxGroupInput(session,
                           "sel_ShowStationCharSets",
                           # label = h6("Select characteristic set(s):"),
                           # choices = switch((!is.null(input$sel_ShowStationChars))+1, NULL, sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowStationChars & rv_param_temp$subDat$MonitoringLocationIdentifier == input$sel_ShowOneStation]))),
                           selected = character(0))
  }, ignoreInit = TRUE) # end of observeEvent
      
```

```{r action_button_refreshPlotData}
# Action to update data summaries with current user inputs----

observeEvent(eventExpr = input$button_refreshPlotData, { 
  # FuncUpdateTSPlots()
  
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_SummarizeBy))

  # These are the user inputs that should only update when plots are refreshed.
  rv_param_temp$sel_summarize_by <- isolate(input$sel_SummarizeBy)
  rv_param_temp$sel_show_thresholds <- isolate(input$sel_ShowThresholds) # save the input setting so plots don't change unless the plot data has been refreshed

  if(isolate(rv_param_temp$sel_summarize_by) == "by_char") {
    rv_param_temp$showStations <- isolate(input$sel_ShowStations)
    rv_param_temp$showCharSets <- isolate(input$sel_ShowCharSets)
  }
  
  rv_param_temp$sel_add_gage_precip <- isolate(input$sel_AddGagePrecip)
  rv_param_temp$sel_gage_station <- isolate(input$sel_GageStation)
  rv_param_temp$sel_gage_yscale <- isolate(input$sel_gage_YScale)
  rv_param_temp$sel_precip_station <- isolate(input$sel_PrecipStation)
  rv_param_temp$sel_precip_yscale <- isolate(input$sel_precip_YScale)

  if(rv_param_temp$sel_summarize_by == "by_station") {
    rv_param_temp$showStations <- isolate(input$sel_ShowOneStation)
    rv_param_temp$showCharSets <- isolate(input$sel_ShowStationCharSets)
   }
  
  if(is.null(rv_param_temp$showStations)) {
    showModal(modalDialog(
      title = "No Monitoring Sites Selected",
      "From the left sidebar, please select at least one monitoring site to plot"
      ))
    }
  shiny::req(!is.null(rv_param_temp$showStations))
  
  if(is.null(rv_param_temp$showCharSets)) {
    showModal(modalDialog(
      title = "No Characteristic Sets Selected",
      "From the left sidebar, please select at least one characteristic and at least one characteristic set to plot"
      ))
    }
  shiny::req(!is.null(rv_param_temp$showCharSets))
      rv_param_temp$finalPlot <- rv_param_temp$seasonalPlot <- list(plotly_page = NULL, shared_legend = NULL)

# Format plot data for time series plot tab
  if(any(is.null(rv_param_temp$subDat),  is.null(rv_param_temp$showStations), is.null(rv_param_temp$showCharSets), is.null(rv_param_temp$sel_summarize_by), is.null(input$sel_AddQuantile), is.null(input$sel_AddGagePrecip), is.null(rv_param_temp$sel_show_thresholds))) { 
   
    rv_param_temp$plotDat <- NULL

  } else {          

      withProgress(message = "Formatting plot data...", value = 0, {
          
          rv_param_temp$plotDat <- FuncPlotDat() # this function also assigns data to rv_param_temp$quantDat
      })
  }
})
```

```{r update_map_click}          

# User selects stations by clicking map (to show data plots)
observeEvent(input$param_map_marker_click, {
  isolate({ 
    cat("MARKER CLICK//")
    # local({ # This may be unnecessary
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(input$param_map_marker_click$id)) # the last one keeps the map from aborting when user clicks on a marker that is not a site marker
shiny::req(any(is.null(input$sel_ParamMapShow), input$sel_ParamMapShow == "show"))  
  
rv_param_temp$update_from_sidebar <- FALSE # during this process, put a halt to this

    clicked_site <- input$param_map_marker_click$id
    cat("GRABBED CLICKED SITE\n")
 
    if(clicked_site %in% rv_param_temp$param_map_highlight) { # if the click is in a selected site
      cat("SITE WAS ALREADY SELECTED\n")
            if(all(input$sel_SummarizeBy == "by_station", length(rv_param_temp$param_map_highlight) == 1, identical(clicked_site, rv_param_temp$param_map_highlight))) {
        showModal(modalDialog(
          title = "Cannot de-select station",
          "You must highlight at least one station to summarize."
        ))
            } else {
              rv_param_temp$param_map_highlight <- rv_param_temp$param_map_highlight[rv_param_temp$param_map_highlight != clicked_site] # then remove it from the list of selected sites
        cat("REMOVED CLICKED SITE FROM VECTOR\n")
        leafletProxy("param_map") %>%
          addCircleMarkers(data = rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier == clicked_site,], group = "Available monitoring sites", lat = ~LatitudeMeasure, lng = ~LongitudeMeasure, layerId = ~MonitoringLocationIdentifier, label = ~SITELAB, radius = 12, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 0.8, stroke = FALSE, color = ~rv_param_temp$palOrg(OrganizationFormalName), opacity = 0.7, options = pathOptions(pane = "pane_param_availableStations")) # and change the site to unselected on the map
        cat("REMOVED CLICKED SITE FROM MAP\n")
            }
      
        
        } else { # if the click is in an unselected site
          cat("CLICKED SITE IS NEW\n")
          if(input$sel_SummarizeBy == "by_station") { # if summarizing by station
            rv_param_temp$param_map_highlight <- clicked_site
            cat("UPDATED VECTOR WITH ONLY CLICKED SITE\n")
             leafletProxy("param_map") %>%
          addCircleMarkers(data = FuncParamAvailSites("by_station"), group = "Available monitoring sites", lat = ~LatitudeMeasure, lng = ~LongitudeMeasure, layerId = ~MonitoringLocationIdentifier, label = ~SITELAB, radius = 12, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 0.8, stroke = FALSE, color = ~rv_param_temp$palOrg(OrganizationFormalName), opacity = 0.7, options = pathOptions(pane = "pane_param_availableStations"))
             cat("CLEARED MAP OF ALL SELECTIONS\n")
            
          } else { # if summarizing by characteristic
            rv_param_temp$param_map_highlight <- c(rv_param_temp$param_map_highlight, clicked_site) # append the ID of clicked site
            cat("UPDATED VECTOR BY APPENDING CLICKED SITE\n")
          }
          
           leafletProxy("param_map") %>% # and highlight the site on the map
            addCircleMarkers(data = rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier == clicked_site,], group = "Available monitoring sites", lat = ~LatitudeMeasure, lng = ~LongitudeMeasure, layerId = ~MonitoringLocationIdentifier, label = ~SITELAB, radius = 15, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 1, stroke = TRUE, weight = 4, color = "white", opacity = 1, options = pathOptions(pane = "pane_param_availableStations"))
           cat("ADDED CLICKED SITE ON MAP\n")
      }
    
    # Also update the user select in left side panel

    if(input$sel_SummarizeBy == "by_char") {
      updateCheckboxGroupInput(session,
                               "sel_ShowStations",
                               selected = rv_param_temp$param_map_highlight)
    }

    if(input$sel_SummarizeBy == "by_station") {
      updateSelectInput(session,
                        "sel_ShowOneStation",
                        selected = rv_param_temp$param_map_highlight)

    }
    
    rv_param_temp$update_from_sidebar <- TRUE 
    # }) # end local
    }) # end isolate
    }, ignoreInit = TRUE) # end of observeEvent

```

```{r map_card}
output$param_map <- renderLeaflet({

  FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = FALSE) # make sure data have been imported and filtered, and plot data have been generated
  cat("LINE2095")
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(rv$sitesPointsSub), !is.null(rv$unitPoly), !is.null(rv$userSelect), !is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$palOrg))
cat("RENDERING ENTIRE MAP AGAIN\n")

sel_param_map_show <- switch(is.null(input$sel_ParamMapShow)+1, input$sel_ParamMapShow, "show")

map_point_size <- switch(is.null(input$sel_MapPointSize)+1, input$sel_MapPointSize, 30)

  iconGages = makeAwesomeIcon(
    text = fa("water"),
    iconColor = "black",
    markerColor = "blue")
iconGagesSelected = makeAwesomeIcon(
    text = fa("water"),
    iconColor = "black",
    markerColor = "orange")
iconMeteo = makeAwesomeIcon(icon= "fa-cloud", library = "fa", squareMarker = TRUE, markerColor = "white")
  iconMeteoSelected = makeAwesomeIcon(icon= "fa-cloud", library = "fa", squareMarker = TRUE, markerColor = "orange") #
  iconCWA = makeAwesomeIcon(icon= "fa-building", library = "fa", markerColor = "lightgray")

  param_map <- leaflet(options = leafletOptions(zoomControl = FALSE, zoomSnap = 0.25)) %>%
    addMapPane("pane_param_selectedStations", zIndex = 250) %>% # higher index is on top
    addMapPane("pane_param_availableStations", zIndex = 245) %>%
    addMapPane("pane_param_polylines", zIndex = 230) %>%
    addMapPane("pane_param_facilitiesPointsSub", zIndex = 226) %>%
    # addMapPane("pane_param_gageStations", zIndex = 225) %>%
    addMapPane("pane_param_gageStations_selected", zIndex = 227) %>%
    # addMapPane("pane_param_meteoStations", zIndex = 225) %>%
    addMapPane("pane_param_meteoStations_selected", zIndex = 227) %>%
    addMapPane("pane_param_HUC", zIndex = 220) %>%
    addMapPane("pane_param_unitPoly", zIndex = 210) %>%
    addTiles(options = tileOptions(noWrap = TRUE), group = "Street") %>%
    addProviderTiles("Esri.WorldImagery", options = providerTileOptions(noWrap = TRUE), group="Satellite") %>%
    addPolygons(data = rv$unitPoly, group = "NPS unit", color = "black", fillColor = "yellow", fillOpacity = 1, weight = 1, options = pathOptions(pane = "pane_param_unitPoly")) %>% # park unit outline
    addPolygons(data = rv[[rv$userSelect$sel_HUClevel]], group = paste0(rv$userSelect$sel_HUClevel, " boundaries"), color = "blue", fillColor = "lightblue", fillOpacity = 0.3, weight = 0.7, options = pathOptions(pane = "pane_param_HUC")) %>% # HUC polygons
    addScaleBar() %>%
    addControl(rv$parkID, position = "topleft") # add 4-letter UNIT code on map

cat("DONE WITH STANDARD MAP")

  # Done with the standard mapping. Now to conditional layers.

  show_layers <- data.frame(layer = c(paste0(rv$userSelect$sel_HUClevel, " boundaries"), "Available monitoring sites", "Selected monitoring sites", "Imported stream lines", "Discharge facilities", "Selected gage stations", "Selected weather stations"), show = c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, TRUE)) # dataframe to track what layers to show
  
  if(input$sel_SummarizeBy == "by_char") { # if multiple sites per characteristic, then available sites are only those that actually have the selected characteristic
    shiny::req(!is.null(input$sel_ShowChar))
    avail_sites_data <- rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier %in% unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowChar]),]
  } else {
    avail_sites_data <- rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier %in% unique(rv_param_temp$subDat$MonitoringLocationIdentifier),]
  }
  # isolate({
cat("RENDERING AVAILABLE SITES IN FULL MAP\n")
  param_map %<>%
    addCircleMarkers(data = avail_sites_data, group = "Available monitoring sites", lat = ~LatitudeMeasure, lng = ~LongitudeMeasure, layerId = ~MonitoringLocationIdentifier, label = ~SITELAB, radius = 12, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 0.8, stroke = FALSE, color = ~rv_param_temp$palOrg(OrganizationFormalName), opacity = 0.7, options = pathOptions(pane = "pane_param_availableStations")) # WQ stations for which data (for selected parameter) are available  
cat("line1988")
# })
  

  # If UP-DOWN selection, show stream lines
  if(rv$userSelect$sel_SelectMethod=="methodDist") {
    show_layers$show[show_layers$layer == "Imported stream lines"] <- TRUE
  cat("line2693")
    if(!is.null(rv$selectedDownstreamLines)) { # add selected downstreams in brown
      param_map %<>%
        addPolylines(data = rv$selectedDownstreamLines, color = "brown", weight = 2, opacity = 1, options = pathOptions(pane = "pane_param_polylines"), group = "Imported stream lines")
    }
  cat("line2698")
        if(!is.null(rv$selectedUpstreamLines)) { # add selected upstreams in blue
      param_map %<>%
        addPolylines(data = rv$selectedUpstreamLines, color = "blue", weight = 2, opacity = 1, options = pathOptions(pane = "pane_param_polylines"), group = "Imported stream lines")
    }

  } else {
    show_layers$show[show_layers$layer == "Imported stream lines"] <- FALSE
  }

  cat("line2707")
  
  # Show selected stream gages
  if(all(!is.null(rv$gageStations), !is.null(rv$selectedGages), rv$selectedGages$GageID %in% rv$gageStations$GageID)) { 
      show_layers$show[show_layers$layer == "Selected gage stations"] <- TRUE

      param_map %<>%
        addAwesomeMarkers(icon = iconGagesSelected, data = rv$selectedGages, lng = ~Longitude, lat = ~Latitude, group = "Selected gage stations", label = ~GAGELAB, popup = ~GAGEPOP, options = pathOptions(pane = "pane_param_gageStations_selected")) # selected stream gage stations
  } else {
      show_layers$show[show_layers$layer == "Selected gage stations"] <- FALSE
    }
 
   # If weather stations have been found
  if(all(!is.null(rv$meteoStations), !is.null(rv$selectedMeteo))) {
      show_layers$show[show_layers$layer == "Selected weather stations"] <- TRUE
      
      param_map %<>%
      addAwesomeMarkers(icon = iconMeteoSelected, data = rv$selectedMeteo, lng = ~longitude, lat = ~latitude, group = "Selected weather stations", label = ~METEOLAB, popup = ~METEOPOP, options = pathOptions(pane = "pane_param_meteoStations_selected")) # selected weather stations
  } else {
        show_layers$show[show_layers$layer == "Selected weather stations"] <- FALSE
      }

  # If Discharge facilities have been found
  if(!is.null(rv$facilitiesPointsSub)) {
    param_map %<>%
      addAwesomeMarkers(icon = iconCWA, data = rv$facilitiesPointsSub, group = "Discharge facilities", label = ~FACLAB, popup = ~FACPOP, options = pathOptions(pane = "pane_param_facilitiesPointsSub"))
    show_layers$show[show_layers$layer == "Discharge facilities"] <- TRUE
  } else {
    show_layers$show[show_layers$layer == "Discharge facilities"] <- FALSE
  }
  cat("line2745")
  #

  cat("line3098")
  
# Highlight selected stations
cat("START OF HIGHLIGHT SELECTED")
    if(all(any(is.null(input$sel_ParamMapShow), input$sel_ParamMapShow == "show"), any(isolate(is.null(rv_param_temp$update_from_sidebar)), isolate(rv_param_temp$update_from_sidebar != FALSE)))) # may be TRUE or NULL
      cat("START UPDATE")
    {
    # isolate({
    # if(is.null(rv_param_temp$param_map_highlight)) { # White outline on sites selected from left panel

    # Need to do this on first go-around because don't yet have a param_map to update with proxy. 
      sel_sites <- switch((input$sel_SummarizeBy == "by_char") + 1, input$sel_ShowOneStation, input$sel_ShowStations)
      
      isolate({ # THIS isolate(local()) is the key to keeping the dashboard from blitzing out
        local(
          if(all(any(is.null(rv_param_temp$update_from_sidebar), rv_param_temp$update_from_sidebar==TRUE), !identical(rv_param_temp$param_map_highlight, sel_sites))) {
        rv_param_temp$param_map_highlight <- sel_sites
        }
        )
      })
      cat("START CHANGING MAP")
      if(length(sel_sites) > 0) {
        param_map %<>%
      addCircleMarkers(data = rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier %in% sel_sites,], group = "Available monitoring sites", lat = ~LatitudeMeasure, lng = ~LongitudeMeasure, layerId = ~MonitoringLocationIdentifier, label = ~SITELAB, radius = 15, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 1, stroke = TRUE, weight = 4, color = "white", opacity = 1, options = pathOptions(pane = "pane_param_availableStations"))
      }
      
    # } # selected WQ stations are shown as larger, white-outlined points
    # })
      
      rv_param_temp$update_from_sidebar <- TRUE # so it's no longer NULL and can now be activated
    cat("RENDERING SELECTED SITES IN FULL MAP\n")
    } 
  
cat("line2095")
  # If summarizing by characteristic, then additional summary options are available
  if(input$sel_SummarizeBy == "by_char" & !is.null(input$sel_SurvYr)){

    # summarize stations by a single characteristic, user can choose from several summary functions...
    # If map choice is 'median'
    if(sel_param_map_show == "median") {
      shiny::validate(need(sum(!is.na(rv_param_temp$plotDat$ResultMeasureValue)) > 0, message = "No monitoring results available for these data"))

      temp_median <- rv_param_temp$plotDat %>%
        dplyr::group_by(MonitoringLocationIdentifier, Yr) %>%
        summarise(median_val = round(median(ResultMeasureValue, na.rm = TRUE), 2)) %>%
        left_join(rv$sitesPointsSub@data[, c("MonitoringLocationIdentifier", "LatitudeMeasure", "LongitudeMeasure", "SITELAB")], by = "MonitoringLocationIdentifier") # >>>>>>>>>>>>>>>>> TRUNCATES LAT-LONG

      palNumeric <- colorNumeric(
        palette = "Reds",
        domain = temp_median$median_val)

      temp_median_plot <- temp_median %>%
        filter(Yr == as.numeric(input$sel_SurvYr)) %>% # Do this after setting the range of values for legend
        dplyr::mutate(SITEPOP = paste0("Site: ", MonitoringLocationIdentifier, "<br>Year: ", Yr, "<br>Median Value: ", median_val))
      param_map %<>%
        addControl(tags$div(tag.map.title, HTML(input$sel_ShowChar, " in Year ", input$sel_SurvYr)), position = "topleft", className="map-title") %>%
        addCircleMarkers(data = temp_median_plot, lat = ~LatitudeMeasure, lng = ~LongitudeMeasure, label = ~SITELAB, popup = ~SITEPOP, radius = 12, fillColor = ~palNumeric(median_val), fillOpacity = 1, color = ~palNumeric(median_val), stroke = FALSE, opacity = 1, options = pathOptions(pane = "pane_param_selectedStations")) %>%
        addLegend(pal = palNumeric, values = temp_median$median_val, position = "topleft", title = input$sel_ShowChar) %>%
        hideGroup("Available monitoring sites") %>%
        hideGroup("Selected monitoring sites") %>%
        hideGroup("Selected gage stations") %>%
        hideGroup("Selected weather stations")
    }

    # If map choice is 'thresh'
    if(sel_param_map_show == "thresh") {
      shiny::validate(need(sum(!is.na(rv_param_temp$plotDat$ThreshCateg)) > 0, message = "No threshold limits defined for these data."))

      thresh_mat <- rv_param_temp$plotDat %>%
        dplyr::filter(!is.na(ThreshCateg)) # NA's occur when is.na(ResultMeasureValue_replaced)--these should not be included, they are just missing values

      thresh_list <- switch(rv_param_temp$sel_show_thresholds,
                          showthresh_file = rv_param_temp$threshList,
                          showthresh_custom = rv_param_temp$threshCustom,
                          showthresh_none = NULL)

      thresh_mat$ThreshCateg <- factor(thresh_mat$ThreshCateg, levels = thresh_list[[1]]$cut_categ) # ensures that a column is created even if a factor level is not in the data
      thresh_mat %<>%
        filter(Yr == as.numeric(input$sel_SurvYr)) %>%
        group_by(MonitoringLocationIdentifier) %>%
        dplyr::count(ThreshCateg) %>%
        spread(key = ThreshCateg, value = n, drop = FALSE, fill = 0) %>%
        left_join(subset(rv$sitesPointsSub@data, select = c("MonitoringLocationIdentifier", "LatitudeMeasure", "LongitudeMeasure", "SITELAB")), by = "MonitoringLocationIdentifier") %>%
        ungroup()
      param_map %<>%
        addControl(tags$div(tag.map.title, HTML(input$sel_ShowChar, " in Year ", input$sel_SurvYr)), position = "topleft", className="map-title") %>%
        addMinicharts(
          lng = thresh_mat$LongitudeMeasure,
          lat = thresh_mat$LatitudeMeasure,
          time = thresh_mat$Yr,
          type = "pie",
          transitionTime = 0,
          layerId = thresh_mat$SITELAB,
          height = map_point_size,
          width = map_point_size,
          chartdata = as.matrix(subset(thresh_mat, select = thresh_list[[1]]$cut_categ)),
          colorPalette = thresh_list[[1]]$cut_colors,
          opacity = 1) %>%
        hideGroup("Available monitoring sites")%>%
        hideGroup("Selected monitoring sites") %>%
        hideGroup("Selected gage stations") %>%
        hideGroup("Selected weather stations")
    }
    
    # If map choice is 'perc'
    if(sel_param_map_show == "perc") {
      shiny::validate(need(sum(!is.na(rv_param_temp$plotDat$PercCateg)) > 0, message = "No percentile limits set for these data"))

      perc_mat <- rv_param_temp$plotDat %>%
        dplyr::filter(!is.na(PercCateg)) %>% # NA's occur when is.na(ResultMeasureValue_replaced)--these should not be included, they are just missing values
        filter(Yr == as.numeric(input$sel_SurvYr)) %>%
        group_by(MonitoringLocationIdentifier, Yr) %>%
        dplyr::count(PercCateg) %>%
        spread(key = PercCateg, value = n, drop = FALSE, fill = 0) %>%
        left_join(subset(rv$sitesPointsSub@data, select = c("MonitoringLocationIdentifier", "LatitudeMeasure", "LongitudeMeasure", "SITELAB")), by = c("MonitoringLocationIdentifier")) %>%
        ungroup()
      param_map %<>% addControl(tags$div(tag.map.title, HTML(input$sel_ShowChar, " in Year ", input$sel_SurvYr)), position = "topleft", className="map-title") %>%
        addMinicharts(
          lng = perc_mat$LongitudeMeasure,
          lat = perc_mat$LatitudeMeasure,
          time = perc_mat$Yr,
          type = "pie",
          transitionTime = 0,
          height = map_point_size,
          width = map_point_size,
          layerId = perc_mat$SITELAB,
          chartdata = as.matrix(perc_mat[, c("below", "between", "above")]),
          colorPalette = c("lightgray", "#56B4E9", "orange"),
          opacity = 1) %>%
        hideGroup("Available monitoring sites") %>%
        hideGroup("Selected monitoring sites") %>%
        hideGroup("Selected gage stations") %>%
        hideGroup("Selected weather stations")
    }
  }

  param_map %<>%
    # hideGroup("Selected gage stations") %>%
    # hideGroup("Selected weather stations") %>%
    hideGroup("Discharge facilities") %>%
    addLayersControl(
      baseGroups = c("Street", "Satellite"),
      overlayGroups = show_layers$layer[show_layers$show == TRUE],
      options = layersControlOptions(collapsed = TRUE)) %>% # set map view at current settings or, if initial map viewing, set to initial defaults. Irritating that it blinks every time, but it seems this can't be easily addressed with leaflet (html-based) outputs
    setView(lng = switch((is.null(input$param_map_center$lng))+1, input$param_map_center$lng, mean(rv$unitPoly@bbox["x",])), lat = switch((is.null(input$param_map_center$lat))+1, input$param_map_center$lat, mean(rv$unitPoly@bbox["y",])), zoom = input$sel_ParamMapZoom)
}) # end of renderLeaflet

# tags$style(type = "text/css", "#param_map {height: calc(100vh - 350px) !important;}") # expand map to fill screen

tags$style("#param_map {height: calc(100vh - 350px) !important;}") # expand map to fill screen
```

```{r ts_cards}
output$out_ts_plots <- renderPlotly({ # separate validation statements so they are checked in sequence

  FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = FALSE)
cat("line5039")

  shiny::validate(
    need(!is.null(rv_param_temp$showCharSets) & !is.null(rv_param_temp$showStations), message = "From the left sidebar, please select characteristic(s), characteristic set(s) and monitoring site(s) to plot, then click the green 'REFRESH PLOT DATA' button"))

  shiny::validate(
    need(length(unique(na.omit(rv_param_temp$subDat$ResultSampleFractionText[rv_param_temp$subDat$CharacteristicSet %in% rv_param_temp$showCharSets]))) < 2 | rv_param_temp$sel_summarize_by == "by_station", message = "Cannot combine characteristic sets with different sample fractions (e.g., dissolved vs. total)"))

    if(all(!is.null(input$sel_CombineSites), !is.null(rv_param_temp$showStations))) {
      shiny::validate(need(length(rv_param_temp$showStations) < 6 | input$sel_CombineSites == FALSE, message = "The maximum number of monitoring sites to display in a single plot is FIVE. From the left sidebar, please either UNSELECT 'Combine sites in one plot' or reduce the number of sites to display."))
    }
cat("line2220")
  # shiny::req(!is.null(rv_param_temp$plotDat), !is.null(rv_param_temp$quantDat))
  cat("line2222")
  if(all(!is.null(rv_param_temp$plotDat), !is.null(rv_param_temp$quantDat))) {
    
  saveRDS(isolate(reactiveValuesToList(rv)), "TEMP2_rv.RDS")
  saveRDS(isolate(reactiveValuesToList(rv_param_temp)), "TEMP2_rv_param_temp.RDS")
  saveRDS(isolate(reactiveValuesToList(input)), "TEMP2_input.RDS")
    
    rv_param_temp$finalPlot <- FuncPlotPage(plot_type = input$sel_PlotType, plot_dat = rv_param_temp$plotDat, quant_dat = rv_param_temp$quantDat, time_unit = "ActivityStartDate", free_y = switch(is.null(input$sel_FreeY)+1, input$sel_FreeY, FALSE), sel_combine_sites = switch(is.null(input$sel_CombineSites)+1, input$sel_CombineSites, FALSE), trans_log_y = switch(exists("input$sel_log_y")+1, NULL, input$sel_log_y))
    cat("line2224")
  }
    
    shiny::req(!is.null(rv_param_temp$finalPlot$plotly_page))
    cat("line2226")
  
    rv_param_temp$finalPlot$plotly_page
    })
unlink("Rplots.pdf")
tags$style("#out_ts_plots{height: calc(100vh - 350px) !important;overflow-y:scroll}")

output$out_season_plots <- renderPlotly({
  
    FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = FALSE)
  
  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$subDat),  !is.null(rv_param_temp$subDatTypes))

  shiny::validate(
    need(!is.null(rv_param_temp$showCharSets) & !is.null(rv_param_temp$showStations), message = "From the left sidebar, please select characteristic set(s) and monitoring site(s) to plot, then click the green 'REFRESH PLOT DATA' button"))

  shiny::validate(
    need(length(unique(na.omit(rv_param_temp$subDat$ResultSampleFractionText[rv_param_temp$subDat$CharacteristicSet %in% input$sel_ShowCharSets]))) < 2, message = "Cannot combine characteristic sets with different sample fractions (e.g., dissolved vs. total)"))

  if(!is.null(input$sel_CombineSites) & !is.null(rv_param_temp$showStations)) {
    shiny::validate(need(length(rv_param_temp$showStations) < 6 | input$sel_CombineSites == FALSE, message = "The maximum number of monitoring sites to display in a single plot is FIVE. From the left sidebar, please either UNSELECT 'Combine sites in one plot' or reduce the number of sites to display."))
  }
    
  shiny::req(!is.null(rv_param_temp$plotDat), !is.null(rv_param_temp$quantDat))
  
    rv_param_temp$seasonalPlot <- FuncPlotPage(plot_type = input$sel_PlotType, plot_dat = rv_param_temp$plotDat, quant_dat = rv_param_temp$quantDat, time_unit = switch(is.null(input$sel_SeasonalTimeUnit)+1, input$sel_SeasonalTimeUnit, "Wk"), free_y = switch(is.null(input$sel_FreeY)+1, input$sel_FreeY, FALSE), sel_combine_sites = switch(is.null(input$sel_CombineSites)+1, input$sel_CombineSites, FALSE), trans_log_y = switch(exists("input$sel_log_y")+1, NULL, input$sel_log_y))

  shiny::req(!is.null(rv_param_temp$seasonalPlot$plotly_page))
  rv_param_temp$seasonalPlot$plotly_page
})
unlink("Rplots.pdf")
tags$style("#out_season_plots{height: calc(100vh - 350px) !important;overflow-y:scroll}")

output$out_thresh_plots <- renderPlotly({

  # FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = TRUE)

  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$subDat),  !is.null(rv_param_temp$subDatTypes), !is.null(rv_param_temp$plotDat))
shiny::req(!is.null(rv_param_temp$sel_summarize_by))
shiny::validate(need(rv_param_temp$sel_summarize_by == "by_char", message = "Currently, this display is available only when summarizing by characteristic (not by station)"))

shiny::req(!is.null(rv_param_temp$sel_show_thresholds))
shiny::validate(need(!is.null(rv_param_temp$sel_show_thresholds != "showthresh_none"), "In the left sidebar, choose to define custom threshold limits or import limits from a file, then click the green 'REFRESH PLOT DATA' button"))

thresh_list <- switch(rv_param_temp$sel_show_thresholds,
                          showthresh_file = rv_param_temp$threshList,
                          showthresh_custom = rv_param_temp$threshCustom)

shiny::validate(need(!is.null(thresh_list), message = "No threshold limits defined"))

thresh_ID = paste0(unique(na.omit(rv_param_temp$plotDat$CharacteristicName)), " (", unique(na.omit(rv_param_temp$plotDat$ResultMeasure.MeasureUnitCode)), ")")
shiny::validate(need(!is.null(thresh_list[[thresh_ID]]), message = paste0("No threshold limits defined for ", thresh_ID)))

  threshPieDat <- FuncPieDat(limit_type = "ThreshCateg")
  
  shiny::validate(
    need(!is.null(threshPieDat), message = "No threshold limits defined"))
  
  thresh_named_colors <- thresh_list[[thresh_ID]]$cut_colors
  thresh_named_levels <- thresh_list[[thresh_ID]]$cut_categ
  
  thresh_plot_title <- paste0("Threshold levels by ", switch((rv_param_temp$sel_summarize_by == "by_char")+1, "water quality characteristic", "monitoring site"), " (rows) and year (cols) for ", switch((rv_param_temp$sel_summarize_by == "by_char")+1, unique(rv_param_temp$plotDat$MonitoringLocationIdentifier), unique(rv_param_temp$plotDat$CharacteristicName)))
  
  thresh_pie <- FuncPlotlyPieMatrix(dat = threshPieDat %>% dplyr::filter(!is.na(CategVar)), discrete_cols = thresh_named_colors, discrete_levels = thresh_named_levels, plot_title = thresh_plot_title)
  })
tags$style("#out_thresh_plots{height: calc(100vh - 350px) !important;overflow-x:scroll;overflow-y:scroll}")

output$out_perc_plots <- renderPlotly({
  # FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = TRUE)
  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$subDat),  !is.null(rv_param_temp$subDatTypes), !is.null(rv_param_temp$plotDat))
          
  percPieDat <- FuncPieDat(limit_type = "PercCateg")
  
  shiny::validate(
    need(!is.null(percPieDat), message = "No percentile data calculated"))
  shiny::req(!is.null(rv_param_temp$sel_summarize_by), !is.null(input$sel_AddQuantile))

  perc_named_colors <- c("lightgray", "#56B4E9", "orange")

  perc_named_levels <- c("below", "between", "above")

  plot_title <- paste0("Percentile levels by ", switch((rv_param_temp$sel_summarize_by == "by_char")+1, "WQ characteristic", "monitoring site"), " (rows) and year (cols) for ", switch((rv_param_temp$sel_summarize_by == "by_char")+1, unique(rv_param_temp$plotDat$MonitoringLocationIdentifier), unique(rv_param_temp$plotDat$CharacteristicName)), " calculated", switch((input$sel_QuantileGroupBy=="quant_all")+1, " separately by site", " for all sites combined"))

  perc_pie <- FuncPlotlyPieMatrix(dat = percPieDat %>% dplyr::filter(!is.na(CategVar)), discrete_cols = perc_named_colors, discrete_levels = perc_named_levels, plot_title = plot_title)
  })
tags$style("#out_perc_plots{height: calc(100vh - 350px) !important;overflow-x:scroll;overflow-y:scroll}")
```

MAP TEST...
====================================== 

Inputs {.sidebar data-width=340}
-------------------------------------
```{r summary_sidebar}  
br()

actionButton("button_refreshPlotData", "REFRESH PLOT DATA", style="border-color:black; background-color: lightgreen; width:100%; border:0px; margin:0px") # updates plots
  
br()

br()


 ### Filter data----
page_fluid(
  accordion(
    multiple = TRUE,
    open = TRUE,
    # open = c("plot_display_options", "define_thresholds", "add_stream_precip", "plot_display_options"),
    
    ## Panel to select plot data----
  accordion_panel(
    title = "Select data", 
    value = "plot_display_options", 
    icon = bsicons::bs_icon("funnel-fill"),
  
renderUI({
  radioButtons("sel_SummarizeBy",
               label = h6(" Summarize by:"),
               choiceNames = list("ONE CHARACTERISTIC for many stations", "many characteristics for ONE STATION"),
               choiceValues = list("by_char", "by_station"),
               selected = "by_char")
  }),

# Generate bold, red warning if characteristic sets with different measurement units are compared for a single characteristic
tags$div(renderText({ 
  shiny::req(!is.null(rv_param_temp$finalPlot$plotly_page), !is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$showCharSets))

  char_incomp <- rv_param_temp$plotDat %>% dplyr::group_by(CharacteristicName) %>% dplyr::summarize(num_units = length(unique(na.omit(ResultMeasure.MeasureUnitCode)))) %>% dplyr::ungroup() %>% dplyr::filter(num_units > 1) %>% .$CharacteristicName

  if(length(char_incomp) > 0) {
    paste0("WARNING!! It looks like you're summarizing data with different measurement units for these characteristics: ", paste(char_incomp, collapse = ", "), ". Results are NOT VALID if the selected units are not comparable.")  # Post a warning if it looks like different measurement units are being compared
  }
}), style = "font-size:14px; color:red;"), # could also bold it... font-weight:bold; 

hr(),

# If summarizing by characteristic (ONE CHARACTERISTIC for many stations)...
renderUI({
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(rv_param_temp$subDatTypes))
  shiny::req(input$sel_SummarizeBy == "by_char")
  
  char_choices <- sort(intersect(unique(rv_param_temp$subDat$CharacteristicName), rv_param_temp$subDatTypes$CharacteristicName[rv_param_temp$subDatTypes$DataType == "numeric"]))
  
  selectInput("sel_ShowChar",
                  label = h6("Select a characteristic to plot:"),
                  choices = char_choices,
                  selected = switch(is.null(input$sel_ShowChar)+1, input$sel_ShowChar, char_choices[1]))
}),

renderUI({
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowChar))
  shiny::req(input$sel_SummarizeBy == "by_char")
  
  checkboxGroupInput("sel_ShowStations",
                          label = h6("Select monitoring site(s):"),
                          choices =  sort(unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowChar])),
                          selected = input$sel_ShowStations
  )# don't do switch here because will cause problems with select all/none
  
  }),

renderUI({
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowChar))
  shiny::req(input$sel_SummarizeBy == "by_char")
  
      FuncAllNoneButtons(cond = "input.sel_ShowStations", name_all = "button_allStations", name_none = "button_noStations")
}),

renderUI({
    shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowChar), !is.null(input$sel_ShowStations))
  shiny::req(input$sel_SummarizeBy == "by_char")
        
        checkboxGroupInput("sel_ShowCharSets",
                         label = h6("Select characteristic set(s):"),
                         choices = sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName==input$sel_ShowChar & rv_param_temp$subDat$MonitoringLocationIdentifier %in% input$sel_ShowStations])),
                         selected = sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName==input$sel_ShowChar & rv_param_temp$subDat$MonitoringLocationIdentifier %in% input$sel_ShowStations])))
        }),

renderUI({
   shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowChar), !is.null(input$sel_ShowStations))
  shiny::req(input$sel_SummarizeBy == "by_char")
    
    FuncAllNoneButtons(cond = "input.sel_ShowCharSets", name_all = "button_allCharSets", name_none = "button_noCharSets")
    }),

# If summarizing by station (many characteristics for ONE STATION)...
renderUI({
    shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat))
  shiny::req(input$sel_SummarizeBy == "by_station")
  
    selectInput("sel_ShowOneStation",
                label = h6("Select a monitoring site:"),
                choices = sort(unique(rv_param_temp$subDat$MonitoringLocationIdentifier)),
                selected = input$sel_ShowOneStation)
}),

renderUI({
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(rv_param_temp$subDatTypes), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
    
    checkboxGroupInput("sel_ShowStationChars",
              label = h6("Select characteristic(s):"),
              choices = sort(intersect(unique(rv_param_temp$subDat$CharacteristicName[rv_param_temp$subDat$MonitoringLocationIdentifier == input$sel_ShowOneStation]), rv_param_temp$subDatTypes$CharacteristicName[rv_param_temp$subDatTypes$DataType == "numeric"])),
              selected = input$sel_ShowStationChars
              ) # don't do switch here because will cause problems with select all/none
}),

renderUI({
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(rv_param_temp$subDatTypes), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
    
    FuncAllNoneButtons(cond = "input.sel_ShowStationChars", name_all = "button_allStationChars", name_none = "button_noStationChars")
}),

renderUI({
   shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowStationChars), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
          
    checkboxGroupInput("sel_ShowStationCharSets",
                         label = h6("Select characteristic set(s):"),
                         choices = sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowStationChars & rv_param_temp$subDat$MonitoringLocationIdentifier == input$sel_ShowOneStation])),
                         selected = sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowStationChars & rv_param_temp$subDat$MonitoringLocationIdentifier == input$sel_ShowOneStation])))
    
}),

renderUI({
   shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowStationChars), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
    
    FuncAllNoneButtons(cond = "input.sel_ShowStationCharSets", name_all = "button_allStationCharSets", name_none = "button_noStationCharSets")
    }) # <<<<<<<<<<<<< PICK UP FROM HERE. CHANGE GAGEPRECIP TO WITHIN ACTION BUTTON. CHARSETS SHOULD BE A POP-UP BUTTON.
), # end of accordion panel

## Panel to define high/low values ----
accordion_panel( 
  title = "Define high/low values", 
    value = "define_thresholds", 
    icon = bsicons::bs_icon("stoplights-fill"),
  
  renderUI({ 
    shiny::req(!is.null(rv_param_temp$subDat))
    radioButtons("sel_ShowThresholds",
                 label = h6("Show threshold limits on plot"),
                 choiceNames = c("Do not show", "Use limits entered below for the selected characteristic", "Use threshold limits from attached file"),
                 choiceValues = c("showthresh_none", "showthresh_custom", "showthresh_file"),
                 selected = switch(is.null(input$sel_Thresholds)+1, switch((input$sel_SummarizeBy=="site")+1, input$sel_Thresholds, "showthresh_none"), switch(is.null(rv_param_temp$threshList)+1, "showthresh_file", "showthresh_none"))
    )
    }),
  
  renderUI({ # Set threshold limits
    shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_ShowThresholds), !is.null(input$sel_SummarizeBy))
    shiny::req(input$sel_ShowThresholds == "showthresh_custom")
    conditionalPanel(
      condition = "input.sel_ShowThresholds == 'showthresh_custom'",
      shiny::validate(need(input$sel_SummarizeBy == "by_char", message = "This option is available only when summarizing by characteristic (not by station)")),
        selectInput("sel_ThreshUnit",
                    label = "Threshold measure unit",
                    choices = sort(unique(na.omit(rv_param_temp$subDat$ResultMeasure.MeasureUnitCode[ rv_param_temp$subDat$CharacteristicName == input$sel_ShowChar]))),
                    selected = switch(is.null(input$sel_ThreshUnit)+1, input$sel_ThreshUnit, sort(unique(na.omit(rv_param_temp$subDat$ResultMeasure.MeasureUnitCode[ rv_param_temp$subDat$CharacteristicName == input$sel_ShowChar])))[1])
        ),
        numericInput("sel_ThreshLower",
                     label = "Enter a lower threshold limit (use -999 for no lower limit)",
                     value = -999,
                     min = NA,
                     max = NA,
                     step = NA),
        numericInput("sel_ThreshUpper",
                     label = "Enter an upper threshold limit (use 999 for no upper limit)",
                     value = 999,
                     min = NA,
                     max = NA,
                     step = NA)
    )
    }),
  
  br(),

  renderUI({
  checkboxInput("sel_AddQuantile",
              label = h6("Add percentile lines to plot"),
              value = switch(is.null(input$sel_AddQuantile)+1, input$sel_AddQuantile, TRUE))
    }),
  
  renderUI({
    shiny::req(!is.null(input$sel_AddQuantile),
               !is.null(input$sel_SummarizeBy))
    shiny::req(input$sel_AddQuantile == TRUE)
    conditionalPanel(
      condition = "input.sel_AddQuantile == true",
      numericInput("sel_QuantileProbLower",
                 label = "Enter lower percentile limit (or 0 for no lower limit)",
                 value = 0.05,
                 min = 0.0,
                 max = 1.0,
                 step = 0.05),
      numericInput("sel_QuantileProbUpper",
                 label = "Enter upper percentile limit (or 1 for no upper limit)",
                 value = 0.95,
                 min = 0.0,
                 max = 1.0,
                 step = 0.05),
      # if(input$sel_SummarizeBy == "by_char") {
        selectInput("sel_QuantileGroupBy",
                 label = "Calculate percentile limits:",
                 choices = c("per site" = "quant_each",
                             "across sites" = "quant_all"),
              selected = "quant_all")
        # } # <<<<<<<<<<<<<< REALLY THIS SHOULD ONLY SHOW IF BY_CHAR, BUT I NEED AN ENTRY REGARDLESS
      )
    })
), # end of accordion panel

## Panel to add streamflow/precip data ----
accordion_panel( 
  title = "Add Streamflow/Precip", 
    value = "add_stream_precip", 
    icon = fa("cloud-showers-water"),
  
  # Additional plot
  renderUI({
    radioButtons("sel_AddGagePrecip",
                 label = h6("Add external data plot: "),
                 choices = c("none", "streamflow", "precipitation"),
                 selected = switch(is.null(input$sel_AddGagePrecip)+1, input$sel_AddGagePrecip, "none")
                 )
  }),
  
  # Add streamflow plot
  renderUI({
    shiny::req(!is.null(input$sel_AddGagePrecip))
    shiny::req(input$sel_AddGagePrecip == "streamflow")
    shiny::validate(
      need(!is.null(rv$selectedGages) & !is.null(rv$gagesDat), message = "No streamflow data imported"))
    conditionalPanel(
      condition = "input.sel_AddGagePrecip == 'streamflow'", 
      selectInput("sel_GageStation", # choose a gage station
                  label = "Select a gage station for streamflow data",
                  choices = sort(unique(rv$selectedGages$GageName)),
                  selected = switch(is.null(input$sel_GageStation)+1, input$sel_GageStation, sort(unique(rv$selectedGages$GageName))[1])),
      )
    }),
  
  # Add precipitation plot
  renderUI({
    shiny::req(!is.null(input$sel_AddGagePrecip))
    shiny::req(input$sel_AddGagePrecip == "precipitation")
    shiny::validate(
      need(!is.null(rv$selectedMeteo) & !is.null(rv$meteoDat), message = "No precipitation data imported"))
    conditionalPanel(
      condition = "input.sel_AddGagePrecip == 'precipitation'",
      selectInput("sel_PrecipStation", # choose a weather station
                  label = "Select a weather station",
                  choices = sort(unique(rv$selectedMeteo$MeteoName)),
                  selected = switch(is.null(input$sel_PrecipStation)+1, input$sel_PrecipStation, sort(unique(rv$selectedMeteo$MeteoName))[1])),
      )
    })
) # end of accordion_panel


) # end of accordion
) # end of page_fluid
```

Column
-------------------------------------
###
```{r}
output$out_alert <- renderText({
    shiny::req(!is.null(rv_param_temp$plotDat))
    "NOTE: Summaries by Reporting Site are limited to survey events for which data are available for all included Sites"
  })

conditionalPanel(
  condition = "(typeof output.out_alert !== 'undefined' && output.out_alert > 0)",
  tags$div(
  id = "test_alert",
  class = "alert alert-warning",
  textOutput("out_alert")
  )
)

```

```{r map_input}

div(style="display:flex; flex-direction:row; max-width:100%; justify-content:space-evenly; flex-wrap: wrap; align-items: center;",
    div(style ="flex: 0 0 45; padding:2px;",
        renderUI({ 
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$plotDat))
  radioGroupButtons("sel_ParamMapShow",
              label = h6("Show on map: "),
              choices = switch((input$sel_SummarizeBy == "by_char")+1, c("Sites" = "show"), c("Sites" = "show", "Median" = "median", "Thresholds" = "thresh", "Percentiles" = "perc")),
              size = "sm",
              selected = "show") # <<<<<<<<< NEED TO CALC OVERALLS STILL
  }),
  renderUI({
  shiny::req(!is.null(rv$unitPoly), !is.null(rv_param_temp$sel_summarize_by), !is.null(rv_param_temp$plotDat), !is.null(input$sel_ParamMapShow))
    shiny::req(input$sel_ParamMapShow != "show")
  sliderTextInput("sel_SurvYr", force_edges = TRUE, label = h6("Choose a survey year"), choices = sort(unique(rv_param_temp$plotDat$Yr)), selected = max(rv_param_temp$plotDat$Yr, na.rm = TRUE), dragRange = FALSE, animate = TRUE, width = "85%")
  })
  ),

div(style ="flex: 0 0 45; padding:2px;",
        renderUI({
  shiny::req(!is.null(rv$unitPoly))
  map_zoom <- min(RgoogleMaps::MaxZoom(lonrange = rv$unitPoly@bbox["x",], latrange = rv$unitPoly@bbox["y",]))
  sliderInput("sel_ParamMapZoom", label = h6("Set map zoom (smaller = wider view):"), min = max(1, map_zoom - 6), max = 15, value = map_zoom - 1, step = 0.5, ticks = FALSE, dragRange = FALSE, width = "95%")
  }),
  renderUI({
  shiny::req(!is.null(rv$unitPoly), !is.null(rv_param_temp$sel_summarize_by), !is.null(rv_param_temp$plotDat), !is.null(input$sel_ParamMapShow))
    shiny::req(input$sel_ParamMapShow %in% c("thresh", "perc"))
    sliderInput("sel_MapPointSize", label = "Resize map pie charts:", min = 10, max = 60, value = 30, step = 10, ticks = FALSE, dragRange = FALSE, width = "95%")
    })
  )
)

  br()
```

```{r map}  
card(
  full_screen = TRUE,
  card_body(
leafletOutput('param_map', width = "100%")
))
```

Column {.tabset .tabset-fade}
-------------------------------------

```{r}
output$out_alert2 <- renderText({
    shiny::req(!is.null(rv_param_temp$plotDat))
    "NOTE: Summaries by Reporting Site are limited to survey events for which data are available for all included Sites"
  })

div(style="display:flex; flex-direction:row; max-width:100%; justify-content:space-evenly; flex-wrap: wrap; align-items: center;",
    div(style = "flex: 0 0 80; padding:10px;",
        class = "alert alert-warning",
        textOutput("out_alert2")
        ), # this alert spans the entire plots column
    div(style ="flex: 0 0 55; padding:2px;", # these inputs are on left-side of plots column
  radioGroupButtons("sel_PlotType",
             label = h6("Plot type:"),
             choiceNames = list("Points", "Points + Smooth", "Box Plots"),
             choiceValues = list("points", "points_smooth", "box"),
             size = "sm",
             selected = "points_smooth"),
  
      renderUI({
      shiny::req(all(!is.null(input$sel_SummarizeBy), input$sel_SummarizeBy == "by_char"), !is.null(input$sel_CombineSites), input$sel_CombineSites == FALSE)
  checkboxInput("sel_FreeY",
                        label = h6("Allow y-axis to differ across plots"),
                        value = switch(is.null(input$sel_FreeY)+1, input$sel_FreeY, FALSE))
  })
        
  ),

div(style ="flex: 0 0 35; padding:2px;", # these inputs are on right-side of plots column
    renderUI({
      shiny::req(all(!is.null(input$sel_SummarizeBy), input$sel_SummarizeBy == "by_char"))
  checkboxInput("sel_CombineSites",
                        label = h6("Combine sites in one plot"),
                        value = switch(is.null(input$sel_CombineSites)+1, input$sel_CombineSites, FALSE))
}),

    shinyWidgets::dropdownButton(
    inputId = "dropdown_options",
    label = "Additional Plot Options",
    circle = FALSE,
    status = "button_menu",
    icon = icon("sliders"),
    tooltip = "Options for user to modify plot",
    
    renderUI({
  shiny::req(!is.null(rv_param_temp$plotDat), !is.null(rv_param_temp$sel_add_gage_precip)) # the option to log-transform y-axes only appears after plots have been generated
  
  param_choices <- rv_param_temp$plotDat %>% dplyr::select(CharacteristicName) %>% dplyr::distinct() %>% pull(CharacteristicName)
  if(rv_param_temp$sel_add_gage_precip == "streamflow" & !is.null(rv_param_temp$sel_gage_station)) { # if there is a selected gage station
    param_choices <- c(param_choices, "streamflow")
  }
  if(rv_param_temp$sel_add_gage_precip == "precipitation" & !is.null(rv_param_temp$sel_precip_station)) { # if there is a selected precip station
    param_choices <- c(param_choices, "precipitation")
  }
  
  checkboxGroupInput("sel_log_y",
                     label = "Log-transform y-axis for these parameters:",
                     choices = param_choices,
                     selected = switch(is.null(input$sel_log_y)+1, input$sel_log_y, NULL)
                     ) # a vector of the parameters for which y-axis should be log-transformed
}),
           
  renderUI({
    shiny::req(any(is.null(input$sel_CombineSites), input$sel_CombineSites == FALSE)) # If sites are combined, then colors already represent different sites
    radioButtons("sel_Categ",
                 label = h6("Color point plots by a categorical characteristic:"),
                 choices = switch((!is.null(rv_param_temp$categLevelsPlot) & !is.null(input$sel_SummaryParam))+1, "none", c("none", sort(intersect(input$sel_SummaryParam, unique(rv_param_temp$categLevelsPlot$CharacteristicName))))),
                 selected = "none")
    }),

    renderUI({
      sliderInput("sel_PlotHt",
                   label = h6("Change plot height (in pixels)"),
                  min = 240,
                  max = 340,
                  step = 10,
                  animate = FALSE,
                   value = 280)
    })
  )
  )
)
```
### Time Series

```{r ts_plots}
card(
  full_screen = TRUE,
  card_body(
    plotlyOutput("out_ts_plots")
  )
)
```

### Seasonal Patterns

```{r seasonal_plots_input}
radioGroupButtons("sel_SeasonalTimeUnit",
              label = h6("SEASONAL patterns time unit:"),
              choices = c("Day of Year" = "DayOfYr", "Week of Year" = "Wk", "Month of Year" = "Mnth", "Season of Year" = "Season"),
              selected = "Wk",
              size = "sm")
```

```{r seasonal_plots}
card(
  full_screen = TRUE,
  card_body(
    plotlyOutput("out_season_plots")
  )
)
```

### Annual Threshold Levels

```{r pie_thresh}
card(
  full_screen = TRUE,
  card_body(
    plotlyOutput("out_thresh_plots")
  )
)
```

### Annual Percentile Levels

```{r pie_perc}
card(
  full_screen = TRUE,
  card_body(
    plotlyOutput("out_perc_plots")
  )
)
```