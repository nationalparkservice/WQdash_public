---
title: "Flexdashboard Leaflet Popup Test"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
runtime: shiny
---

```{r setup, include=FALSE}
# >>>>>>>>>>> PICK UP. PIE CHART NEEDS TO SHIFT RIGHT. NO THRESHOLD AVAIL TEXT NEEDS TO LINE UP MIDDLE HORIZONTALLY AND WITH VERTICAL. ALL CELL TEXT NEEDS TO LINE UP UNDER COL. 
# Change table to gt with map to ggplot_image for donut chart. Pie charts should also include '
library(flexdashboard)
library(shiny)
library(leaflet)
library(sf)
library(htmlwidgets)
library(shinyjs)
library(reactable)  # ADD THIS
library(dplyr)      # ADD THIS (you were using it but not loading it)
library(tidyr)      # ADD THIS
library(htmltools)

# Dummy site coordinates
set.seed(1)
sites <- data.frame(
  MonitoringLocationIdentifier = paste0("Site_", 1:5),
  lon = runif(5, -90, -89),
  lat = runif(5, 29, 30)
)
sites_sf <- st_as_sf(sites, coords = c("lon", "lat"), crs = 4326)

# Dummy CharacteristicName tables for each site
make_params <- function(n) {
  data.frame(
    CharacteristicName = paste("Param", 1:n),
    Sample_Size = sample(50:200, n, TRUE),
    Year_Range = paste0(sample(2000:2010, n, TRUE), "â€“", sample(2015:2024, n, TRUE)),
    Lowest_Value = round(runif(n, 0, 5), 1),
    Highest_Value = round(runif(n, 10, 30), 1),
    Most_Recent_Value = round(runif(n, 5, 25), 1),
    Most_Recent_Sample_Date = sample(seq(as.Date('2022-01-01'), as.Date('2024-07-01'), by = "month"), n))
}

site_param_data <- setNames(
  lapply(sample(2:5, 5, TRUE), make_params),
  sites$MonitoringLocationIdentifier
)

full_data <- purrr::map_df(site_param_data, ~as.data.frame(.x), .id="MonitoringLocationIdentifier")

threshold_df <- data.frame(
  MonitoringLocationIdentifier = c("Site_1", "Site_1", "Site_2", "Site_3", "Site_3", "Site_3"),
  CharacteristicName = rep("Param 1", 6),
  ThreshCateg = c("good", "caution", "good", "good", "caution", "poor"),
  n = c(16, 1, 20, 19, 4, 2)
)

# Function to generate table with horizontal bar
generate_param_table <- function(df, threshold_df, MonitoringLocationIdentifier) {
  
  # Join and process data efficiently
  display_data <- df %>%
    dplyr::left_join(
      threshold_df %>%
        dplyr::filter(tolower(MonitoringLocationIdentifier) == tolower(!!MonitoringLocationIdentifier)) %>%
        dplyr::group_by(CharacteristicName) %>%
        dplyr::summarise(
          good_count = sum(n[ThreshCateg == "good"], na.rm = TRUE),
          caution_count = sum(n[ThreshCateg == "caution"], na.rm = TRUE),
          poor_count = sum(n[ThreshCateg == "poor"], na.rm = TRUE),
          .groups = "drop"
        ),
      by = "CharacteristicName"
    ) %>%
    tidyr::replace_na(list(good_count = 0, caution_count = 0, poor_count = 0))
  
  display_data$range_viz <- NA  # Placeholder column
display_data$threshold_viz <- NA  # Placeholder column
  
  reactable::reactable(
    display_data,
    columns = list(
      CharacteristicName = reactable::colDef(name = "Parameter", width = 120),
      Sample_Size = reactable::colDef(name = "Sample Size", width = 100),
      Year_Range = reactable::colDef(name = "Year Range", width = 100),
      Most_Recent_Sample_Date = reactable::colDef(name = "Recent Date", width = 100),
      Most_Recent_Value = reactable::colDef(name = "Recent Value", width = 100),
      Lowest_Value = reactable::colDef(show = FALSE),
      Highest_Value = reactable::colDef(show = FALSE),
      good_count = reactable::colDef(show = FALSE),
      caution_count = reactable::colDef(show = FALSE),
      poor_count = reactable::colDef(show = FALSE),
      # Custom column for range visualization
      range_viz = reactable::colDef(
        name = "Value Range",
        width = 150,
        cell = function(value, index) {
          low <- display_data$Lowest_Value[index]
          high <- display_data$Highest_Value[index]
          current <- display_data$Most_Recent_Value[index]
          pct <- round(((current - low) / (high - low)) * 100, 1)
          
          htmltools::div(
            style = "display: flex; align-items: center;",
            htmltools::div(
              style = paste0(
                "background: linear-gradient(to right, #007BFF 0%, #007BFF ", pct,
                "%, #eee ", pct, "%, #eee 100%); height: 20px; width: 100px; border-radius: 10px;"
              )
            ),
            htmltools::div(style = "margin-left: 8px; font-size: 10px;", paste0(pct, "%"))
          )
        }
      ),
      # Custom column for threshold summary
      threshold_viz = reactable::colDef(
        name = "Thresholds",
        width = 120,
        cell = function(value, index) {
          good <- display_data$good_count[index]
          caution <- display_data$caution_count[index]  
          poor <- display_data$poor_count[index]
          
          if (good + caution + poor == 0) {
            return(htmltools::div("No data", style = "color: #666; font-size: 10px;"))
          }
          
          htmltools::div(
            htmltools::div(style = "color: #28a745; font-size: 10px;", paste("Good:", good)),
            htmltools::div(style = "color: #ffc107; font-size: 10px;", paste("Caution:", caution)),
            htmltools::div(style = "color: #dc3545; font-size: 10px;", paste("Poor:", poor))
          )
        }
      )
    ),
    defaultPageSize = 10,
    striped = TRUE,
    highlight = TRUE,
    borderless = TRUE,
    theme = reactable::reactableTheme(
      stripedColor = "#f8f9fa",
      highlightColor = "#e3f2fd",
      cellPadding = "8px 12px"
    )
  )
}
```

Column {data-width = 1000}
-------------------------------------

```{r}
# Output the map
leafletOutput("param_map", height = "600px")
```

```{r}
output$param_map <- renderLeaflet({
  leaflet(data = sites_sf) |>
    addTiles() |>
    addCircleMarkers(
      layerId = ~MonitoringLocationIdentifier,
      label = ~MonitoringLocationIdentifier,
      radius = 8,
      color = "red",
      fillOpacity = 0.8,
      stroke = FALSE
    ) |>
    htmlwidgets::onRender("
      function(el, x) {
        this.on('contextmenu', function(e) {
          var clicked = null;
          this.eachLayer(function(layer) {
            if (layer.options && layer.options.layerId) {
              var latlng = layer.getLatLng();
              var dist = Math.sqrt(
                Math.pow(e.latlng.lat - latlng.lat, 2) +
                Math.pow(e.latlng.lng - latlng.lng, 2)
              );
              if (dist < 0.01) { clicked = layer.options.layerId; }
            }
          });
          if (clicked) {
            Shiny.setInputValue('map_right_click', {
              MonitoringLocationIdentifier: clicked,
              nonce: Math.random()
            });
          }
        });
      }
    ")
})

observeEvent(input$map_right_click, {
  site <- input$map_right_click$MonitoringLocationIdentifier
  
  # More efficient data filtering with error checking
  site_data <- full_data %>% 
    dplyr::filter(MonitoringLocationIdentifier == site)
  
  if (nrow(site_data) == 0) {
    shiny::showNotification("No data available for this site", type = "warning")
    return()
  }
  
  shiny::showModal(
    shiny::modalDialog(
      title = paste("Water Quality Summary -", site),
      generate_param_table(
        df = site_data,
        threshold_df = threshold_df,
        MonitoringLocationIdentifier = site
      ),
      easyClose = TRUE,
      size = "l",
      footer = shiny::modalButton("Close")
    )
  )
})
```