---
title: "Water in Our Parks"
output:
  flexdashboard::flex_dashboard:
    theme: yeti   # theme options: default, cosmo, bootstrap, cerulean, journal, flatly, readable, spacelab, united, lumen, paper, sandstone, simplex, yeti
orientation: columns
vertical_layout: fill
runtime: shiny
---

```{r global, include=FALSE}
### HIGHEST PRIORITY STILL TO DO:
# > Hydro-linked data pull no longer working. Check again in mid-March after USGS updates WQP API's
# > Test that package for web service pull
# > Add characteristic sets and water types >>> I really broadened the filter on line 2500 so user options need to be expanded too
# > Yellowstone's requested hydrograph
# > Documentation, links to data sources, 503 compliance, troubleshooting/FAQs page
# > Phase out the rgdal code completely
# > Maps and some others are not yet exportable
# > Put maps in function to minimize duplication
# > Add categorical color page back in and allow import of categ levels
# > Allow option to save filter settings with RDS and to update RDS data only
# > Add extensive error check page allowing user to omit site-parameters with issues
# > Sample size matrix and Explore data should NOT require data filter page. Retry plotly for sample size matrix, or yr on each facet
# > Test polite::bow() and rip()
# > Save RDS should be more default and obvious

# Overall
# -	There is a limit to how much data can be downloaded
# Home
# -	One character vector error messages
# 
# Time series
# -Map zoom slider should be much wider
# - Title and legend somteimtes don't fit
# - Add something to highlight current and other seletected years
# -	Dismiss button for view table should be on top
# -	Pie charts the expand card option disappears
# -	There is unnecessary x-andy-scroll for all these


### UPCOMING CHANGES:
# > rnoaa is not available for R3.2. This package is going to be phased out in 2024, so keep an eye out

# Install and load packages
rm(list=ls())

pkgs <- c("flexdashboard", 
          "shiny", 
          "knitr",  
          "here", 
          "tidyverse", 
          "janitor", 
          "mgcv", 
          "plyr", 
          "scales", 
          "rtf", 
          "rmarkdown", 
          "shinyWidgets", 
          "leaflet", 
          "plotrix", 
          "GGally", 
          "plotly", 
          "httr", 
          "jsonlite", 
          "tidyverse", 
          "readr", 
          "sp",
          "bslib", # for accordion panels
          "bsicons",
          "RgoogleMaps", # to set map zoom
          "sf", 
          "magrittr", 
          "leaflet.extras", 
          "lubridate", 
          "fontawesome", 
          "viridisLite", 
          "purrr",
          "stringr",
          "ggpubr", # for drawing separate legends
          "heatmaply", # for interactive heat plots
          "reactable", # for easy nested tables
          "htmltools", # for arranging plots in tab (browsable)
          "shinyFiles", # for user to save files in specified location
          "RColorBrewer", # to display brewer palettes
          "shinyjs", # for easy functions that use JavaScript
          "stringr", # to detect text snippets
          "sortable", # drag-and-drop rank input
          "tmaptools", # for flexible color mapping (get_brewer_pal)
          "DT", # for interactive tables
          "zoo", # for year-month
          "cowplot", # to get legends from plots
          "gridExtra", # for arranging plots and adding plot annotations (ggplotly can't do captions or subtitles)
          "RgoogleMaps", # for MaxZoom & MinZoom
          "geojsonio", # to test for presence of features
          "rnoaa", # to get NOAA climate data <<<<< THIS PACKAGE WILL RETIRE SOON. KEEP AN EYE ON THIS.
          "leaflet.minicharts",
          "polite") # for web etiquette with APIs

installed_pkgs <- pkgs %in% installed.packages()
if (length(pkgs[!installed_pkgs]) > 0) install.packages(pkgs[!installed_pkgs], repos = "https://cloud.r-project.org", dep=TRUE) 
invisible(lapply(pkgs, library, character.only = TRUE))

# Check for required dashboard files
req_files <- c("park_noaa_overlaps_list.RDS", "park_gage_overlaps_list.RDS", "parks_sf.RDS", "unique_parks_df.csv")
have_files <- list.files(path = here::here("dashboard_files"))
try(if(!all(req_files %in% have_files)) stop(paste("Missing required dashboard files in 'dashboard_files' subfolder:", setdiff(req_files, have_files))))

  # Read in park choice file
  unique_parks_df <- read_csv("dashboard_files/unique_parks_df.csv")

options(shiny.maxRequestSize = 20*1024^2, 
        timeout = 1000,
        stringsAsFactors = FALSE,
        dplyr.summarise.inform = FALSE
)
  
```

```{r css}
# Force modal to fill width of screen

# tags$style("#plot_tab .modal-dialog .modal-content .modal-body {
#   inline-size: 95%;
#   font-size: 12px;
#   max-width: 100%;
#   margins: 0;
#   padding: 0;
#   width: 2000px;
#   height: calc(100vh - 80px) !important;
# }")

# In flexboxes, force checkboxes to align with text
tags$style(".horiz_input .shiny-input-container {
  display: flex;
  flex-direction: row;
}")

# This forces datatable to fill height of modal
tags$style(".dataTables_scrollBody {
    height: calc(100vh - 180px) !important;
}")

# This sizes and positions the custom gif loading images
tags$style("dropdown-toggle {
           background-color:lightblue !important;
           padding:6px;
           }")

tags$style("#gif_modal .modal-body {padding:0px}
            #gif_modal .modal-dialog {width:auto; display:inline-block; position:absolute; top:35%;left:50%; transform:translate(-50%, -50%) !important;}
")

# This expands initial map to fill screen
tags$style("map {
           height: calc(100vh - 80px) !important;
           }")

# Call this to force an input value to reset to NULL
tags$script("
    Shiny.addCustomMessageHandler('setNull', function(variableName) {
      Shiny.setInputValue(id = variableName, value = null);
    });
  ")

# Call this to force an input value to reset to a specified value
tags$script("
    Shiny.addCustomMessageHandler('resetValue', function(message) {
      Shiny.setInputValue(message);
    });
  ")

# When an action button is disabled, text should be gray and button color light gray
tags$style(".btn.disabled {
  color:gray;
  background-color:light-gray;
}")

tags$style(".rank-list-title {
  font-size:14px;
  padding:4px;
}")

tags$style(".rank-list-item {
  font-size:14px;
  padding:4px;
}")

tags$style("table.dataTable tbody th, table.dataTable tbody td input.form-control {
    padding: 2px 5px; 
}") # reduce padding in data tables

tags$style(HTML(".shiny-output-error-validation {
  font-size:14px;
  color: #FF0000;
}")
) # validation text is in red. Could also add 'font-weight: bold;'

tags$style(".reactable {
font-size: 13px; 
}") # font size for reactable tables

tag.map.title <- tags$style(HTML("
  .leaflet-control.map-title { 
    text-align: center;
    font-weight: bold;
    background: rgba(255,255,255,0.75); # white box
    font-size: 21px;
    color: darkred;
  }
")) # add title to leaflet map

tags$style(".map-unitcode {
           font-weight: bold;
           background: rgba(255,255,255,0.75); # white box
           font-size:24px;
           }") # add bold park unit name/code to leaflet map

tags$style(".chart-stage-flex {
overflow: scroll !important;
}") # Helps ensure data table bottoms don't get cut off


```

```{r generic_action_buttons}
# Action to cancel modal
observeEvent(eventExpr = input$button_cancelModal, {
  removeModal()
  })
```

```{r functions}
### FUNCTIONS ----

# Web etiquette
polite_GET <- politely(httr::GET, verbose=TRUE) 

FuncAboutButton <- function(nam) {
  actionButton(nam, "   PAGE INSTRUCTIONS", icon = icon("question-sign", lib = "glyphicon"), width = "100%")
}

FuncShowWellPanel <- function(input_to_test, wp_to_toggle) {
  # Function to show or hide a well panel based on a checkbox selection
  #
  # Args:
  #   input_to_test:  The ID of the checkbox input, e.g., input$sel_ShowPanel
  #   wp_to_toggle:  ID of the well panel to toggle, e.g., wp_example
  #
  shiny::req(!is.null(rv$dat),!is.null(input_to_test))
  if(input_to_test) {
    shinyjs::showElement(wp_to_toggle)
    } else {
      shinyjs::hideElement(wp_to_toggle)
    }
  }

FuncAllNoneButtons <- function(cond, name_all, name_none) {
  # Function to create 'Select All' and 'Select None' action buttons
  #
  # Args:
  #   cond:  The input ID that needs to be defined for buttons to show (enter as input.XXX rather than as input$XXX)
  #   name_all:  ID to assign to 'Select All' button
  #   name_none:  ID to assign to 'Select None' button
  #
  conditionalPanel(
    condition = paste0("typeof ", cond, " !== 'undefined'"),
    actionButton(name_all, "Select All", style="color:black; display:inline-block; border:1px; padding:4px 12px;"),
    actionButton(name_none, "Select None", style="color:black; display:inline-block; border:1px; padding:4px 12px;")
  )
}

FuncCalcWaterSeasons <- function(dateVec){
  # Function to calculate water year from calendar date (modified from calcWaterSeasons function in package 'dataRetrieval')
  # POSIXlt years start at 100, POSIXlt months start at 0
  dateTimeVec <- as.POSIXlt(dateVec)
  calYear <- dateTimeVec$year + 1900
  calMon <- dateTimeVec$mon + 1
  
  # when the date is NA, it should not try to add 1
  whichPastOct <- calMon >= 10
  whichPastOct[is.na(whichPastOct)] <- FALSE
  
  # add one to the year if it is in October or after
  WaterSeasons <- calYear
  WaterSeasons[whichPastOct] <- calYear[whichPastOct] + 1
  
  return(WaterSeasons)
}

FuncBreakDates <- function(dat_df) {
  # Function to break dates into date categories
  #
  # Args:
  #   dat_df:  A data frame with the raw data. One column needs to be ActivityStartDate, which is date class with format yyyy-mm-dd
  #
  dat_df2 <- dat_df %>% 
    dplyr::mutate(
      YrDate = base::as.Date(cut(ActivityStartDate, breaks = "year")), # these maintain date class, so are useful for certain summaries
      MnthDate = base::as.Date(cut(ActivityStartDate, breaks = "month")),
      WkDate = base::as.Date(cut(ActivityStartDate, breaks = "week", start.on.monday = FALSE)), # Sunday start of week
      MeteoYr = as.integer(lubridate::year(ActivityStartDate)), # for other types of summaries
      WaterYr = as.integer(FuncCalcWaterSeasons(ActivityStartDate)),
      Season = factor(cut(lubridate::yday(ActivityStartDate),
                   breaks=c(-Inf, 59, 151, 243, 334, Inf),
                   labels=c("Winter","Spring","Summer", "Fall", "Winter")), levels = c("Spring","Summer", "Fall", "Winter")), # Meteorological Seasons: Spring=March 1 - May 31; Summer=June 1 - Aug 31; Fall=Sept1 - Nov30; Winter=Dec1 - Feb28
      Mnth = lubridate::month(ActivityStartDate, label = TRUE, abbr = TRUE),
      Wk = factor(lubridate::week(ActivityStartDate), levels = 1:52),
      DayOfYr = lubridate::yday(ActivityStartDate))
  dat_df2$Mnth = factor(dat_df2$Mnth, levels = levels(dat_df2$Mnth), ordered = FALSE)
  
  return(dat_df2)
}

FuncOrderCheck <- function(import = FALSE, filter_internal = FALSE, filter_external = FALSE, plot = FALSE) {

  # Function to check if data have been imported, filtered, and plot data summarized
    if(import) {
      shiny::validate(
     need(!is.null(rv$dat), message = "No data available. Please use the 'Get WQP Data' tab to first import or load water quality data."))}
  if(filter_internal) {
    shiny::validate(
    need(!is.null(rv_param_temp$subDat) & !is.null(rv_param_temp$subDatTypes), message = "From the left sidebar, choose a subset of data to work with"))}
  if(filter_external) {
    shiny::validate(
    need(!is.null(rv_param_temp$subDat) & !is.null(rv_param_temp$subDatTypes), message = "On the 'Define & Filter Data' page, please choose a subset of data to work with"))}
  if(plot) {
    shiny::validate(
    need(!is.null(rv_param_temp$plotDat), message = "On the 'Explore Data - Time Series' page, select characteristic set(s) and monitoring site(s) to plot and then click the green 'REFRESH PLOT DATA' button."))

  }
}

FuncCustomSeasons <- function(dat_df, seas) {
  # Function to assign USGS water year or custom seasons to ActivityStartDate
  #
  # Args:
  #   dat_df:  A data frame to modify. One column needs to be ActivityStartDate, which is date class with format yyyy-mm-dd
  #   seas: character string, "WaterSeasons" or "CustomSeasons"
  #
  dat_df$Season <- NA
  # assign the custom season names based on dates. Can't just use cut, in case the seasons aren't consecutive
  if(seas == "WaterSeasons") {
    df_CustomSeason <- data.frame(
      Name = c("Fall(WY)", "Winter(WY)", "Spring(WY)", "Summer(WY)"),
      RangeStart = as.Date("2018-01-01")-1 + c(274, 1, 91, 182),
      RangeEnd = as.Date("2018-01-01")-1 + c(265, 90, 181, 273))
  }
  if(seas == "CustomSeasons") {
    df_CustomSeason <- data.frame(
      Name = c(input$sel_Season1Name, input$sel_Season2Name, input$sel_Season3Name, input$sel_Season4Name),
      RangeStart = c(input$sel_Season1Range[1], input$sel_Season2Range[1], input$sel_Season3Range[1], input$sel_Season4Range[1]),
      RangeEnd = c(input$sel_Season1Range[2], input$sel_Season2Range[2], input$sel_Season3Range[2], input$sel_Season4Range[2]))
  }
  
  df_CustomSeason <- df_CustomSeason[df_CustomSeason$Name != "",] # if no name assigned, then it's not a season level
  for(i in 1:nrow(df_CustomSeason)) {
    Name <- df_CustomSeason$Name[i]
    StartDate <- lubridate::yday(df_CustomSeason$RangeStart[i])
    StartDate_LY <- lubridate::yday(gsub("^.{1,4}", "2000", df_CustomSeason$RangeStart[i])) # yday count is different for leap years
    EndDate <- lubridate::yday(df_CustomSeason$RangeEnd[i])
    EndDate_LY <- lubridate::yday(gsub("^.{1,4}", "2000", df_CustomSeason$RangeEnd[i])) # yday count is different for leap years
    
    
    if(StartDate < EndDate) {
      # for leap year
      dat_df$Season[lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) >= StartDate_LY & lubridate::yday(dat_df$ActivityStartDate) <= EndDate_LY] <- Name
      # for not leap year
      dat_df$Season[!lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) >= StartDate & lubridate::yday(dat_df$ActivityStartDate) <= EndDate] <- Name
    } else { # start yday is larger than end yday, it means it spans Dec 31-Jan 1
      # for leap year
      dat_df$Season[lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) >= StartDate_LY] <- Name
      dat_df$Season[lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) <= EndDate_LY] <- Name
      # for not leap year
      dat_df$Season[!lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) >= StartDate] <- Name
      dat_df$Season[!lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) <= EndDate] <- Name
    }
  }
  
  dat_df$Season <- factor(dat_df$Season, levels = df_CustomSeason$Name)
  return(dat_df)
}

FuncBaseMap <- function(maptype) {
    cbp1 <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7", "#0072B2", "#D55E00", "#999999", "#F0E442", "#000000", "chocolate4", "purple4", "chartreuse", "lightpink", "honeydew2") # Colorblind-friendly palette
  cat("in FuncBaseMap")
  cbp1_org <- switch((length(unique(rv$sitesPointsSub$OrganizationFormalName)) <= length(cbp1)) + 1,  colorRampPalette(cbp1)(length(unique(rv$sitesPointsSub$OrganizationFormalName))), cbp1[1:length(unique(rv$sitesPointsSub$OrganizationFormalName))])
  
  rv_param_temp$palOrg <- colorFactor(palette = cbp1_org, domain = unique(rv$sitesPointsSub$OrganizationFormalName), levels = unique(rv$sitesPointsSub$OrganizationFormalName))
  
  iconGages = makeAwesomeIcon(
    text = fa("water"),
    iconColor = "black",
    markerColor = "blue")
  
  iconMeteo = makeAwesomeIcon(
    icon= "fa-cloud", 
    library = "fa", 
    squareMarker = TRUE, 
    markerColor = "white")
  
  iconCWA = makeAwesomeIcon(
    icon= "fa-building", 
    library = "fa", 
    markerColor = "lightgray")
  
  iconGagesSelected = makeAwesomeIcon(
      text = fa("water"),
      iconColor = "black",
      markerColor = "orange")
  
  iconMeteoSelected = makeAwesomeIcon(
      icon= "fa-cloud", 
      library = "fa", 
      squareMarker = TRUE, 
      markerColor = "orange")
  cat("Creating base map")
  # Order map layers -- higher zIndex is on "top"
  map <- leaflet(options = leafletOptions(zoomControl = FALSE, zoomSnap = 0.25)) %>%
    addMapPane("pane_unitPoly", zIndex = 210) %>%
    addMapPane("pane_HUC", zIndex = 220) %>%
    addMapPane("pane_facilitiesPoints", zIndex = 225) %>%
    addMapPane("pane_meteoStations", zIndex = 230) %>%
    addMapPane("pane_gageStations", zIndex = 235) %>%
    addMapPane("pane_meteoStations_selected", zIndex = 240) %>%
    addMapPane("pane_gageStations_selected", zIndex = 245) %>%
    addMapPane("pane_availableStations", zIndex = 255) %>%
    addMapPane("pane_selectedStreamlines", zIndex = 257) %>%
    addMapPane("pane_selectedStations", zIndex = 260) %>% # always keep selected monitoring station points on "top" of map layers (highest zIndex)
    addMapPane("pane_selectedOrigin", zIndex = 265) %>%
    addTiles(options = tileOptions(noWrap = TRUE), group = "Street") %>%
    addProviderTiles("Esri.WorldImagery", options = providerTileOptions(noWrap = TRUE), group="Satellite") %>%
    addPolygons(data = rv$unitPoly, group = "NPS unit", color = "black", fillColor = "yellow", fillOpacity = 0.8, weight = 1, options = pathOptions(pane = "pane_unitPoly")) %>% # park unit outline
    addPolygons(data = rv[[rv$userSelect$sel_HUClevel]], group = rv$userSelect$sel_HUClevel, color = "blue", fillColor = "lightblue", fillOpacity = 0.6, weight = 0.5, layerId = ~HUC, options = pathOptions(pane = "pane_HUC")) %>% # HUC polygons
    addScaleBar() %>%
    addControl(rv$parkName, position = "topleft", className="map-unitcode") # add 4-letter UNIT code on map)
  
  # Conditional mapping (when data are available)
  
  init_sites <- subset(rv$sitesPointsSub, OrganizationFormalName %in% rv$userSelect$sel_Organization & MonitoringLocationTypeName %in% rv$userSelect$sel_SiteType)
  
  if(maptype == "initial") { # These are specific to the initial map
    cat("Map type is 'initial'")
    if(nrow(init_sites) > 0) { # Available water quality stations
  map %<>% addCircleMarkers(data = init_sites, group = "Available monitoring sites", label = ~SITELAB, popup = ~SITEPOP, radius = 4, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 0.8, stroke = TRUE, weight = 1, color = ~rv_param_temp$palOrg(OrganizationFormalName), opacity = 0.7, options = pathOptions(pane = "pane_availableStations"))
      } # WQ stations
                                                         
      if(!is.null(rv$selectedStations)) {
        sel_stations <- rv$sitesPointsSub %>% dplyr::filter(MonitoringLocationIdentifier %in% rv$selectedStations$MonitoringLocationIdentifier)

        if(nrow(sel_stations) > 0) {
          cat("Mapping selected sites")
    map %<>%
      addCircleMarkers(data = rv$sitesPointsSub %>% dplyr::filter(MonitoringLocationIdentifier %in% rv$selectedStations$MonitoringLocationIdentifier), group = "Selected monitoring sites", label = ~SITELAB, popup = ~SITEPOP, radius = 8, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 0.8, stroke = TRUE, weight = 4, color = "white", opacity = 1, options = pathOptions(pane = "pane_selectedStations"))
    }
      }

    
    if(!is.null(rv$selectedOriginStation) & !is.null(rv$userSelect$sel_SelectMethod)){ # the origin station for up-down selection is outlined in red
    if(rv$userSelect$sel_SelectMethod=="methodDist") {
      if(nrow(rv$sitesPointsSub[rv$sitesPointsSub$MonitoringLocationIdentifier == rv$selectedOriginStation$identifier,]) > 0) {
      map %<>% 
        addCircleMarkers(data = rv$sitesPointsSub[rv$sitesPointsSub$MonitoringLocationIdentifier == rv$selectedOriginStation$identifier,], group = "Selected monitoring sites", label = ~SITELAB, popup = ~SITEPOP, radius = 8, fillOpacity = 0, stroke = TRUE, weight = 4, color = "red", opacity = 1, options = pathOptions(pane = "pane_selectedOrigin"))}
    }
    }
    
  }
  
  # These are for any map type
   if(rv$userSelect$sel_SelectMethod=="methodHuc" & !is.null(rv$selectedHucs)) { # layer the selected polygons on map, if selection method is by HUC 
     cat("mapping HUCs")
     ### >>> ERROR BELOW: Error in writeImpl: Text to be written must be a length-one character vector--THIS OCCURS AFTER HAVING SELECTED POINTS
    map %<>%
      addPolygons(data = rv[[rv$userSelect$sel_HUClevel]][rv[[rv$userSelect$sel_HUClevel]]$HUC %in% rv$selectedHucs,], group = rv$userSelect$sel_HUClevel, color = "blue", fillColor = "lightblue", fillOpacity = 0.8, weight = 1.5, layerId = ~HUC, options = pathOptions(pane = "pane_HUC"))
   }
  
  if(!is.null(rv$selectedOriginStation) & !is.null(rv$userSelect$sel_SelectMethod)){
    if(rv$userSelect$sel_SelectMethod=="methodDist") {
    
    if(!is.null(rv$selectedDownstreamLines)) {
      map %<>%
        addPolylines(data = rv$selectedDownstreamLines, color = "#660000", weight = 2, opacity = 1, group = "Selected monitoring sites", options = pathOptions(pane = "pane_selectedStreamlines")) # downstream lines in brown
      }
    
    if(!is.null(rv$selectedUpstreamLines)) {
    map %<>%
        addPolylines(data = rv$selectedUpstreamLines, color = "#FFFFFF", weight = 2, opacity = 1, group = "Selected monitoring sites", options = pathOptions(pane = "pane_selectedStreamlines")) # upstream lines in blue
  }
    }
}
          
  if(!is.null(rv$gageStations)) { # Add USGS gage (streamflow) stations only if found
    map %<>%
      addAwesomeMarkers(icon = iconGages, data = rv$gageStations, group = "Gage stations", label = ~GAGELAB, popup = ~GAGEPOP, options = pathOptions(pane = "pane_gageStations")) # selected stream gage stations
  }

  if(!is.null(rv$meteoStations)) { # Add weather stations only if found
    map %<>%
      addAwesomeMarkers(icon = iconMeteo, data = rv$meteoStations, group = "Weather stations", label = ~METEOLAB, popup = ~METEOPOP, options = pathOptions(pane = "pane_meteoStations")) # weather stations
  }
  
  if(!is.null(rv$facilitiesPointsSub)) { # Add EPA-monitored discharge facilities only if found
    map %<>%
      addAwesomeMarkers(icon = iconCWA, data = rv$facilitiesPointsSub, group = "Discharge facilities", label = ~FACLAB, popup = ~FACPOP)
    }
  
  if(!is.null(rv$gageStations) & !is.null(rv$selectedGages)) { # Add selected USGS gage stations only if found
  if(all(rv$selectedGages$GageID %in% rv$gageStations$GageID)) { 
    
    map %<>%
      addAwesomeMarkers(icon = iconGagesSelected, data = rv$selectedGages, group = "Gage stations", label = ~GAGELAB, popup = ~GAGEPOP, options = pathOptions(pane = "pane_gageStations_selected"))
  }}
  
  if(!is.null(rv$meteoStations) & !is.null(rv$selectedMeteo)) {
    if(all(rv$selectedMeteo$MeteoID %in% rv$meteoStations$MeteoID)) {
      map %<>%
        addAwesomeMarkers(icon = iconMeteoSelected, data = rv$selectedMeteo, group = "Weather stations", label = ~METEOLAB, popup = ~METEOPOP, options = pathOptions(pane = "pane_meteoStations_selected"))
    }}
  return(map)
}

FuncUpdateHome <- function() {
  updateTextInput(session,
                  "sel_UnitCode",
                  value = "")
  
  updateSliderInput(session,
                    "sel_MapZoom", 
                    value = NULL)
  
  updateRadioButtons(session,
                     "sel_HUClevel",
                     selected = "HUC10")
  
  updateRadioButtons(session,
                     "sel_SelectMethod",
                     selected = "methodHuc")
  
  updateTextInput(session,
                  "sel_OriginStationID",
                  value = "")
  
  updateCheckboxGroupInput(session,
                           "sel_Organization",
                           choices = NULL,
                           selected = NULL)
  
  updateCheckboxGroupInput(session,
                           "sel_Gages",
                           choices = NULL,
                           selected = NULL)
  
  updateCheckboxGroupInput(session,
                           "sel_Meteo",
                           choices = NULL,
                           selected = NULL)
  
  # # Reset map center and map bounds to NULL
  session$sendCustomMessage(type = "setNull", message = "map_center")
  session$sendCustomMessage(type = "setNull", message = "map_bounds")
}

FuncUpdateFilter <- function() {
  updateRadioButtons(session,
                     "sel_DefineSeasons",
                     selected = "MeteoSeasons")
  
  updateSliderInput(session,
                    "sel_SeasonsStart",
                    value = as.Date("2018-01-01"))
  
  updateTextInput(session,
                  "sel_Season1Name",
                  value = "")
  
  updateTextInput(session,
                  "sel_Season2Name",
                  value = "")
  
  updateTextInput(session,
                  "sel_Season3Name",
                  value = "")
  
  updateTextInput(session,
                  "sel_Season4Name",
                  value = "")
  
  updateSliderInput(session,
                    "sel_YrRange",
                    min = NULL, 
                    max = NULL, 
                    step = NULL, 
                    value = NULL)
  
  updateNumericInput(session,
                     "sel_MinYrs",
                     value = 3)
  
  updateNumericInput(session,
                     "sel_MinStations",
                     value = 1)
  
  updateCheckboxGroupInput(session,
                           "sel_ActivityType",
                           selected = NULL)
  
  updateCheckboxGroupInput(session,
                           "sel_ResultStatus",
                           selected = NULL)
  
  
  updateCheckboxGroupInput(session,
                           "sel_SummaryOrg",
                           selected = sort(unique(rv$dat$OrganizationFormalName)))
}


FuncUpdateInputsOther <- function() {
    FuncUpdateFilter()
    
    updateSelectInput(session,
                    "sel_ShowChar",
                    choices = NULL,
                    selected = NULL)
    
    updateCheckboxGroupInput(session,
                           "sel_ShowStations",
                           choices = NULL,
                           selected = NULL)
    
    updateRadioButtons(session,
                       "sel_Categ",
                       choices = "none",
                       selected = "none")
}

# FuncUpdateTSMap <- function() {
#   if(!is.null(rv_param_temp$plotDat)) {
#      updateSliderTextInput(session,
#                         "sel_SurvYr",
#                         selected = max(rv_param_temp$plotDat$Yr, na.rm = TRUE))
#   }
#    
#   if(!is.null(rv$unitPoly)) {
#     updateSliderInput(session,
#                         "sel_ParamMapZoom",
#                       selected = min(RgoogleMaps::MaxZoom(lonrange = c(st_bbox(rv$unitPoly)$xmin, st_bbox(rv$unitPoly)$xmax), latrange = c(st_bbox(rv$unitPoly)$ymin, st_bbox(rv$unitPoly)$ymax))) - 1)
#   }
# }

# FuncUpdateTSPlots <- function() {
#   updateSelectInput(session,
#                     "sel_ShowThresholds",
#                     selected = "showthresh_none")
# 
#   updateSelectInput(session,
#                     "sel_AddGagePrecip",
#                     selected = "none")
# 
#   updateSelectInput(session,
#                     "sel_YScale",
#                     selected = "identity")
# 
#   updateSelectInput(session,
#                     "sel_Categ",
#                     selected = "none")
# 
#   updateSelectInput(session,
#                     "sel_ParamMapShow",
#                     selected = "show")
# 
#   updateCheckboxInput(session,
#                       "sel_FreeY",
#                       selected = FALSE)
# 
#   updateCheckboxInput(session,
#                       "sel_AddQuantile",
#                       selected = TRUE)
# 
#   updateCheckboxInput(session,
#                       "sel__PlotByStation",
#                       selected = TRUE)
# 
#   updateSliderInput(session,
#                     "sel_MapPointSize",
#                     selected = 0)
# }
FuncUpdateUserSelect <- function(inputs_to_update) {
  shiny::req(!is.null(rv$dat))
  input_list <- isolate(reactiveValuesToList(input)) # difficulties indexing reactive list, so convert to unreactive list first
  replacement_list <- input_list[inputs_to_update]
  names(replacement_list) <- inputs_to_update # adds list element name, even for NULL elements
  rv$userSelect <- modifyList(rv$userSelect, replacement_list, keep.null = TRUE) # update only the list elements in replacement_list
}
  
FuncDataTypes <- function(dat) {
  # Function to identify which characteristic names have non-numeric entries, and what those entries are
  #
  # Args:
  #   dat: The imported data frame. Requires columns CharacteristicName and ResultMeasureValue
  # 
  # Returns:
  #   Data frame with each characteristic name, best guess of data type (categorical or numeric), and the non-numeric entries
  temp_datatype <- dat %>%
    dplyr::select(CharacteristicName, ResultMeasureValue) %>%
    dplyr::group_by(CharacteristicName)
  
  temp_datatype_count <- temp_datatype %>%
    dplyr::summarise(NumRecords = n()) %>%
    dplyr::select(CharacteristicName, NumRecords)
  
  temp_datatype_categ <- temp_datatype %>%
    group_map(~sort(unique(na.omit(.x$ResultMeasureValue[which(is.na(suppressWarnings(as.numeric(gsub(",", "", .x$ResultMeasureValue)))))])))) # identify all non-numeric, non-NA entries for each characteristic. If it's a number with comma, removes the comma and still counts it as a number
  
  df_datatype <- as.data.frame.AsIs(temp_datatype_categ, stringsAsFactors=FALSE) %>% # unfortunately, I can't get the data table edit function to work with factor class variables
    dplyr::mutate(CharacteristicName = unique(dat$CharacteristicName),
                  DataType = ifelse(temp_datatype_categ %in% c("character(0)", "numeric(0)", "logical(0)"), "numeric", "categorical")) %>%
    rowwise() %>%
  mutate(NonNumericEntries = paste(temp_datatype_categ, collapse = " // ")) %>% # make sure using unique separator that wouldn't be part of any entry
    dplyr::select(-temp_datatype_categ) %>%
    dplyr::left_join(temp_datatype_count, by = "CharacteristicName") %>%
    arrange(DataType, CharacteristicName)
  df_datatype$DataType <- factor(df_datatype$DataType, levels = c("categorical", "numeric")) # only allows these entries
  return(df_datatype)
}

FuncFilterDat <- function() {
  # Function to filter data based on user input on filter page of dashboard. Add custom seasons, if applicable.
  #
  # Returns:
  #   Assigns to rv_param_temp$subDat, rv_param_temp$subDatYears
  #

  shiny::req(!is.null(rv$dat), !is.null(rv$userSelect$sel_Organization))
  if(all(unique(rv$dat$OrganizationFormalName) %in% rv$userSelect$sel_Organization)==FALSE) {
    rv_param_temp$subDatYears <- NULL
    rv_param_temp$subDat <- NULL
    } else {
      
      shiny::req(!is.null(input$sel_MinYrs), !is.null(input$sel_SummaryParam), !is.null(input$sel_SummaryOrg), !is.null(input$sel_YrRange), !is.null(input$sel_ActivityType), !is.null(input$sel_ResultStatus), !is.null(input$sel_DefineSeasons))
      cat("line720")
      rv_param_temp$seasonType <- switch(input$sel_DefineSeasons, MeteoSeasons = "Calendar Year (starts Jan. 1)", WaterSeasons = "Water Year (starts Oct. 1)", CustomSeasons = paste0("Custom Year (starts ", as.character(input$sel_Seasons, format="%b %d"), ")"))
                                
      filterDat <- rv$dat 
      if(input$sel_DefineSeasons=="MeteoSeasons") {
        filterDat$Yr <- as.integer(filterDat$MeteoYr)
        filterDat$Mnth <- factor(filterDat$Mnth,levels(rv$dat$Mnth))
      } else {
        filterDat$Yr <- as.integer(filterDat$WaterYr)
        filterDat$Mnth <- factor(filterDat$Mnth,levels(rv$dat$Mnth)[c(10,11,12,1:9)])
      }
      cat("line731")
      filterDat %<>%
        dplyr::filter(Yr >= as.integer(input$sel_YrRange[1]) & Yr <= as.integer(input$sel_YrRange[2]) & OrganizationFormalName %in% input$sel_SummaryOrg & CharacteristicName %in% input$sel_SummaryParam & ActivityTypeCode %in% input$sel_ActivityType & ResultStatusIdentifier %in% input$sel_ResultStatus)
      
      # Create ResultMeasureValue_replaced column that replaces values not detected
      
  filterDat$ResultMeasureValue_replaced <- as.numeric(filterDat$ResultMeasureValue)
  filterDat$ResultMeasureValue_replaced[filterDat$ResultDetectionConditionText != "Detected and Quantified" & is.na(filterDat$ResultMeasureValue) & !is.na(filterDat$DetectionQuantitationLimitMeasure.MeasureValue)] <-
      as.numeric(filterDat$DetectionQuantitationLimitMeasure.MeasureValue[filterDat$ResultDetectionConditionText != "Detected and Quantified" & is.na(filterDat$ResultMeasureValue) & !is.na(filterDat$DetectionQuantitationLimitMeasure.MeasureValue)]) # create a column in which the detection limit replaces NA, for records where result was above or below detection limit--this column will be used to calculate probability quantiles <<<<<<<<<<<<<<< INCLUDE THIS EXPLANATION IN DOCUMENTATION
  
      # Add threshold columns
      filterDat$ThreshCateg <- NA
    if(!is.null(rv_param_temp$threshList)) {
      
      for (t in names(rv_param_temp$threshList)) {
        which_rows <- which(filterDat$CharacteristicName == rv_param_temp$threshList[[t]]$CharacteristicName & filterDat$ResultMeasure.MeasureUnitCode == rv_param_temp$threshList[[t]]$ResultMeasure.MeasureUnitCode)
        if(length(which_rows) > 0) {
        filterDat$ThreshCateg[which_rows] <- as.character(cut(as.numeric(filterDat$ResultMeasureValue_replaced[which_rows]), breaks = rv_param_temp$threshList[[t]]$cut_breaks, labels = rv_param_temp$threshList[[t]]$cut_categ))
        }
      }
    } 
      cat("line763")
      # Assign custom seasons
      if(nrow(filterDat) > 0 & input$sel_DefineSeasons %in% c("WaterSeasons", "CustomSeasons"))
        {
        filterDat <- FuncCustomSeasons(dat_df = filterDat, seas = input$sel_DefineSeasons)
        }
      rv$userSelect$sel_DefineSeasons <- input$sel_DefineSeasons
      
      if(nrow(filterDat) > 0) {
        filterYears <- filterDat %>%
          dplyr::select(CharacteristicName, MonitoringLocationIdentifier, Yr) %>%
          dplyr::group_by(CharacteristicName, MonitoringLocationIdentifier) %>%
          dplyr::summarize(StartYr = as.integer(min(Yr, na.rm = TRUE)),
                           EndYr = as.integer(max(Yr, na.rm = TRUE)),
                           TotalSurveyYrs = dplyr::n_distinct(Yr),
                           NumRecords = n()) %>%
          dplyr::filter(TotalSurveyYrs >= input$sel_MinYrs)
      cat("line780")
        if(nrow(filterYears) > 0) { # if none of the data meet the minimum years criterion, these entries will be NULL
          rv_param_temp$subDat <- filterDat %>%
            right_join(filterYears[, c("CharacteristicName", "MonitoringLocationIdentifier")], by = c("CharacteristicName", "MonitoringLocationIdentifier")) # just keep the ones that met the data filter criteria for total survey years, so these are the raw data that are summarized in rv_param_temp$subDatYears
          rv_param_temp$subDatYears <- filterYears
          cat("line785")
  
        } else {
          rv_param_temp$subDat <- NULL
          rv_param_temp$subDatYears <- NULL
        }
      } else {
        rv_param_temp$subDat <- NULL
        rv_param_temp$subDatYears <- NULL
      }
      }
}

# FuncPlotlyHeatMap <- function(dat, y_name, facet_by_name, legend_name, is_discrete = FALSE, indiv_scale = FALSE) {
#   # Function to create plotly heatmaps. X-axis is always year. Using plot_ly because ggplotly can be slow for interactive heat plots b/c it doesn't recognize the input as a heatmap and creates a scatterplot where each rectangle is drawn separately with all the necessary attributes.
#   #
#   # Args:
#   #   dat: Data frame with these columns: Yr (for x-axis), Y, FillCol, FacetBy, HoverLabel. Both 'X' and 'FacetBy' should be factor class with levels specified.
#   #   y_name, facet_by_name, legend_name: Axis labels and facet and legend titles
#   #   is_discrete: TRUE if legend should be discrete (for counts), not continuous
#   #   indiv_scale: TRUE if each plot gets its own scale because the plots represent different water quality characteristics
#   #
#   # Returns:
#   #   Legend and heat map
#   #
# 
#   # Fill missing values
#   template <-
#     expand_grid(FacetBy = factor(levels(dat$FacetBy), levels = levels(dat$FacetBy)), Y = factor(levels(dat$Y), levels = levels(dat$Y)), Yr = min(dat$Yr, na.rm = TRUE):max(dat$Yr, na.rm = TRUE)) %>%
#     left_join(dat[c("FacetBy", "Y", "Yr", "FillCol", "HoverLabel")], by = c("FacetBy", "Y", "Yr")) %>%
#     dplyr::arrange(FacetBy, Y, Yr)
# 
#   # Calculate total and relative heights
#   total_page_ht <- max(2000, 60 + (30 * length(levels(dat$FacetBy)) * length(levels(dat$Y)))+15 + 30 * length(levels(dat$FacetBy)))
#   # total_page_ht <- 5000
# 
#   # Create color scale
#   min_colorval <- min(template$FillCol, na.rm = TRUE)
#   max_colorval <- max(template$FillCol, na.rm = TRUE) # make sure the range of color values is the same across all subplots
#   template_cols <- viridis(n = max_colorval - min_colorval + 1, alpha = 1, begin = 0, end = 1, direction = -1)
# 
#   # Create separate legend - hacky legend because plotly heatmaps can't generate horizontal colorbars
#   shared_legend <- grid.arrange(ggpubr::as_ggplot(
#     get_legend(
#       ggplot(template, aes(x = Yr, y = Y, fill = FillCol)) +
#         geom_tile() +
#         scale_fill_viridis_c(name = legend_name, direction=-1, begin = 0, end = 1) +
#         theme(legend.position = "top",
#               legend.key.width = unit(1, "cm"),
#               legend.text = element_text(size = 16, margin = margin(r = 2, unit = "cm")),
#               legend.title = element_text(size = 16)
#         )
#       )
#     )
#   )
# 
#   heatplot_list <- lapply(levels(template$FacetBy), function(i) {
#     # Data for this plot
#     subdat <- subset(template, FacetBy == i)
#     mat_values <- matrix(dplyr::pull(subdat, FillCol),
#                          nrow=length(unique(subdat$Y)),
#                          byrow = TRUE,
#                          dimnames = list(
#                            levels(template$Y),
#                            min(template$Yr, na.rm = TRUE):max(template$Yr, na.rm = TRUE)
#                            )
#     )
#     mat_hover <- matrix(dplyr::pull(subdat, HoverLabel), nrow=length(unique(subdat$Y)), byrow = TRUE)
#  shiny::req(!is.null(subdat), !is.null(mat_hover))
#   # Create heatmap
#     # none of the margin arguments are helpful
#     if(sum(!is.na(subdat$FillCol)) > 0) {
#       heat_subplot <- heatmaply(
#         mat_values,
#         column_text_angle = 0,
#         grid_gap = 1,
#         colors = template_cols,
#         limits = c(min_colorval, max_colorval),
#         dendrogram = "none",
#         # main = paste0("# of Survey Events, by Year and ", y_name, " for each ", facet_by_name),
#         subplot_margin = 15,
#         margins = c(15, 15, 15, 15),
#         ylab = y_name,
#         xlab = rv_param_temp$seasonType,
#         xaxis_font_size = "22pt",
#         yaxis_font_size = "22pt",
#         height = total_page_ht,
#         hide_colorbar = TRUE,
#         custom_hovertext = mat_hover,
#         key.title = "# of Survey Events",
#         plot_method = "plotly") %>%
#         add_annotations( # add plot subtitle
#           text = paste0(facet_by_name, ":  ", i),
#           xref = "paper",
#           yref = "paper",
#           x = -0.02,
#           y = 1,
#           xanchor = "left",
#           yanchor = "bottom", # y anchor uses 'middle', x anchor uses 'center'
#           showarrow = FALSE,
#           font=list(size=16, family = "Arial")
#         )
#       }
#     }) %>% purrr::discard(is.null) # remove null list elements
# 
#   shiny::req(!is.null(heatplot_list))
# 
#   # Format heatmap page
#   plotly_heatmap <-
#      plotly::subplot(
#       heatplot_list,
#       nrows = length(heatplot_list),
#       shareX = TRUE, # if set to FALSE, x-axis labels will overlap subplot title
#       shareY = FALSE,
#       titleX = TRUE,
#       titleY = FALSE,
#       heights = rep(1/length(heatplot_list), length(heatplot_list)),
#       which_layout = 1
#     ) %>%
#       layout(
#           margin = list(
#           t=45,
#           b=15,
#           l= 80,
#           r=40)
#           )
#   return_list <- list(shared_legend = shared_legend, plotly_page = plotly_heatmap)
#   return(return_list)
# }

FuncPlotHeatMap <- function(dat, y_name, legend_range, legend_name) {
  # Function to create static heatmaps. X-axis is always year.
  #
  # Args:
  #   dat: Data frame with these columns: Yr (for x-axis), Y, FillCol, MonitoringLocationIdentifier.
  #   y_name, legend_name: Axis labels and legend titles
  #   
  # Returns:
  #   Static heat maps
  #

  # Create color scale
    # min_colorval <- legend_range[1]
    max_colorval <- legend_range[2] # make sure the range of color values is the same across all plots
    template_cols <- viridisLite::viridis(n = max_colorval, alpha = 1, begin = 0, end = 1, direction = -1)
  
    # # Calculate relative heights--This is generic to allow switching back to format where all characteristics are shown in a single page
    # sites_per_char <- dat %>% dplyr::arrange(CharacteristicName) %>% dplyr::distinct(CharacteristicName, MonitoringLocationIdentifier) %>% dplyr::count(CharacteristicName) %>% dplyr::ungroup() 
    # sites_per_char <- sites_per_char[order(sites_per_char$CharacteristicName),] %>% dplyr::pull(n) # For some absurd reason, dplyr::arrange() is not competent in sorting so using base R to sort
    
    # temp_distinct <- dat %>%
      # dplyr::select(CharacteristicName, MonitoringLocationIdentifier, TimeUnit) %>% dplyr::distinct()
    # rel_char_hts <- prop.table(sites_per_char) ### YES!!! This gets the heights correct. No need to try to account for title or x-axis labels, etc.--it's already adjusted for

  # A ggplot object with NO data.  Omit the characteristic from the facet_grid call
  p <- ggplot(dat) +
    aes(x = Yr, y = TimeUnit, fill = FillCol) +
    geom_tile(color = "gray") +
    geom_text(aes(label = FillCol, colour = ifelse(FillCol > 5, "white", "black"))) +
    scale_colour_manual(values=c("white"="white", "black"="black"), guide = "none") +
    xlab(rv_param_temp$seasonType) +
    ggtitle(paste0(unique(dat$CharacteristicName), " (# of surveys per ", input$sel_TimeSubunit, ")")) +
    scale_x_continuous(expand=c(0, 0), breaks = min(dat$Yr, na.rm = TRUE):max(dat$Yr, na.rm = TRUE), limits = c(min(dat$Yr, na.rm = TRUE)-1, max(dat$Yr, na.rm = TRUE)+1)) + # Need to make limits wider b/c otherwise the fill color will be missing from the end columns. Setting the expand cuts out the empty space at beginning and end columns
    scale_y_discrete(limits = rev) +
        # scale_fill_viridis_c(direction = -1, na.value = "white", limits=c(1, max_colorval), name = legend_name) +
    scale_fill_viridis_c(direction = -1, na.value = "white", limits=c(1, 12), oob=scales::squish, breaks = seq(1, 12, by = 2), name = legend_name) +
    theme_bw(base_size = 14) +
    facet_wrap(~MonitoringLocationIdentifier, ncol =1) +
    theme(legend.position="top",
          plot.title = element_text(size = 22),
          axis.text.x = element_text(angle = 90, hjust = 1)) +
    theme(plot.margin=unit(c(3,3,1,2),"lines"))
cat("779")
#   # Build a separate graphic for each Characteristic
#   char_list <- lapply(sort(unique(dat$CharacteristicName)), function(i) {
#     p %+% 
#       subset(dat, CharacteristicName == i) + ggtitle(paste0(i, " (# of surveys per ", input$sel_TimeSubunit, ")"))
#     })
#   names(char_list) <-sort(unique(dat$CharacteristicName))
#   cat("785")
#   # Build as Grobs and plot via gridExtra::grid.arrange
#   final_heat_plots <- char_list %>%
#     lapply(ggplotGrob) %>%
#     arrangeGrob(grobs = ., heights = rel_char_hts) %>%
#     grid.arrange(., ncol = 1)
# cat("791")
#   return(final_heat_plots)
return(p)
}

FuncParamAvailSites <- function(sel) {
  shiny::req(!is.null(rv$sitesPointsSub), !is.null(rv_param_temp$subDat))
  if(sel == "by_station") {
    avail_sites <- rv$sitesPointsSub[rv$sitesPointsSub$MonitoringLocationIdentifier %in% unique(rv_param_temp$subDat$MonitoringLocationIdentifier),]
  } 
  if(sel == "by_char") {
    shiny::req(!is.null(input$sel_ShowChar))
    avail_sites <- rv$sitesPointsSub[rv$sitesPointsSub$MonitoringLocationIdentifier %in% unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowChar]),]
    
  }
    return(avail_sites)
}

FuncPlotlyPieMatrix <- function(dat, discrete_cols, discrete_levels, plot_title) {
  # Function to create plotly pie chart matrix of Threshold or Percentile categories, grouped by monitoring site (row) and year (col)
  #
  # Args:
  #   dat:  Plot data with percentile/threshold classifications
  #   discrete_cols: For discrete fill, the vector of colors
  #   discrete_levels: For discrete fill, the levels corresponding with colors
  #   plot_title: Title for plot page
  #
  # Returns:
  #   Page of plotly pie charts
  #
  fig <- plot_ly(textfont = list(size = 25))
  colors_list <- split(discrete_cols, discrete_levels)
  m <- list(
    l = 300,
    r = 90,
    b = 100,
    t = 100,
    pad = 0
  )
  
  dat$Color <- dplyr::recode(dat$CategVar, !!!colors_list)
  yr_vec <- seq(from = min(dat$Yr, na.rm = TRUE), to = max(dat$Yr, na.rm = TRUE), by = 1)
  
  
  for(row_num in 1:length(unique(dat$RowLev))) {
    row_filter <- sort(unique(dat$RowLev))[row_num]
    for(yr_num in 1:length(yr_vec)) {
      this_yr <- yr_vec[yr_num]
      pie_dat = subset(dat, RowLev == row_filter & Yr == this_yr)
      if(nrow(pie_dat)>0) {  
      fig <- fig %>% 
        add_pie(data = pie_dat,
                name = paste0(row_filter, "_", this_yr),
                labels = ~CategVar, 
                values = ~n,
                textposition = 'inside',
                textinfo = 'label+percent',
                insidetextfont = list(color = switch(("yellow" %in% discrete_cols)+1, "white", "black")),
                hoverinfo = 'text',
                text = ~HoverLabel,
                marker = list(colors = ~Color, line = list(color = '#FFFFFF', width = 1)),
                domain = list(row = row_num-1, column = yr_num-1))
    }
  }
  }
  
  width_px <- 390 + (110 * length(yr_vec)) # this is the plot width (paper)
  height_px <- 200 + (110 * length(unique(dat$RowLev))) # this is the plot height (paper)

  yr_seq_px <- seq(55, width_px-390, by = 110)/(110 * length(yr_vec)) # this is where year labels should align on x-axis, when reference is "paper"
  y_seq_px <- seq(55, height_px-55, length.out = length(unique(dat$RowLev)))/height_px
  title_loc <- 1 + (90/height_px) #it's into the top margin space, when reference is "container"
  legend_loc <- 1 + (50/height_px)
  yrs_loc_bottom <- -1 * (50/height_px)
  
  yr_labels_bottom <- list(
  text = as.list(as.character(yr_vec)),
  xref = "paper",
  yref = "container",
  yanchor = "center",
  xanchor = "center",
  font =list(size = 14),
  align = "right",
  x = yr_seq_px,
  y = yrs_loc_bottom,
  showarrow = FALSE)
  
  y_labels_left <- list(
    text = as.list(sort(unique(dat$RowLev), decreasing = TRUE)),
    xref = "paper",
    yref = "paper",
    xanchor = "right",
    yanchor = "center",
    font =list(size = 14),
    align = "center",
    x = -0.02,
    y = y_seq_px,
    showarrow = FALSE)
  
  fig_final <- fig %>% layout(
    margin = m,
    title = list(
      text = plot_title,
      x = 0.5,
      y = title_loc,
      xref = "container", # gets cut off if referenced to the plot only ("paper")
      yref = "paper",
      xanchor = "center",
      yanchor = "center"),
    showlegend = TRUE,
    legend = list(
      orientation = "h",
      x = 0.5,
      xref = "container",
      yref = "paper",
      xanchor = "center",
      y = legend_loc,
      yanchor = "center"),
    grid=list(
      rows=length(unique(dat$RowLev)),
      columns=length(yr_vec)),
    width = width_px,
    height = height_px,
    autosize = FALSE,
    annotations = y_labels_left) 
  
  fig_final <- fig_final %>% layout(annotations = yr_labels_bottom)

  fig_final
  return(fig_final)
}

FuncPlotDat <- function() {
  # Function to format plot data based on user selections on plot page
  #
  # Returns:
  #   Formatted plot data

  shiny::req(!is.null(rv_param_temp$subDat), !is.null(rv_param_temp$sel_summarize_by))
  # Filter plotting data by user inputs
  plotDat <- rv_param_temp$subDat %>%
    dplyr::select(ActivityStartDate, CharacteristicName, CharacteristicSet, DetectionQuantitationLimitMeasure.MeasureValue, MonitoringLocationIdentifier, OrganizationFormalName, ResultDetectionConditionText, DetectionQuantitationLimitTypeName, ResultMeasureValue, ResultMeasureValue_replaced, ResultMeasure.MeasureUnitCode, ResultSampleFractionText, ThreshCateg, YrDate, MnthDate, WkDate, Yr, Season, Mnth, Wk, DayOfYr) %>% # just keep these columns
    dplyr::filter(MonitoringLocationIdentifier %in% rv_param_temp$showStations & CharacteristicSet %in% rv_param_temp$showCharSets)
  plotDat$ResultMeasureValue <- as.numeric(plotDat$ResultMeasureValue)
  plotDat$DetectionQuantitationLimitMeasure.MeasureValue <- as.numeric(plotDat$DetectionQuantitationLimitMeasure.MeasureValue)
  
    # If coloring by categorical characteristics
    if(!is.null(input$sel_Categ)) {
      if(input$sel_Categ != "none") {
        if(rv_param_temp$sel_summarize_by == "by_char") {
          shiny::validate(
            need(input$sel_CombineSites == FALSE, message = "Cannot color points by a categorical characteristic when multiple monitoring sites are combined in a single plot. Please UNSELECT the checkbox for 'Combine sites in one plot'"))
        }
        shiny::req(!is.null(rv_param_temp$categLevelsPlot))
        shiny::validate(
          need(input$sel_Categ %in% unique(rv_param_temp$categLevelsPlot$CharacteristicName), message = "The selected categorical characteristic is not recognized as a categorical characteristic in the dataset. Please first add it to the categorical definitions file."))
        plotCategDat <- rv$dat %>% # pulling from the original data
          dplyr::filter(CharacteristicName == input$sel_Categ) %>%
          dplyr::select(OrganizationFormalName, ActivityStartDate, MonitoringLocationIdentifier, CategName = CharacteristicName, CategResultMeasureValue = ResultMeasureValue) %>%
          dplyr::distinct(.)

        plotDat %<>% dplyr::left_join(plotCategDat, by = c("OrganizationFormalName", "MonitoringLocationIdentifier", "ActivityStartDate"))
        plotDat$CategResultMeasureValue <- as.factor(plotDat$CategResultMeasureValue)
        cat("line1034")
      }
    }
    
    # Assign custom threshold limits
    if(!is.null(rv_param_temp$sel_show_thresholds) & !is.null(input$sel_ThreshUnit) & !is.null(input$sel_ThreshLower) & !is.null(input$sel_ThreshUpper) & !is.null(plotDat)) {
    if(rv_param_temp$sel_show_thresholds == "showthresh_custom" & rv_param_temp$sel_summarize_by == "by_char") {

      plotDat$ThreshCateg <- NA
      rv_param_temp$threshCustom <- list()
      
    if(input$sel_ThreshLower != -9999 | input$sel_ThreshUpper != 9999) { # if a lower or upper threshold has been entered
      thresh_ID <- paste0(unique(na.omit(rv_param_temp$plotDat$CharacteristicName)), " (", input$sel_ThreshUnit, ")")
      if(input$sel_ThreshLower == -9999) { # no lower limit
        temp_cut <- c(-Inf, input$sel_ThreshUpper, Inf)
        temp_categ <- c("good", "above")
        temp_colors <- c("#56B4E9", "#E69F00")
      }
      
      if(input$sel_ThreshUpper == 9999) { # no upper limit
        temp_cut <- c(-Inf, input$sel_ThreshLower, Inf)
        temp_categ <- c("below", "good")
        temp_colors <- c("lightgray", "#56B4E9")
      }
      
      if(input$sel_ThreshLower != -9999 & input$sel_ThreshUpper != 9999) { # has lower and upper limit
        temp_cut <- c(-Inf, input$sel_ThreshLower, input$sel_ThreshUpper, Inf)
        temp_categ <- c("below", "good", "above")
        temp_colors <- c("lightgray", "#56B4E9", "#E69F00")
      }
      
    temp_thresh_custom <- list(
      "CharacteristicName" = unique(na.omit(plotDat$CharacteristicName)),
      "ResultMeasure.MeasureUnitCode" = input$sel_ThreshUnit,
      "cut_breaks" = temp_cut,
      "cut_categ" = temp_categ,
      "cut_colors" = temp_colors
    )
    rv_param_temp$threshCustom[[thresh_ID]] <- temp_thresh_custom
    
    # Fill ThreshCateg column in plotDat
    shiny::req(!is.null(rv_param_temp$threshCustom))
    which_rows <- which(plotDat$CharacteristicName == rv_param_temp$threshCustom[[1]]$CharacteristicName & plotDat$ResultMeasure.MeasureUnitCode == rv_param_temp$threshCustom[[1]]$ResultMeasure.MeasureUnitCode)
    if(length(which_rows) > 0) {
      plotDat$ThreshCateg[which_rows] <- as.character(cut(as.numeric(plotDat$ResultMeasureValue_replaced[which_rows]), breaks = rv_param_temp$threshCustom[[1]]$cut_breaks, labels = rv_param_temp$threshCustom[[1]]$cut_categ))
        }
      }
    }
      }# end assign custom threshold limits

    # Determine quantiles for plots
  if(any(input$sel_AddQuantile == FALSE, is.null(input$sel_QuantileProbLower), is.null(input$sel_QuantileProbUpper))) {
      rv_param_temp$quantDat <- NULL
    } else {

      if(rv_param_temp$sel_summarize_by == "by_station" | (rv_param_temp$sel_summarize_by == "by_char" & input$sel_QuantileGroupBy == "quant_each"))  { # if 'by_station' or if 'by_char' and calculating separate quantile for each station, then group data by station-characteristicname
        rv_param_temp$quantDat <- plotDat %>%
          dplyr::select(MonitoringLocationIdentifier, CharacteristicName, ResultMeasureValue_replaced) %>%
          dplyr::group_by(MonitoringLocationIdentifier, CharacteristicName) %>%
          dplyr::summarise(QuantLineLower = quantile(ResultMeasureValue_replaced, probs = input$sel_QuantileProbLower, na.rm = TRUE),
                    QuantLineUpper = quantile(ResultMeasureValue_replaced, probs = input$sel_QuantileProbUpper, na.rm = TRUE)) # data frame where each row has a monitoring station ID and the value for the user-defined quantile probability
      }
      
      if(rv_param_temp$sel_summarize_by == "by_char" & input$sel_QuantileGroupBy == "quant_all") { # if 'by_char' and calculating one quantile across all stations
        rv_param_temp$quantDat <- data.frame(
          MonitoringLocationIdentifier = sort(unique(plotDat$MonitoringLocationIdentifier)),
          CharacteristicName = sort(unique(plotDat$CharacteristicName)),
          QuantLineLower = as.numeric(quantile(plotDat$ResultMeasureValue_replaced, probs = input$sel_QuantileProbLower, na.rm = TRUE)),
          QuantLineUpper = as.numeric(quantile(plotDat$ResultMeasureValue_replaced, probs = input$sel_QuantileProbUpper, na.rm = TRUE)),
          stringsAsFactors = FALSE)
      }
    }

    # Finalize the plotDat
    # Add quantDat columns
    if(!is.null(rv_param_temp$quantDat)) {
        plotDat2 <- plotDat %>%
          left_join(data.frame(rv_param_temp$quantDat), by = setdiff(names(rv_param_temp$quantDat), c("QuantLineLower", "QuantLineUpper"))) %>%
          dplyr::mutate(PercCateg = ifelse(ResultMeasureValue_replaced > QuantLineUpper, "above", ifelse(ResultMeasureValue_replaced < QuantLineLower, "below", ifelse(ResultMeasureValue_replaced >= QuantLineLower & ResultMeasureValue_replaced <= QuantLineUpper, "between", NA))))
        plotDat2$PercCateg <- factor(plotDat2$PercCateg, levels = c("below", "between", "above"))
    } else {
      plotDat2 <- plotDat %>%
        dplyr::mutate(PercCateg = NA)
    }
  
    return(plotDat2)
  }
 
FuncGageDat <- function(gage_station) {
  # Function to summarize gage data for plotting
  #
  # Args:
  #   gage_station: Name of the gage station to summarize data of
  #
  # Returns:
  #   Streamflow data for the selected gage station, and limited to the range of dates for which data will be plot

  shiny::req(!is.null(rv_param_temp$plotDat), !is.null(rv$gagesDat), !is.null(rv$userSelect$sel_DefineSeasons))
  shiny::validate(need(gage_station %in% unique(rv$gagesDat$GageName), message = "Streamflow data not available for the selected gage station"))
  gageDat <- subset(rv$gagesDat, GageName == gage_station & ActivityStartDate >= min(rv_param_temp$plotDat$ActivityStartDate, na.rm = TRUE) & ActivityStartDate <= max(rv_param_temp$plotDat$ActivityStartDate, na.rm = TRUE)) %>%
    dplyr::ungroup()
  
  # Assign custom seasons if applicable
  if(nrow(gageDat) > 0 & rv$userSelect$sel_DefineSeasons %in% c("WaterSeasons", "CustomSeasons"))
    {
    gageDat <- FuncCustomSeasons(dat_df = gageDat, seas = rv$userSelect$sel_DefineSeasons)
  }
  
  # Assign water year if applicable
  if(rv$userSelect$sel_DefineSeasons=="WaterSeasons") {
    gageDat$Yr <- gageDat$WaterYr
    gageDat$Mnth <- factor(gageDat$Mnth, levels(gageDat$Mnth)[c(10,11,12,1:9)])
    } else {
      gageDat$Yr <- gageDat$MeteoYr
      gageDat$Mnth <- factor(gageDat$Mnth, levels(rv$dat$Mnth))
    }
  
  if(!is.null(gageDat) & sum(!is.na(gageDat$MeanDailyDischarge)) == 0) {
        showModal(modalDialog(
          title = "No Data",
          "Streamflow data for the selected gage station do not overlap the timespan of water quality data."
          # , footer = modalButton("OK")
          ))
    gageDat <- NULL
        }
    
  return(gageDat)
} 

FuncPrecipDat <- function(precip_station) {
  # Function to summarize precipitation data for plotting. Use mean rather than total for each month, in case missing data
  #
  # Args:
  #   precip_station: Name of the precipitation station to summarize data of
  #
  # Returns:
  #   Precipitation data for the selected weather station, and limited to the range of dates for which data will be plot

  shiny::req(!is.null(rv_param_temp$plotDat), !is.null(rv$meteoDat), !is.null(rv$selectedMeteo))
  shiny::validate(need(precip_station %in% unique(rv$meteoDat$MeteoName), message = "Precipitation data not available for the selected weather station"))
  precipDat <- subset(rv$meteoDat, MeteoShortID == rv$selectedMeteo$MeteoShortID[rv$selectedMeteo$MeteoName == precip_station] & ActivityStartDate >= min(rv_param_temp$plotDat$ActivityStartDate, na.rm = TRUE) & ActivityStartDate <= max(rv_param_temp$plotDat$ActivityStartDate, na.rm = TRUE)) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(MeteoName = precip_station)
  
    # Assign custom seasons if applicable
  if(nrow(precipDat) > 0 & rv$userSelect$sel_DefineSeasons %in% c("WaterSeasons", "CustomSeasons"))
    {
    precipDat <- FuncCustomSeasons(dat_df = precipDat, seas = rv$userSelect$sel_DefineSeasons)
  }
  
  # Assign water year if applicable
  if(rv$userSelect$sel_DefineSeasons=="WaterSeasons") {
    precipDat$Yr <- precipDat$WaterYr
    precipDat$Mnth <- factor(precipDat$Mnth, levels(precipDat$Mnth)[c(10,11,12,1:9)])
    } else {
      precipDat$Yr <- precipDat$MeteoYr
      precipDat$Mnth <- factor(precipDat$Mnth, levels(rv$dat$Mnth))
    }

  return(precipDat)
} 

FuncPlotlyFormat <- function(plotly_list, plotly_title, subplot_titles_vec = NULL, xlab, shared_ylab = NULL, shared_ylab_position = NULL, ylab_vec = NULL, total_height, top_margin = 60, bottom_margin = 20, left_margin = 80, right_margin = 60, hover_tip = "text", is_grouped_boxplots = FALSE) { # <<<<< CHANGE BACK TO "text" FOR HOVER_TIP
  # Function to arrange interactive plots from a list. Necessary because plotly does not format well just with grid.arrange or ggplot faceting
  #
  # Args:
  #   plotly_list: Lists of ggplots that will be generated as a set.
  #   plotly_title: Title for plot set.
  #   subplot_titles_vec: Vector of subplot titles
  #   xlab: X-axis label.
  #   shared_ylab: A single y-axis label to be shared across all subplots.
  #   shared_ylab_position: A number (usually negative) indicating location of a shared y-axis label
  #   ylab_vec: Vector of y-axis labels
  #   total_height: Total height for the plot set.
  #   top_margin...right_margin: Margin sizes that will be used for the final page
  #   hover_tip: Argument for ggplotly--what will show on hover
  #   is_grouped_boxplots: Logical--need additional code if grouped boxplots
  #
  # Returns:
  #   Formatted plotly for a set of plots
  # 
  out_list <- list()
  for(p in 1:length(plotly_list)) {
    temp_plot <- ggplotly(
      plotly_list[[p]],
      tooltip = hover_tip,
      height = total_height
      ) %>% # specify the total plot height here because this layout will be applied to the entire page
        # highlight(.,
        #           on = "plotly_click", 
        #           off = "plotly_doubleclick",
        #           color = I("red"), 
        #           selectize = TRUE,
        #           persistent = TRUE,
        #           opacityDim = .3,
        #           dynamic = FALSE,
        #           selected = attrs_selected(showlegend = FALSE)
        #           ) %>% # linked brushing
      layout(
        title = list( # this is the title for the page
          font = list(size = 20), 
          text = plotly_title,
          margin = list( l = 10, r = 10, b = 80, t = 20, pad = 4 )), 
        margin = list(
          t=top_margin,
          b=bottom_margin,
          l= left_margin,
          r=right_margin),
        xaxis = list(
          title = xlab,
          titlefont = list(size = 14),
          font = list(size = 16, family = "Arial"),
          showspikes = TRUE,
          spikemode  = "across", # draw line across plots and to x-axis
          spikedash = "solid",
          spikecolor = "gray",
          spikesnap = "data",
          spikethickness = 2))
    
    # If adding a shared y-axis title...
    if(!is.null(shared_ylab)) {
      temp_plot %<>%
        layout(
          annotations = list(
            x = shared_ylab_position,
            y = 0.55,
            text = shared_ylab,
            showarrow = F, 
            xref="paper",
            yref="paper",
            xanchor="left",
            yanchor="middle",
            textangle=-90,
            font=list(size=16, family = "Arial", color="black")
          ))
      }
    
    # If adding subplot titles...
    if(!is.null(subplot_titles_vec)) {
      temp_plot %<>%
        layout(
          annotations = list(
            text = subplot_titles_vec[[p]],
            xref = "paper",
            yref = "paper",
            yanchor = "top",
            xanchor = "middle",
            x = 0.5,
            y = 1.2,
            showarrow = FALSE,
            font=list(size=16, family = "Arial", color="black")
          ))
    }
    
    # If adding individual y-axis titles...
    if(!is.null(ylab_vec)) {
      temp_plot %<>% 
        layout(
          yaxis = list(
            title = ylab_vec[p], 
            titlefont = list(size = 14),
            font = list(size = 16, family = "Arial")) # font size and family for y-axis
        )
    }
    
    if(is_grouped_boxplots) { # if boxplots for multiple stations, all combined
      temp_plot %<>% layout(boxmode = "group") # Will generate a false warning -- this is a known, unresolved issue with plotly (issue was closed due to low priority)
    }
    
    out_list[[p]] <- plotly::hide_legend(temp_plot) # this doesn't work for heatmap continuous colors
  }
  return(out_list)
}

FuncQuantLines <- function(quant_df, combine_sites, dat_df, p) {
  if(!is.null(quant_df)) {
    if(nrow(quant_df)>0) {
      # ...if stations will all be in a single plot and quantLine is by station...
      if(rv_param_temp$sel_summarize_by == "by_char" & combine_sites==TRUE & length(unique(dat_df$MonitoringLocationIdentifier)) > 1) {
        if(length(unique(quant_df$QuantLineLower)) > 1 | length(unique(quant_df$QuantLineUpper)) > 1) {
          showModal(modalDialog(
            title = "Percentile by Monitoring Site",
            "When combining monitoring sites in a plot, the percentile limits must be calculated across all sites rather than by individual sites"
            ))
          shiny::req(length(unique(quant_df$QuantLineLower)) == 1, length(unique(quant_df$QuantLineUpper)) == 1)
        }
        }
      p <- p +
        geom_hline(data = quant_df %>% dplyr::filter(CharacteristicName==sort(unique(dat_df$CharacteristicName)) & MonitoringLocationIdentifier==sort(unique(dat_df$MonitoringLocationIdentifier))), aes(yintercept = QuantLineLower), linetype = "dashed", color = "red") +
        geom_hline(data = quant_df %>% dplyr::filter(CharacteristicName==sort(unique(dat_df$CharacteristicName)) & MonitoringLocationIdentifier==sort(unique(dat_df$MonitoringLocationIdentifier))), aes(yintercept = QuantLineUpper), linetype = "solid", color = "red")
    }
  }
  return(p)
  }

FuncAddThresh <- function(v_char, thresh, p, xlow_temp = NULL, xhigh_temp = NULL, ylow_temp, yhigh_temp) {
  # Function to add threshold background color
  #
  # Args:
  #   v_char:  Characteristic Name
  #   thresh: NULL or the list for threshold background colors for this site-char
  #   p: Base plot
  #   xlow_temp, xhigh_temp, ylow_temp, yhigh_temp: lower/upper x/y limits for threshold box
  #
  # Returns:
  #   Plot with threshold background
  #
    for (i in 1:length(thresh$cut_categ)) {
      ylow = max(thresh$cut_breaks[i], ylow_temp)
      yhigh = min(thresh$cut_breaks[i+1], yhigh_temp)
      if(ylow <= yhigh) {
        fill_col = thresh$cut_colors[i]
        p <- p +
          geom_rect(data = data.frame(ylow, yhigh), aes(xmin = xlow_temp, xmax = xhigh_temp, ymin = ylow, ymax = yhigh), fill = fill_col, alpha = 0.15, show.legend = FALSE, inherit.aes = FALSE)
      }
    } # threshold background boxes
  return(p)
}


FuncPlotScatter <- function(plot_dat, quant_df = NULL, categ_df = NULL, x_nam = "ActivityStartDate", combine_sites, fixed_free_y = "fixed", add_loess = TRUE, incl_cens = FALSE, thresh_list = NULL, rotate_x = FALSE, gage_dat = NULL, precip_dat = NULL, month_summary = FALSE, sel_add_gage_precip = switch(is.null(rv_param_temp$sel_add_gage_precip)+1, rv_param_temp$sel_add_gage_precip, "none"), sel_categ, trans_log_y) {
  # Function to generate scatterplot of data, with censored values shown as dotted intervals
  #
  # Args:
  #   plot_dat:  A data frame with the raw data
  #   quant_df:  A data frame with quantile probability limits for each station
  #   categ_df: NULL or the imported categorical levels dataframe
  #   x_nam: Column name for x-axis variable
  #   combine_sites:  TRUE to combine multiple stations in a single plot of a characteristic
  #   fixed_free_y:  Are scales fixed or free across all plots?
  #   add_loess:  Add loess smooth? (will be biased by censored data)
  #   incl_cens: Should censored data be plot as intervals?
  #   thresh_list: NULL or the list for threshold background colors
  #   rotate_x: should x-axis labels be rotated?
  #   gage_dat: USGS gage station data, if streamflow plot should be included: otherwise, NULL
  #   precip_dat: weather station data, if precipitation plot should be included; otherwise, NULL
  #
  # Returns:
  #   List of scatterplot
  # 

  shiny::req(sum(!is.na(plot_dat$y)) > 0) # make sure there are data

  # All plots share a single x-axis. Don't need to do this for other x_nam because those are factors with specified levels.
if(x_nam == "ActivityStartDate") {
  xaxes_min = min(plot_dat$x, na.rm = TRUE)
  xaxes_max = max(plot_dat$x, na.rm = TRUE)
}

  # Create column for point shape
  plot_dat %<>% dplyr::mutate(
    pointShape = factor(ifelse(ResultDetectionConditionText == "Detected and Quantified", "quant", "censored"))) # filled circle (shape = 16) if the datum was detected and quantified, otherwise open circle (shape 1)

  # Create the water quality plot(s)
  p1_points_list <- list()
  cat("line1434")
  
  if(rv_param_temp$sel_summarize_by == "by_char" & combine_sites==TRUE) {
    unique_df <- plot_dat %>% dplyr::select(CharacteristicName) %>% dplyr::distinct()
  } else {
    unique_df <- plot_dat %>% expand(CharacteristicName, MonitoringLocationIdentifier) %>% arrange(CharacteristicName, MonitoringLocationIdentifier) # data frame of unique characteristic-sites
  cat("line586")
  }
  
  char_vec <- unique_df$CharacteristicName
  cat("line588")
  for (v in 1:nrow(unique_df)) { # for each characteristic-site
    dat_df <- plot_dat %>%
      dplyr::filter(CharacteristicName == unique_df$CharacteristicName[v])
    
    trans_y <- ifelse(all(!is.null(trans_log_y), unique_df$CharacteristicName[v] %in% trans_log_y), "log", "identity")
    
    if("MonitoringLocationIdentifier" %in% names(unique_df)) {
      dat_df %<>% 
        dplyr::filter(MonitoringLocationIdentifier == unique_df$MonitoringLocationIdentifier[v])
    }
               
    cat("line592")
    # Shared y-axes range
    yaxes_min_temp = switch(all(fixed_free_y=="fixed", length(unique(unique_df$CharacteristicName)) < 2)+1, min(dat_df$y, dat_df$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE), min(plot_dat$y, plot_dat$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE)) # y axis limits. If only one characteristic name and free_fixed_y=="fixed", calculate y-axis limits from the full plot_dat
    shiny::req(!is.null(yaxes_min_temp))
    yaxes_min = switch((yaxes_min_temp <= 0)+1, 0.9*yaxes_min_temp, yaxes_min_temp - 0.1)
    yaxes_max = switch(all(fixed_free_y=="fixed", length(unique(unique_df$CharacteristicName)) < 2)+1, 1.1*max(dat_df$y, dat_df$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE), 1.1*max(plot_dat$y, plot_dat$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE))
    cat("line1448")
    
    # Set up the plot...
    if(x_nam=="ActivityStartDate") {
      # p_points <- ggplot(data = dat_df %>% plotly::highlight_key(~Yr), aes(x = x, y = y)) + 
      p_points <- ggplot(data = dat_df, aes(x = x, y = y)) +
        scale_x_date(date_breaks = "1 year", date_labels = "%Y", limits = c(xaxes_min, xaxes_max))
    } else { # For seasonal plots
      dat_df$x <- as.numeric(dat_df$x)
      p_points <- ggplot(data = dat_df, aes(x = x, y = y))
      
      if(x_nam %in% c("DayOfYr", "Wk")) {
        p_points <- p_points + 
        scale_x_continuous(breaks = scales::breaks_pretty())
        } else { # for categorical x-axis
          p_points <- p_points +
          scale_x_continuous(breaks = 1:length(levels(plot_dat$x)), labels = levels(plot_dat$x))
        }
        }
    
   cat("line1465") 
    # If adding threshold background...
  if(!is.null(thresh_list)) {

    thresh_ID <- paste0(unique_df$CharacteristicName[v], " (", unique(na.omit(dat_df$ResultMeasure.MeasureUnitCode)), ")")
    if(!is.null(thresh_list[[thresh_ID]])) {
    p_points <- FuncAddThresh(v_char = unique_df$CharacteristicName[v], thresh = thresh_list[[thresh_ID]], p = p_points, xlow_temp = switch((x_nam=="ActivityStartDate")+1, 0.5, xaxes_min), xhigh_temp = switch((x_nam=="ActivityStartDate")+1, length(levels(plot_dat$x)) + 0.5, xaxes_max), ylow_temp = yaxes_min, yhigh_temp = yaxes_max)}
  }
    cat("line623")
    # ...if coloring by a categorical characteristic, set up the data...
  if(sel_categ != "none" & !is.null(categ_df)) {
    levs <- unlist(base::strsplit(str_replace_all(categ_df$CategOrder[categ_df$CharacteristicName == sel_categ], "[()]", ""), split="//")) # these are the categorical levels from the category import file--pull from there rather than from data to ensure no levels are omitted just because they were not in the data
    levels_ok <- all(na.exclude(unique(plot_dat$CategResultMeasureValue[plot_dat$CategName == sel_categ])) %in% levs)
    shiny::req(!is.null(levels_ok))
     if(!levels_ok) { # Discontinue if category levels in data don't match levels in imported category file
        showModal(modalDialog(
          title = "Categorical levels mismatch",
          paste0("At least one categorical level found in the data (", paste(sort(na.exclude(unique(plot_dat$CategResultMeasureValue[plot_dat$CategName == sel_categ]))), collapse = ", "), ") is not included in the levels imported from the  category file (", paste(sort(levs), collapse = ", "), "). Please amend the category file to match the data."))
        )}
    dat_df$CategResultMeasureValue <- factor(dat_df$CategResultMeasureValue, levels = levs)
    cols <- unlist(base::strsplit(str_replace_all(categ_df$CategColor[categ_df$CharacteristicName == sel_categ], "[()]", ""), split="//"))
    names(cols) <- levs # create a named color vector to use as palette
 cat("line1488")
    p_points <- p_points +
      suppressWarnings(geom_point(aes(shape = pointShape, color = CategResultMeasureValue, fill = CategResultMeasureValue, text = paste0("Characteristic Set: ", CharacteristicSet, "<br>Monitoring Site: ", MonitoringLocationIdentifier, "<br>Survey Date: ", ActivityStartDate, "<br><br>X-value: ", x, "<br>Parameter Value: ", y, "<br>Detection Level: ", ResultDetectionConditionText, "<br>Categorical Level: ", CategResultMeasureValue)), size = 2, show.legend = c(fill = FALSE, color = TRUE, shape = FALSE))) + # aesthetic text is for ggplotly tooltip. Gives warning that it's not recognized but it still works and it's the only way to also allow geom_smooth (weird)
      scale_fill_manual(values = cols, na.value = "black", drop = FALSE) +
      scale_color_manual(name = paste0(sel_categ, "     "), limits = levs, values = cols, na.value = "black", drop = FALSE) # specifying all possible values in limits is required to make sure they are not dropped from legend when not in data
  } else {

      # ..if combining sites for a single characteristic, so coloring by monitoring site...
      if(rv_param_temp$sel_summarize_by == "by_char" & combine_sites==TRUE) { # if coloring by monitoring site, use viridis color scale
        p_points <- p_points +
          suppressWarnings(geom_point(aes(shape = pointShape, color = MonitoringLocationIdentifier, fill = MonitoringLocationIdentifier, text = paste0("Characteristic Set: ", CharacteristicSet, "<br>Monitoring Site: ", MonitoringLocationIdentifier, "<br>Survey Date: ", ActivityStartDate, "<br><br>X-value: ", x, "<br>Parameter Value: ", y, "<br>Detection Level: ", ResultDetectionConditionText)), size = 2, show.legend = c(fill = FALSE, color = TRUE, shape = FALSE))) + # this will give a false unknown aesthetics warning for 'text'
          scale_fill_viridis_d() +
          scale_color_viridis_d(name = "Site")
      } else { # ...if not coloring the points...
      p_points <- p_points +
        suppressWarnings(geom_point(aes(shape = pointShape, text = paste0("Characteristic Set: ", CharacteristicSet, "<br>Monitoring Site: ", MonitoringLocationIdentifier, "<br>Survey Date: ", ActivityStartDate, "<br><br>X-value: ", x, "<br>Parameter Value: ", y, "<br>Detection Level: ", ResultDetectionConditionText)), size = 2, color = "black", show.legend = FALSE))
      }
  }
  cat("line1506")
  # Shape the points for quantified vs. censored data
    p1_points <- p_points +
      scale_shape_manual(values = c("quant" = 16, "censored" = 1))
  
  # If including censored data...
  if(incl_cens) {
    dat_cens <- subset(dat_df, ResultDetectionConditionText %in% c("Present Below Quantification Limit", "Not Detected", "Present Above Quantification Limit"))
    if(nrow(dat_cens) > 0) {
      dat_cens$segment_start <- dat_cens$segment_end <- NA
      dat_cens$segment_start[dat_cens$ResultDetectionConditionText %in% c("Not Detected", "Present Below Quantification Limit")] <- yaxes_min # left-censored data
      dat_cens$segment_end[dat_cens$ResultDetectionConditionText %in% c("Not Detected", "Present Below Quantification Limit")] <- dat_cens[dat_cens$ResultDetectionConditionText %in% c("Not Detected", "Present Below Quantification Limit"), "DetectionQuantitationLimitMeasure.MeasureValue", drop = TRUE]
      dat_cens$segment_start[dat_cens$ResultDetectionConditionText == "Present Above Quantification Limit"] <- dat_cens[dat_cens$ResultDetectionConditionText == "Present Above Quantification Limit", "DetectionQuantitationLimitMeasure.MeasureValue", drop = TRUE]
      dat_cens$segment_end[dat_cens$ResultDetectionConditionText == "Present Above Quantification Limit"] <- yaxes_max
      p1_points <- p1_points +
        geom_segment(data = dat_cens, aes(x = x, xend = x, y = segment_start, yend = segment_end), linewidth = 0.25, linetype = "dotted")
    }
  }

  cat("line1533")  
    # If adding loess smooth...
  if(add_loess) {
    # If plotting all stations on one plot, color by station
    if(rv_param_temp$sel_summarize_by == "by_char" & combine_sites==TRUE) {
      p1_points <- p1_points + 
        geom_smooth(aes(color = MonitoringLocationIdentifier, fill = MonitoringLocationIdentifier), method = "loess", se = FALSE, size = 0.5, alpha = 0.3, show.legend = FALSE, na.rm = TRUE, fullrange = FALSE) +
        coord_cartesian(ylim = c(c(yaxes_min, yaxes_max)))

      } else {
        p1_points <- p1_points + 
          geom_smooth(method = "loess", se = FALSE, size = 0.5, alpha = 0.3, show.legend = FALSE, na.rm = TRUE, fullrange = FALSE) +
          coord_cartesian(ylim = c(c(yaxes_min, yaxes_max)))
      }
    }
    
    # If plotting percentile lines...
    p1_points <- FuncQuantLines(quant_df = quant_df, combine_sites = combine_sites, dat_df = dat_df, p = p1_points)
cat("line1551")  

  # Final formatting of plots
  p1_points <- p1_points +
    scale_y_continuous(trans = trans_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks(), limits = c(yaxes_min, yaxes_max)) + # alternatively, can use 'coord_cartesian(ylim = c(yaxes_min, yaxes_max))' to zoom in to the limits rather than "cutting off" the limits, as setting limits within scale_y_continuous() would do 
    theme_bw(base_size = 14) +
    {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
    {if(rotate_x) {theme(axis.title.x = element_text(margin = margin(t = 10, r = 0, b = 0, l = 0)))}} +
    theme(axis.title.y = element_blank(),
          legend.position = "top",
          legend.text = element_text(size = 16),
          legend.title = element_text(size = 16))
  
  # Add monitoring site as facet label if separate plot per site
  if(combine_sites==FALSE) { 
    p1_points <- p1_points +
      facet_wrap(. ~ MonitoringLocationIdentifier, drop = TRUE, ncol = 1)
  }
  
  p1_points_list[[v]] <- p1_points
  }
  
  ## If adding streamflow plot... ----
  if(sel_add_gage_precip == "streamflow" & !is.null(gage_dat)) {
    trans_gage_y <- ifelse(all(!is.null(trans_log_y), "streamflow" %in% trans_log_y), "log", "identity")
    
    if(x_nam=="ActivityStartDate") {
      if(month_summary == TRUE) {
        gage_dat <- gage_dat %>%
        dplyr::mutate(x = MnthDate + 14) %>% # plot at mid-point of month (on x-axis) for streamflow time series
        dplyr::group_by(GageName, x) %>%
        dplyr::summarise(MnthMean_MeanDailyDischarge = round(mean(MeanDailyDischarge, na.rm = TRUE), 2), # summarize mean daily discharge for each month
                MnthMax_MeanDailyDischarge = round(max(MeanDailyDischarge, na.rm = TRUE), 2)) %>%
        dplyr::ungroup()
        
        gage_plot <- ggplot(gage_dat, aes(x = x)) +
        suppressWarnings(geom_line(aes(y = MnthMean_MeanDailyDischarge, group = 1, text = paste0("Gage Name: ", GageName, "<br>Mid-month date: ", x, "<br>Mean daily discharge (cfs), MEAN for month: ", MnthMean_MeanDailyDischarge)), linetype = "solid", colour = "blue")) +
        suppressWarnings(geom_line(aes(y = MnthMax_MeanDailyDischarge, group = 1, text = paste0("Gage Name: ", GageName, "<br>Mid-month date: ", x, "<br>Mean daily discharge (cfs), MAX for month: ", MnthMax_MeanDailyDischarge)), linetype = "dashed", colour = "blue")) + # for time series point plots, present data summarized by month
          scale_x_date(date_breaks = "1 year", date_labels = "%Y", limits = c(xaxes_min, xaxes_max))
      } else { # just plot the points
        gage_plot <- ggplot(gage_dat, aes(x = ActivityStartDate, y = MeanDailyDischarge)) +
        suppressWarnings(geom_point(aes(text = paste0("Gage Name: ", GageName, "<br>Survey date: ", ActivityStartDate, "<br><br>Mean daily discharge (cfs): ", MeanDailyDischarge)))) + 
        scale_x_date(date_breaks = "1 year", date_labels = "%Y", limits = c(xaxes_min, xaxes_max))
        
        # If loess smooth and NOT monthly summary...
        if(add_loess) {
          gage_plot <- gage_plot + 
            geom_smooth(method = "loess", se = FALSE, size = 0.5, alpha = 0.3, show.legend = FALSE) +
            coord_cartesian(ylim = c(c(yaxes_min, yaxes_max)))
        } 
        }
    } else { # if seasonal plot...
        gage_dat$x <- as.numeric(gage_dat$x)
        gage_plot <- ggplot(gage_dat, aes(x = x, y = MeanDailyDischarge)) +
          suppressWarnings(geom_point(aes(text = paste0("Gage Name: ", GageName, "<br>Survey date: ", ActivityStartDate, "<br><br>X-value: ", x, "<br>Mean daily discharge (cfs): ", MeanDailyDischarge)), alpha = 0.5))
        
        # if(x_nam=="DayOfYr") {
        if(x_nam %in% c("DayOfYr", "Wk")) {
          gage_plot <- gage_plot +
            # scale_x_continuous(breaks = seq(from = 0, to = 366, by = 20))
            scale_x_continuous(breaks = scales::breaks_pretty())
          } else {
            gage_plot <- gage_plot +
          scale_x_continuous(breaks = 1:length(levels(plot_dat$x)), labels = levels(plot_dat$x))
          }
        
        # If loess smooth...
        if(add_loess) {
          gage_plot <- gage_plot + 
            stat_smooth(se = TRUE, level = 0.95, size = 0.5, alpha = 0.3, show.legend = FALSE)
        }
        }
    
    # Final formatting of streamflow plot...
    gage_plot <- gage_plot +
      scale_y_continuous(trans = trans_gage_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks()) +
        theme_bw(base_size = 14) +
        {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
        theme(axis.title.x = element_blank(),
              axis.title.y = element_blank(),
              legend.position = "none") +
        facet_wrap(. ~ GageName, ncol = 1) + # add the name as facet label
       theme(strip.background = element_rect(fill="lightblue")) # use different color facet strip background to distinguish from water characteristic plots
    } else {
    gage_plot <- NA # blank data frame
    }
  cat("line1642")
   ## If adding precipitation plot... ----
  if(sel_add_gage_precip == "precipitation" & !is.null(precip_dat)) {
    
    trans_precip_y <- ifelse(all(!is.null(trans_log_y), "precipitation" %in% trans_log_y), "log", "identity")
    
    if(x_nam=="ActivityStartDate") {
      if(month_summary == TRUE) {
      precip_dat <- precip_dat %>%
        dplyr::mutate(x = MnthDate + 14) %>% # plot at mid-point of month (on x-axis) for precipitation time series
        dplyr::group_by(MeteoName, x) %>%
        dplyr::summarise(AvgPrecip_cm = round(mean(PRCP_cm, na.rm = TRUE), 2), # summarize precipitation for each month
                MaxPrecip_cm = round(max(PRCP_cm, na.rm = TRUE), 2)) %>%
        dplyr::ungroup()

      precip_plot <- ggplot(precip_dat, aes(x = x)) +
        suppressWarnings(geom_line(aes(y = AvgPrecip_cm, group = 1, text = paste0("Weather Station Name: ", MeteoName, "<br>Mid-month date: ", x, "<br>Daily precipitation (cm), MEAN for month: ", AvgPrecip_cm)), linetype = "solid", colour = "blue")) +
        suppressWarnings(geom_line(aes(y = MaxPrecip_cm, group = 1, text = paste0("Weather Station Name: ", MeteoName, "<br>Mid-month date: ", x, "<br>Daily precipitation (cm), MAX for month: ", MaxPrecip_cm)), linetype = "dashed", colour = "blue")) + # for time series point plots, present data summarized by month
        scale_x_date(date_breaks = "1 year", date_labels = "%Y", limits = c(xaxes_min, xaxes_max))
      } else { # just plot the points
      precip_plot <- ggplot(precip_dat, aes(x = ActivityStartDate, y = PRCP_cm)) +
        suppressWarnings(geom_point(aes(text = paste0("Weather Station Name: ", MeteoName, "<br>Survey date: ", ActivityStartDate, "<br><br>Daily precipitation (cm): ", PRCP_cm)))) + 
        scale_x_date(date_breaks = "1 year", date_labels = "%Y", limits = c(xaxes_min, xaxes_max))
      
      # If loess smooth and NOT monthly summary...
      if(add_loess) {
        precip_plot <- precip_plot + 
          geom_smooth(method = "loess", se = FALSE, size = 0.5, alpha = 0.3, show.legend = FALSE)
      } 
      }
      } else { # if seasonal plot...
        precip_dat$x <- as.numeric(precip_dat$x)
        precip_plot <- ggplot(precip_dat, aes(x = x, y = PRCP_cm)) +
          suppressWarnings(geom_point(aes(text = paste0("Weather Station Name: ", MeteoName, "<br>Survey date: ", ActivityStartDate, "<br><br>X-value: ", x, "<br>Daily precipitation (cm)): ", PRCP_cm)), alpha = 0.5))
        
        # if(x_nam=="DayOfYr") {
                if(x_nam %in% c("DayOfYr", "Wk")) {
          precip_plot <- precip_plot +
            # scale_x_continuous(breaks = seq(from = 0, to = 366, by = 20))
            scale_x_continuous(breaks = scales::breaks_pretty())
          } else {
            precip_plot <- precip_plot +
              scale_x_continuous(breaks = 1:length(levels(plot_dat$x)), labels = levels(plot_dat$x))
          }
    
    # If loess smooth...
    if(add_loess) {
      precip_plot <- precip_plot +
        geom_smooth(method = "loess", se = FALSE, size = 0.5, alpha = 0.3, show.legend = FALSE)
    }
  }
    
    # Final formatting of precipitation plot...
    precip_plot <- precip_plot +
      scale_y_continuous(trans = trans_precip_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks()) +
        theme_bw(base_size = 14) +
        {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
        theme(axis.title.x = element_blank(),
              axis.title.y = element_blank(),
              legend.position = "none") +
        facet_wrap(. ~ MeteoName, ncol = 1) + # add the name as facet label
       theme(strip.background = element_rect(fill="lightblue")) # use different color facet strip background to distinguish from water characteristic plots
    } else {
    precip_plot <- NA # blank data frame
  }
  cat("line1712")
  return_list <- list(p1_points_list, char_vec, gage_plot, precip_plot)
  return(return_list)
  }

FuncPlotBox <- function(plot_dat, quant_df = NULL, x_nam = "Yr", combine_sites = FALSE, fixed_free_y = "fixed", add_loess = TRUE, incl_cens = FALSE, thresh_list = NULL, rotate_x = FALSE, gage_dat = NULL, precip_dat = NULL, sel_add_gage_precip = switch(is.null(rv_param_temp$sel_add_gage_precip)+1, rv_param_temp$sel_add_gage_precip, "none"), trans_log_y) {
  # Function to generate boxplots of data, with reporting limits marked as dotted horizontal lines
  #
  # Args:
  #   plot_dat:  A data frame with the raw data
  #   quant_df:  A data frame with quantile probability limits for each station
  #   x_nam: Column name for x-axis variable. For time series, this is "Yr"
  #   combine_sites:  TRUE to combine multiple stations in a single plot of a characteristic
  #   fixed_free_y:  Are scales fixed or free across all facets?
  #   incl_cens: Should reporting limits be marked as dotted horizontal lines?
  #   thresh_list: NULL or the list for threshold background colors
  #   rotate_x: should x-axis labels be rotated?
  #   gage_dat: USGS gage station data, if streamflow plot should be included: otherwise, NULL
  #   precip_dat: weather station data, if precipitation plot should be included; otherwise, NULL
  #   
  # Returns:
  #   List of boxplots
  # 
  
  shiny::req(sum(!is.na(plot_dat$y)) > 0) # make sure there are data
  
  # Create the water quality plot(s)
  p1_box_list <- list()
  
  if(rv_param_temp$sel_summarize_by == "by_char" & combine_sites==TRUE) {
    unique_df <- plot_dat %>% dplyr::select(CharacteristicName) %>% dplyr::distinct()
  } else {
    unique_df <- plot_dat %>% expand(CharacteristicName, MonitoringLocationIdentifier) %>% arrange(CharacteristicName, MonitoringLocationIdentifier) # data frame of unique characteristic-sites
  }
  
  char_vec <- unique_df$CharacteristicName
  
  for (v in 1:nrow(unique_df)) { # for each characteristic-site
    dat_df <- plot_dat %>%
      dplyr::filter(CharacteristicName == unique_df$CharacteristicName[v])
    
    trans_y <- ifelse(all(!is.null(trans_log_y), unique_df$CharacteristicName[v] %in% trans_log_y), "log", "identity")
    
    if("MonitoringLocationIdentifier" %in% names(unique_df)) {
      dat_df %<>% 
        dplyr::filter(MonitoringLocationIdentifier == unique_df$MonitoringLocationIdentifier[v])
    }
  
  # Thresholds for detection limits--draw these lines on plot, if within the range of y axes
  y_upperQL <- ifelse(any(!is.na(dat_df$DetectionQuantitationLimitMeasure.MeasureValue[dat_df$ResultDetectionConditionText == "Present Above Quantification Limit"])),  min(dat_df$DetectionQuantitationLimitMeasure.MeasureValue[dat_df$ResultDetectionConditionText == "Present Above Quantification Limit"], na.rm = TRUE), NA) # lowest upper quantification limit -- These may change through time, and we are only going to show the most conservative value 
  
  y_lowerQL <- ifelse(any(!is.na(dat_df$DetectionQuantitationLimitMeasure.MeasureValue[dat_df$ResultDetectionConditionText %in% c("Not Detected", "Present Below Quantification Limit")])), max(dat_df$DetectionQuantitationLimitMeasure.MeasureValue[dat_df$ResultDetectionConditionText %in% c("Not Detected", "Present Below Quantification Limit")], na.rm = TRUE), NA) # highest lower quantification limit

  # Shared y-axes range
  yaxes_min_temp = switch((fixed_free_y=="fixed" & length(unique(unique_df$CharacteristicName)) < 2)+1, min(dat_df$y, dat_df$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE), min(plot_dat$y, plot_dat$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE)) # y axis limits. If only one characteristic name and free_fixed_y=="fixed", calculate y-axis limits from the full plot_dat
  yaxes_min = ifelse(yaxes_min_temp <= 0, yaxes_min_temp - 0.1, 0.9*yaxes_min_temp)
  yaxes_max = switch((fixed_free_y=="fixed" & length(unique(unique_df$CharacteristicName)) < 2)+1, 1.1*max(dat_df$y, dat_df$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE), 1.1*max(plot_dat$y, plot_dat$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE))
  
  # Set up the plot..
  p_box <- ggplot(data = dat_df, aes(x = x, y = y)) 
  
  # if(x_nam=="DayOfYr") {
  if(x_nam %in% c("DayOfYr", "Wk")) {
    p_box <- p_box +
      # scale_x_discrete(breaks = seq(from = 0, to = 366, by = 20))
    scale_x_discrete(breaks = scales::breaks_pretty())
  } else {
    p_box <- p_box +
      scale_x_discrete(drop = FALSE)
  }
  
  # If adding threshold background...
  if(!is.null(thresh_list)) {
    
    thresh_ID <- paste0(unique_df$CharacteristicName[v], " (", unique(na.omit(dat_df$ResultMeasure.MeasureUnitCode)), ")")
    if(!is.null(thresh_list[[thresh_ID]])) {
      
    p_box <- FuncAddThresh(v_char = unique_df$CharacteristicName[v], thresh = thresh_list[[thresh_ID]], p = p_box, xlow_temp = 0.5, xhigh_temp = length(levels(plot_dat$x)) + 0.5, ylow_temp = yaxes_min, yhigh_temp = yaxes_max)
    }
    }
    
  # If combining sites for a single characteristic, so coloring by monitoring site...
  if(rv_param_temp$sel_summarize_by == "by_char" & combine_sites==TRUE) { # if coloring by monitoring site, use viridis color scale
    p1_box <- p_box +
      geom_boxplot(aes(fill = MonitoringLocationIdentifier), alpha = 0.4, show.legend = c(fill = TRUE)) +
      scale_fill_viridis_d(name = "Site") + 
      guides(fill = guide_legend(direction = "horizontal")) # can't seem to turn legend horizontal with theme(legend...)
    } else {
      p1_box <- p_box + geom_boxplot()
    }
  
  # If including censored data...
  if(incl_cens) {
    if(!is.na(y_lowerQL) & y_lowerQL >= yaxes_min) { # add LQL line
      p1_box <- p1_box +
        geom_hline(yintercept = y_lowerQL, linetype = "dotted", color = "gray")
      }
    if(!is.na(y_upperQL) & y_upperQL <= yaxes_max) { # add UQL line
      p1_box <- p1_box +
        geom_hline(yintercept = y_upperQL, linetype = "dotted", color = "black")
    }
    }
  
  # If plotting percentile lines...
  p1_box <- FuncQuantLines(quant_df = quant_df, combine_sites = combine_sites, dat_df = dat_df, p = p1_box)
  
  # Final formatting of plots
  
  p1_box <- p1_box +
    scale_y_continuous(trans = trans_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks(), limits = c(yaxes_min, yaxes_max))  +
    theme_bw(base_size = 14) +
    {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
    {if(rotate_x) {theme(axis.title.x = element_text(margin = margin(t = 10, r = 0, b = 0, l = 0)))}} +
    theme(axis.title.y = element_blank())
  
  # Add monitoring site as facet label if separate plot per site
  if(combine_sites==FALSE) {
    p1_box <- p1_box +
      facet_wrap(. ~ MonitoringLocationIdentifier, drop = TRUE, ncol = 1)
    }
  
  p1_box_list[[v]] <- p1_box
  }
  
  # If adding streamflow plot...
  if(sel_add_gage_precip == "streamflow" & !is.null(gage_dat)) {
    trans_gage_y <- ifelse(all(!is.null(trans_log_y), "streamflow" %in% trans_log_y), "log", "identity")
    
    gage_box <- ggplot(gage_dat, aes(x = x, y = MeanDailyDischarge)) + 
      geom_boxplot() +
      {if(x_nam == "DayOfYr") {scale_x_discrete(breaks = seq(from = 0, to = 366, by = 20))} else {scale_x_discrete(drop = FALSE)}} +
      scale_y_continuous(trans = trans_gage_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks()) +
      theme_bw(base_size = 14) +
      {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
      theme(axis.title.x = element_blank(),
            axis.title.y = element_blank(),
            legend.position = "none") +
      facet_wrap(. ~ GageName, ncol = 1) + # add the name as facet label
      theme(strip.background = element_rect(fill="lightblue"))
    } else {
      gage_box <- NA # blank data frame
    }
  
  # If adding precipitation plot...
  if(sel_add_gage_precip == "precipitation" & !is.null(precip_dat)) {
    
    trans_precip_y <- ifelse(all(!is.null(trans_log_y), "precipitation" %in% trans_log_y), "log", "identity")
    
    precip_box <- ggplot(precip_dat, aes(x = x, y = PRCP_cm)) + 
      geom_boxplot() +
      {if(x_nam == "DayOfYr") {scale_x_discrete(breaks = seq(from = 0, to = 366, by = 20))} else {scale_x_discrete(drop = FALSE)}} +
      scale_y_continuous(trans = trans_precip_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks()) +
      theme_bw(base_size = 14) +
      {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
      theme(axis.title.x = element_blank(),
            axis.title.y = element_blank(),
            legend.position = "none") +
      facet_wrap(. ~ MeteoName, ncol = 1) + # add the name as facet label
      theme(strip.background = element_rect(fill="lightblue"))
    } else {
      precip_box <- NA # blank data frame
    }
  
  return_list <- list(p1_box_list, char_vec, gage_box, precip_box)
  return(return_list)
}
  
FuncPlotlyPieMatrix <- function(dat, discrete_cols, discrete_levels, plot_title) {
  # Function to create plotly pie chart matrix of Threshold or Percentile categories, grouped by monitoring site (row) and year (col)
  #
  # Args:
  #   dat:  Plot data with percentile/threshold classifications
  #   discrete_cols: For discrete fill, the vector of colors
  #   discrete_levels: For discrete fill, the levels corresponding with colors
  #   plot_title: Title for plot page
  #
  # Returns:
  #   Page of plotly pie charts
  #
  fig <- plot_ly(textfont = list(size = 25))
  colors_list <- split(discrete_cols, discrete_levels)
  m <- list(
    l = 300,
    r = 90,
    b = 100,
    t = 100,
    pad = 0
  )
  
  dat$Color <- dplyr::recode(dat$CategVar, !!!colors_list)
  yr_vec <- seq(from = min(dat$Yr, na.rm = TRUE), to = max(dat$Yr, na.rm = TRUE), by = 1)
  
  
  for(row_num in 1:length(unique(dat$RowLev))) {
    row_filter <- sort(unique(dat$RowLev))[row_num]
    for(yr_num in 1:length(yr_vec)) {
      this_yr <- yr_vec[yr_num]
      pie_dat = subset(dat, RowLev == row_filter & Yr == this_yr)
      if(nrow(pie_dat)>0) {  
      fig <- fig %>% 
        add_pie(data = pie_dat,
                name = paste0(row_filter, "_", this_yr),
                labels = ~CategVar, 
                values = ~n,
                textposition = 'inside',
                textinfo = 'label+percent',
                insidetextfont = list(color = switch(("yellow" %in% discrete_cols)+1, "white", "black")),
                hoverinfo = 'text',
                text = ~HoverLabel,
                marker = list(colors = ~Color, line = list(color = '#FFFFFF', width = 1)),
                domain = list(row = row_num-1, column = yr_num-1))
    }
  }
  }
  
  width_px <- 390 + (85 * length(yr_vec)) # this is the plot width (paper). The plot value used to be 110 (not 85)
  height_px <- 200 + (85 * length(unique(dat$RowLev))) # this is the plot height (paper)

  yr_seq_px <- seq(55, width_px-390, by = 85)/(85 * length(yr_vec)) # this is where year labels should align on x-axis, when reference is "paper"
  y_seq_px <- seq(55, height_px-55, length.out = length(unique(dat$RowLev)))/height_px
  title_loc <- 1.05 + (90/height_px) #it's into the top margin space, when reference is "container"- CHANGED THIS FROM 1 +
  legend_loc <- 1 + (50/height_px)
  yrs_loc_bottom <- -1 * (50/height_px)
  
  yr_labels_bottom <- list(
  text = as.list(as.character(yr_vec)),
  xref = "paper",
  yref = "container",
  yanchor = "center",
  xanchor = "center",
  font =list(size = 14),
  align = "right",
  x = yr_seq_px,
  y = yrs_loc_bottom,
  showarrow = FALSE)
  
  y_labels_left <- list(
    text = as.list(sort(unique(dat$RowLev), decreasing = TRUE)),
    xref = "paper",
    yref = "paper",
    xanchor = "right",
    yanchor = "center",
    font =list(size = 14),
    align = "center",
    x = -0.02,
    y = y_seq_px,
    showarrow = FALSE)
  
  fig_final <- fig %>% layout(
    margin = m,
    title = list(
      text = plot_title,
      x = 0.5,
      y = title_loc,
      xref = "container", # gets cut off if referenced to the plot only ("paper")
      yref = "paper",
      xanchor = "center",
      yanchor = "center"),
    showlegend = TRUE,
    legend = list(
      orientation = "h",
      x = 0.5,
      xref = "container",
      yref = "paper",
      xanchor = "center",
      y = legend_loc,
      yanchor = "center"),
    grid=list(
      rows=length(unique(dat$RowLev)),
      columns=length(yr_vec)),
    width = width_px,
    height = height_px,
    autosize = FALSE,
    annotations = y_labels_left) 
  
  fig_final <- fig_final %>% layout(annotations = yr_labels_bottom)

  fig_final
  return(fig_final)
}

FuncPlotPage <- function(plot_type, plot_dat, quant_dat, time_unit, free_y, categLevelsPlot = rv_param_temp$categLevelsPlot, sel_add_gage_precip = switch(is.null(rv_param_temp$sel_add_gage_precip)+1, rv_param_temp$sel_add_gage_precip, "none"), sel_combine_sites, sel_plot_ht = switch(is.null(input$sel_PlotHt)+1, 280+20*input$sel_PlotHt, 280), trans_log_y) {
  sel_categ = switch(is.null(input$sel_Categ)+1, input$sel_Categ, "none")
 
  plot_dat <- isolate(plot_dat)
# Includes censored data
    incl_cens <- any(c("Present Below Quantification Limit", "Not Detected", "Present Above Quantification Limit") %in% unique(plot_dat$ResultDetectionConditionText)) # TRUE if there are any reporting limits
  
    if(time_unit == "ActivityStartDate" & plot_type == "box") {time_unit <- "Yr"} # Box plots for time series are grouped by year
    
    thresh_list <- switch(rv_param_temp$sel_show_thresholds,
                          showthresh_file = rv_param_temp$threshList,
                          showthresh_custom = rv_param_temp$threshCustom,
                          showthresh_none = NULL)
    
      plot_dat$x <- plot_dat[[time_unit]]
      plot_dat$y <- round(plot_dat[["ResultMeasureValue_replaced"]], 2)
      shiny::req(sum(!is.na(plot_dat$y)) > 0) # make sure there are data!
      
      # If adding streamflow data...
        if(any(sel_add_gage_precip!="streamflow", is.null(rv_param_temp$sel_gage_station), is.null(rv$gagesDat), is.null(rv$selectedGages))) {
          gageDat <- NULL
          gage_YScale <- NULL
        } else {
          gageDat <- FuncGageDat(gage_station = rv_param_temp$sel_gage_station)
          if(!is.null(gageDat)) {
            gage_YScale <- rv_param_temp$sel_gage_yscale
            } else {
              gage_YScale <- NULL
            }
        }
      # If adding precipitation data...
        if(any(sel_add_gage_precip!="precipitation", is.null(rv_param_temp$sel_precip_station), is.null(rv$meteoDat), is.null(rv$selectedMeteo))) {
          precipDat <- NULL
          precip_YScale <- NULL
        } else {
          precipDat <- FuncPrecipDat(precip_station = rv_param_temp$sel_precip_station)
          precip_YScale <- rv_param_temp$sel_precip_yscale
        }
      
      cat("line1898")
      # For seasonal patterns...
      if(time_unit != "ActivityStartDate") {
        xseq = switch(time_unit,
                      Yr = seq(min(as.numeric(as.character(plot_dat$x)), na.rm = TRUE), max(as.numeric(as.character(plot_dat$x)), na.rm = TRUE), by = 1), # this is only for time series boxplots
                      Season = levels(plot_dat$Season), # c("Spring", "Summer", "Fall", "Winter"),
                      Mnth = levels(plot_dat$Mnth),
                      Wk = 1:53,
                      DayOfYr = 1:366 # account for leap year
                      )
        
        plot_dat$x <- factor(plot_dat$x, levels = xseq, labels = xseq)
        
        if(!is.null(gageDat)) {
          gageDat$x <- factor(gageDat[[time_unit]], levels = xseq, labels = xseq)
        }
        
        if(!is.null(precipDat)) {
          precipDat$x <- factor(precipDat[[time_unit]], levels = xseq, labels = xseq)
        }
      }
      if(!is.null(input$sel_PlotType)) {
        month_summary <- all(sel_add_gage_precip != "none", input$sel_PlotType %in% c("points", "points_smooth"))
      } else {
        month_summary <- FALSE
      }
  cat("line1921")
    if(plot_type %in% c("points", "points_smooth")) {

      ts_plot <- FuncPlotScatter(plot_dat = plot_dat, quant_df = quant_dat, categ_df = categLevelsPlot, x_nam = time_unit, combine_sites = ifelse(length(unique(plot_dat$CharacteristicName)) == 1, ifelse(sel_combine_sites, TRUE, FALSE), FALSE), fixed_free_y = ifelse(free_y, "free_y", "fixed"), add_loess = ifelse(plot_type == "points_smooth", TRUE, FALSE), incl_cens = incl_cens, thresh_list = thresh_list, rotate_x = TRUE, gage_dat = gageDat, precip_dat = precipDat, month_summary = month_summary, sel_categ = sel_categ, trans_log_y = trans_log_y)}

    if(plot_type == "box") {
      ts_plot <- FuncPlotBox(plot_dat = plot_dat, quant_df = quant_dat, x_nam = time_unit, combine_sites = ifelse(length(unique(plot_dat$CharacteristicName)) == 1, ifelse(sel_combine_sites, TRUE, FALSE), FALSE), fixed_free_y = ifelse(free_y, "free_y", "fixed"), incl_cens = incl_cens, thresh_list = thresh_list, rotate_x = TRUE, gage_dat = gageDat, precip_dat = precipDat, trans_log_y = trans_log_y)}

    # PUT THE PLOTS TOGETHER
cat("line1930")
    shiny::req(!is.null(ts_plot[[1]]))

    # Get the shared legend if it exists - getting shared legends to format properly with plotly is a PITB. Tried following many stackexchange suggestions, with no success.
      if(!is.null(get_legend(ts_plot[[1]][[1]]))) {
      shared_legend <- ggpubr::as_ggplot(get_legend(ts_plot[[1]][[1]])) # if a legend exists, extract it
    } else {
      shared_legend <- NULL
    }

    total_plot_height <- 64 + sel_plot_ht * (length(ts_plot[[1]]) + as.integer(sel_add_gage_precip!="none")) # Final plot will take the layout of the first plot, so the first plot needs to have the height of final plot. Initially tried to account for x_axis height, but seems it was probably already adjusted for

    # First, the parameter plots
    param_plotly <- FuncPlotlyFormat(
      plotly_list = ts_plot[[1]],
      plotly_title = paste0("Data for ",  switch((length(unique(plot_dat$MonitoringLocationIdentifier)) > 1)+1, unique(plot_dat$MonitoringLocationIdentifier), "multiple sites"), ":  ", switch((length(unique(plot_dat$CharacteristicName)) > 1) + 1, unique(plot_dat$CharacteristicName), "multiple water characteristics"), " (", min(plot_dat$Yr, na.rm = TRUE), " to ", max(plot_dat$Yr, na.rm = TRUE), ")<br><br>"),
      xlab = switch(time_unit, ActivityStartDate = "Survey Date (time series)", DayOfYr = "Day", Wk = "Week", Mnth = "Month", Season = "Season"),
      ylab_vec = ts_plot[[2]],
      total_height = total_plot_height,
      is_grouped_boxplots = (plot_type == "box" & length(unique(plot_dat$CharacteristicName)) == 1 & length(unique(plot_dat$MonitoringLocationIdentifier)) > 1 & sel_combine_sites == TRUE) # boxplots for multiple stations, all combined in a single plot
    ) 
      
    # If there is a streamflow plot, add that in
    if(sel_add_gage_precip == "streamflow" & !is.null(gageDat) & "ggplot" %in% class(ts_plot[[3]])) {

  extra_plotly <- FuncPlotlyFormat(
    plotly_list = list(Streamflow = ts_plot[[3]]),
    plotly_title = "Mean Daily Discharge",
    xlab = switch(time_unit, ActivityStartDate = "Survey Date (time series)", DayOfYr = "Day of Year", Wk = "Week of Year", Mnth = "Month of Year", Season = "Season of Year"),
    ylab_vec = c("Mean Daily Discharge (cfs)"),
    total_height = total_plot_height,
    is_grouped_boxplots = FALSE
  )
}

  # If there is a precipitation plot, add that in
if(sel_add_gage_precip == "precipitation" & !is.null(precipDat) & "ggplot" %in% class(ts_plot[[4]])) {
 
  extra_plotly <- FuncPlotlyFormat(
    plotly_list = list(Precipitation = ts_plot[[4]]),
    plotly_title = "Precipitation",
    xlab = switch(time_unit, ActivityStartDate = "Survey Date (time series)", DayOfYr = "Day of Year", Wk = "Week of Year", Mnth = "Month of Year", Season = "Season of Year"),
    ylab_vec = c("Precip (cm)"),
    total_height = total_plot_height,
    is_grouped_boxplots = FALSE
  )
}
    cat("line1978")
    shiny::req(!is.null(param_plotly))
      
      if(exists("extra_plotly")) {
        subplot_list <- c(param_plotly, extra_plotly)
        n_plots <- length(ts_plot[[1]])+1
        } else {
          subplot_list <- param_plotly
      n_plots <- length(ts_plot[[1]])
        }

      shiny::req(!is.null(subplot_list))
      plotly_page <-
      subplot(subplot_list,
              nrows = n_plots, # add 1 for precip plot
              shareX = TRUE, # if set to FALSE, the X-axis labels will appear but will be cut off unless margin is increased. If margin is increased, plot sizes will be uneven
              shareY = FALSE,
              titleX = TRUE,
              titleY = TRUE,
              margin = c(0, 0.0, 0.02/length(subplot_list), 0.14/length(subplot_list)),
              which_layout = 1)
      return_list <- list(plotly_page = plotly_page, shared_legend = shared_legend)
    # return(plotly_page)
      return(return_list)
}

FuncPieDat <- function(limit_type) {
  shiny::req(sum(!is.na(rv_param_temp$plotDat[limit_type])) > 0)
    
    if(rv_param_temp$sel_summarize_by=="by_char") {
      temp_pie_dat <- rv_param_temp$plotDat %>%
        dplyr::filter(!is.na(get(limit_type))) %>%
        group_by(MonitoringLocationIdentifier, Yr) %>%
        summarise(N = n()) %>%
        left_join(rv_param_temp$plotDat %>%
                    dplyr::rename("CategVar" = limit_type) %>%
                    group_by(MonitoringLocationIdentifier, Yr) %>%
                    dplyr::count(CategVar), by = c("MonitoringLocationIdentifier", "Yr")) %>%
        dplyr::rename(RowLev = MonitoringLocationIdentifier) 
    } else {
      temp_pie_dat <- rv_param_temp$plotDat %>%
        dplyr::filter(!is.na(get(limit_type))) %>%
        group_by(CharacteristicName, Yr) %>%
        summarise(N = n()) %>%
        left_join(rv_param_temp$plotDat %>%
                    dplyr::rename("CategVar" = limit_type) %>%
                    group_by(CharacteristicName, Yr) %>%
                    dplyr::count(CategVar), by = c("CharacteristicName", "Yr")) %>%
        dplyr::rename(RowLev = CharacteristicName) 
    }
    temp_pie_dat %<>%
      dplyr::mutate(HoverLabel = paste0(RowLev, "<br>", rv_param_temp$seasonType, ": ", Yr, "<br>LEVEL: ", CategVar, "<br>COUNT: ", n, " out of N = ", N))
    return(temp_pie_dat)
}

FuncSummaryStats <- function(dat, plot_summarize_by) {
  
  if(plot_summarize_by == "by_station") {
    temp_dat <- dat %>%
      dplyr::rename("GroupingVar" = "CharacteristicName")
  } else {
    temp_dat <- dat %>%
      dplyr::rename("GroupingVar" = "MonitoringLocationIdentifier")
  }

  temp_plot_summary <- temp_dat %>% 
    dplyr::group_by(GroupingVar) %>% 
    dplyr::summarise(
      NumRecords = n(),
      NumSampleDays = length(unique(ActivityStartDate)),
      Mean = round(mean(ResultMeasureValue, na.rm = TRUE), 2),
      Median = round(median(ResultMeasureValue, na.rm = TRUE), 2),
      Min = round(min(ResultMeasureValue, na.rm = TRUE), 2),
      Max = round(max(ResultMeasureValue, na.rm = TRUE), 2)
      )
  param_tab_list <- list()

for (i in c("ResultDetectionConditionText", "ThreshCateg", "PercCateg")) {
  if(sum(!is.na(temp_dat[i])) > 0) {
    temp_add_cols <- temp_dat %>% 
      dplyr::rename("CategVar" = i) %>%
      dplyr::group_by(GroupingVar) %>%
          dplyr::count(CategVar) %>%
        dplyr::left_join(temp_plot_summary[, c("GroupingVar", "NumRecords")], by = "GroupingVar")

    temp_add_cols %<>%
      mutate(Perc = round((n/NumRecords)*100, 1)) %>%
      select(-n, -NumRecords) %>%
      spread(key = CategVar, value = Perc, sep = ": %", drop = FALSE, fill = 0)
    names(temp_add_cols) <- gsub("CategVar", i, names(temp_add_cols), fixed = TRUE)
    param_tab_list[[i]] <- temp_add_cols
  }
}
  
    final_plot_summary <- c(list(temp_plot_summary), param_tab_list) %>% purrr::reduce(left_join, by =  c("GroupingVar")) # left-join multiple tables
    names(final_plot_summary) <- gsub(pattern = "ResultDetectionConditionText: ", replacement = "", names(final_plot_summary))
    names(final_plot_summary) <- gsub(pattern = "PercCateg", replacement = "Percentiles", names(final_plot_summary))
    names(final_plot_summary) <- gsub(pattern = "ThreshCateg", replacement = "Thresholds", names(final_plot_summary))

    if(plot_summarize_by == "by_station") {
    final_plot_summary %<>%
      dplyr::rename("Characteristic"="GroupingVar")
  } else {
    final_plot_summary %<>%
      dplyr::rename("Site"="GroupingVar")
  }
    
final_plot_summary
}


FuncClearAll <- function() {
  rv <- reactiveValues(wqp_url = NULL, parkName = NULL, parkID = NULL, unitPoly = NULL, HUC10 = NULL, HUC12 = NULL, sitesPointsSub = NULL, meteoStations = NULL, selectedMeteo = NULL, meteoDat = NULL, facilitiesPointsSub = NULL, selectedHucs = NULL, selectedStations = NULL, selectedOriginStation = NULL, selectedUpstreamStations = NULL, selectedDownstreamStations = NULL, selectedUpstreamLines = NULL, selectedDownstreamLines = NULL, orgs = NULL, gageStations = NULL, selectedGages = NULL, gagesDat = NULL, dat = NULL, userSelect = list())
  
  rv_param_temp <- reactiveValues(loadMap = FALSE, resetFilter = FALSE, newImport = NULL, palOrg = NULL, selectParam = NULL, N_plotly_page = NULL, subDat = NULL, subDatTypes = NULL, subDatYears = NULL, filterNPlot = NULL, showStations = NULL, showCharSets = NULL, sel_summarize_by = NULL, sel_add_gage_precip = NULL, sel_gage_station = NULL, sel_gage_yscale = NULL, sel_precip_station = NULL, sel_precip_yscale = NULL, plotDat = NULL, quantDat = NULL, finalPlot = list(plotly_page = NULL, shared_legend = NULL), seasonalPlot = list(plotly_page = NULL, shared_legend = NULL), plotSummary = NULL, precipDat = NULL, categLevels = NULL, categLevelsPlot = NULL, categLevelsImport = NULL, threshList = NULL, threshCustom = NULL, sel_show_thresholds = NULL, percCateg= NULL, showDM = FALSE, seasonType = NULL, param_map_highlight = NULL, update_from_sidebar = NULL)
  
  # Hide filter wellPanels
  restart_panels_filter <- c("new_data_P1", "new_data_P2", "new_data_P3", "new_data_P4", "create_categfile_P1", "create_categfile_P2", "create_categfile_P3") 
  lapply(restart_panels_filter, FUN = function(x) shinyjs::hideElement(x))
  
  # Update inputs
  FuncUpdateHome()
  FuncUpdateInputsOther()
}

  FuncSelHUC <- function(huc, huc_sf, park_code, overlaps_list) {
    # Function to generate HUC sf with only the HUCs that overlap the selected park unit
    huc_on_park <- overlaps_list[[huc]] %>%
    dplyr::filter(unit_code == park_code) %>%
    dplyr::pull(tolower(huc))
    
    huc_sf_subset <- huc_sf %>% 
      dplyr::rename(HUC = tolower(huc)) %>%
      dplyr::filter(HUC %in% huc_on_park)
    
    # huc_sf_subset <- rmapshaper::ms_simplify(huc_sf_subset, keep = 0.3) # <<<<<<<<<<< TEST THIS
    return(huc_sf_subset)
  }
  
# These are reactable functions
bar_chart <- function(label, width = "100%", height = "14px", fill = "#00bfc4", background = NULL) {
  bar <- div(style = list(background = fill, width = width, height = height))
  chart <- div(style = list(flexGrow = 1, marginLeft = "6px", background = background), bar)
  div(style = list(display = "flex", alignItems = "center"), label, chart)
  }

with_tooltip <- function(value, tooltip) {
  tags$abbr(style = "text-decoration: underline; text-decoration-style: dotted; cursor: help", title = tooltip, value)
}

download_button <- function(outputId, label = "Download", class = NULL, ...)  {
     tags$a(id = outputId, class = paste("btn btn-default shiny-download-link", 
        class), href = "", target = "_blank", download = NA, 
        icon("download"), label, ...)
}

```

```{r startup}

rv <- reactiveValues(wqp_url = NULL, parkName = NULL, parkID = NULL, unitPoly = NULL, HUC10 = NULL, HUC12 = NULL, sitesPointsSub = NULL, meteoStations = NULL, selectedMeteo = NULL, meteoDat = NULL, facilitiesPointsSub = NULL, selectedHucs = NULL, selectedStations = NULL, selectedOriginStation = NULL, selectedUpstreamStations = NULL, selectedDownstreamStations = NULL, selectedUpstreamLines = NULL, selectedDownstreamLines = NULL, orgs = NULL, gageStations = NULL, selectedGages = NULL, gagesDat = NULL, dat = NULL, userSelect = list())
  
rv_param_temp <- reactiveValues(loadMap = FALSE, resetFilter = FALSE, newImport = NULL, palOrg = NULL, selectParam = NULL, N_plotly_page = NULL, subDat = NULL, subDatTypes = NULL, subDatYears = NULL, filterNPlot = NULL, showStations = NULL, showCharSets = NULL, sel_summarize_by = NULL, sel_add_gage_precip = NULL, sel_gage_station = NULL, sel_gage_yscale = NULL, sel_precip_station = NULL, sel_precip_yscale = NULL, plotDat = NULL, quantDat = NULL, finalPlot = list(plotly_page = NULL, shared_legend = NULL), seasonalPlot = list(plotly_page = NULL, shared_legend = NULL), plotSummary = NULL, precipDat = NULL, categLevels = NULL, categLevelsPlot = NULL, categLevelsImport = NULL, threshList = NULL, threshCustom = NULL, sel_show_thresholds = NULL, percCateg= NULL, showDM = FALSE, seasonType = NULL, param_map_highlight = NULL, update_from_sidebar = NULL)
```

```{r action_button_beginSearch}
# Action to begin data search from Main Page----
observeEvent(eventExpr = input$button_beginSearch, {
  
  FuncClearAll()
  
# If user choooses to import new data from WQP...

if(input$sel_GetData == "new_data") { 
  shinyjs::showElement("new_data_P1")
  } else { # if user chooses to load existing data...
    showModal(modalDialog(
    fileInput("saved_data_file", label = "Import a saved dashboard data file ('RDS' extension)", placeholder = "Click 'Browse...' button then navigate to file", accept = c('.rds'), width = "100%"),
    footer = tagList(
      modalButton("Cancel")
    )
  ))
  }
})
```

```{r action_saved_data_file}
# Action to load saved .RDS file from Main Page ----
observeEvent(eventExpr = input$saved_data_file, {
  shiny::req(!is.null(input$saved_data_file$datapath))
  if(!toupper(tools::file_ext(input$saved_data_file$datapath)) %in% c("RDS")) {
    showModal(modalDialog(
    title = "Error",
    "File must have .RDS extension. Please select a different file."
    ))
  } else {

    tryCatch(out_file <- readRDS(input$saved_data_file$datapath),
             error = function(e) {out_file <- NULL; print("Cannot import the selected file")})
    
  shiny::req(!is.null(out_file))
  if(class(out_file)!="list") {
    showModal(modalDialog(
    title = "Error",
    "Cannot import the selected file. Please try a different .RDS file."
    ))
    }
  
  shiny::req(!is.null(out_file))
  for(i in names(out_file)) {
      rv[[i]] <- out_file[[i]] # load the data in the dashboard
    }
  
  rv_param_temp$loadMap <- TRUE
  rv_param_temp$resetFilter <- TRUE
  rm(out_file)
  
  showModal(modalDialog(
  title = "Done",
  "You may now navigate to the 'Define & Filter Data' page"
  ))
  }
})
```

```{r action_button_showStations}
# Action to show WQP stations from Main Page ----
observeEvent(eventExpr = input$button_showStations, {
  if(input$sel_UnitCode=="") { # can't print validation message within observeEvent, so use modalDialogs
    showModal(modalDialog(
      title = "No Data",
      "Please choose a Park unit"
    ))
    }
 
  shiny::req(input$sel_UnitCode!="") # make sure user has entered Park unit code

  FuncClearAll()
  
  rv$parkName <- input$sel_UnitCode
  rv$parkID <- unique_parks_df$unit_code[unique_parks_df$unit_name_combined == rv$parkName]
  
  cat("line2417")
  withProgress(message = "Getting data", detail = "...Park unit and intersecting watershed boundaries", value = 0, {

  showModal(tags$div(id = "gif_modal", modalDialog(
      HTML('<img src="https://media.giphy.com/media/BAKUHQxl7y7Zu/giphy.gif"><br><center>I am just your entertainment.<br><center>The progress bar is below.'), # custom loading gif--pdog blowing bubble gum
      easyClose = TRUE,
      footer = NULL
      )))
    
  shinyjs::hideElement("new_data_P2")
  shinyjs::hideElement("new_data_P3")
  shinyjs::hideElement("new_data_P4")
    
  # Get park unit boundary data from dashboard files ----
  parks_sf <- readRDS(here::here("dashboard_files", "parks_sf.RDS"))
    rv$unitPoly <- parks_sf %>% dplyr::filter(UNIT_CODE == rv$parkID)
  cat("line2432")
   # Get HUC10 & HUC12 boundary data from web services ----
    # Files are too large to save with dashboard for quick pull
    for(hucLevel in 5:6) {
      hucName <- switch((hucLevel==6)+1, "HUC10", "HUC12")
     
      # incProgress(1/7, detail = paste0("...", hucName, " boundaries from National Watershed Boundary Dataset"))

      hucURL <- paste0("https://hydro.nationalmap.gov/arcgis/rest/services/wbd/MapServer/", hucLevel, "/query?where=&text=&objectIds=&time=&geometry=", paste(as.character(sf::st_bbox(rv$unitPoly)), collapse ="%2C"), "&geometryType=esriGeometryEnvelope&inSR=4326&outSR=4326&spatialRel=esriSpatialRelIntersects&relationParam=&outFields=*&returnGeometry=true&returnTrueCurves=false&maxAllowableOffset=&geometryPrecision=&having=&returnIdsOnly=false&returnCountOnly=false&orderByFields=&groupByFieldsForStatistics=&outStatistics=&returnZ=false&returnM=false&gdbVersion=&historicMoment=&returnDistinctValues=false&resultOffset=&resultRecordCount=&queryByDistance=&returnExtentOnly=false&datumTransformation=&parameterValues=&rangeValues=&quantizationParameters=&featureEncoding=esriDefault&f=geojson")
      
      cat(hucURL)
      # saveRDS(hucURL, "hucURL.RDS")

    if(http_status(polite_GET(hucURL))$category!="Success") { # make sure the service call is valid
      showModal(
         urlModal(hucURL, title = "Data Retrieval Error", subtitle = paste0("Error retrieving ", hucName, " boundary data from the National Watershed Boundary Dataset. The message from the web service is: `", http_status(polite_GET(hucURL))$message, "`.\n\nTo confirm this is a problem with the web service (and not the dashboard), enter the above URL in a browser and see if data successfully downloads."))
       )
      }
   
    shiny::req(http_status(polite_GET(hucURL))$category=="Success") # if not a valid service call, abort
    
    hucPoly <- tryCatch(sf::st_read(hucURL), error=function(e) cat("Error retrieving ", hucName, " data"))

    if(!"sf" %in% class(hucPoly)) {
      showModal(
         urlModal(hucURL, title = "Data Retrieval Error", subtitle = paste0("Could not successfully retrieve HUC boundary data from the National Watershed Boundary Dataset. To see if this is a problem with the web service (and not the dashboard), enter the above URL in a browser and see if data successfully downloads with boundary information in geojson format."))
       )
      }
    shiny::req("sf" %in% class(hucPoly))
    hucPoly <- sf::st_transform(hucPoly, crs = st_crs(rv$unitPoly))
    
    if(exists("hucPolySub")) {rm(hucPolySub)}
    
    # tryCatch(hucPolySub <- sf::st_intersection(rv$unitPoly, hucPoly), error = function(e) NULL)
    
    
    tryCatch(hucPolySub <- hucPoly[unlist(sf::st_intersects(rv$unitPoly, hucPoly)),], error = function(e) NULL) # can't use intersection here b/c it clips
    
    if(exists("hucPolySub")) {
      hucPolySub %<>%
      dplyr::rename(HUC = tolower(hucName))
      
      rv[[hucName]] <- hucPolySub
      rm(hucPolySub)
      }
      
    rm(hucURL,hucPoly)
    }
    

    # Get Monitoring station sites for overlapping HUC10 bbox, from web services ----
    # Real-time pull so user can set filters

    incProgress(1/7, detail = "...Monitoring sites from Water Quality Portal")
    cat("line2481")
    shiny::req(!is.null(rv[["HUC10"]]), !is.null(input$sel_ActiveWithinYrs))
    cat("line2483")
    huc10_bbox <- sf::st_bbox(rv[["HUC10"]]) # HUC10 bbox
    
  # Recently active WQP stations that fall within the HUC10 bbox (sampled within past [user-specified number of] years) 
  sitesURL <- paste0("https://www.waterqualitydata.us/data/Station/search?siteType=Aggregate%20surface-water-use&siteType=Estuary&siteType=Lake%2C%20Reservoir%2C%20Impoundment&siteType=Spring&siteType=Stream&siteType=Well&siteType=Wetland&siteType=Aggregate%20groundwater%20use&siteType=Aggregate%20groundwater%20use%20&siteType=Aggregate%20water-use%20establishment&siteType=Subsurface&bBox=", paste(huc10_bbox, collapse ="%2C"), "&characteristicType=Toxicity&characteristicType=Physical&characteristicType=Organics%2C%20PFAS&characteristicType=Organics%2C%20Pesticide&characteristicType=Organics%2C%20PCBs&characteristicType=Nutrient&characteristicType=Microbiological&characteristicType=Cyanotoxins%2C%20Phytotoxins&characteristicType=Inorganics%2C%20Major%2C%20Metals&characteristicType=Inorganics%2C%20Major%2C%20Non-metals&minactivities=1&startDateLo=01-01-", lubridate::year(Sys.Date())-as.integer(input$sel_ActiveWithinYrs), "&sampleMedia=Water&sampleMedia=water&mimeType=csv&zip=no&providers=NWIS&providers=STEWARDS&providers=STORET")
   
cat("line2489")
    if(http_status(polite_GET(sitesURL))$category!="Success") { # make sure the service call is valid
      showModal(
        urlModal(sitesURL, title = "Data Retrieval Error", subtitle = paste0("Error retrieving monitoring sites information from the Water Quality Portal. The message from the web service is: `", http_status(polite_GET(sitesURL))$message, "`.\n\nTo confirm this is a problem with the web service (and not the dashboard), enter the above URL in a browser and see if data successfully downloads."))
      )
    }
    
    shiny::req(http_status(polite_GET(sitesURL))$category=="Success") # if not a valid service call, abort
    # polite::bow(sitesURL) %>% rip(destfile = "tempSites.csv", mode = "w")

    download.file(sitesURL, "tempSites.csv", mode = "w")
    sites <- read_csv("tempSites.csv", trim_ws = TRUE)
    sites$HUCEightDigitCode <- gsub(pattern="-", replacement = "", x= as.character(sites$HUCEightDigitCode)) # Weird issue with BLRI
    
    if(is.null(sites)|nrow(sites)==0) { # if no monitoring stations, abort
      showModal(modalDialog(
        title = "No Monitoring Sites",
        "No monitoring sites found in Water Quality Portal for specified query. Please try again."
      ))
      }
    shiny::req(!is.null(sites) & nrow(sites)>0)
    
  # Create sf of WQP stations point location
  temp_points <- sf::st_as_sf(x = sites, 
                        coords = c("LongitudeMeasure", "LatitudeMeasure"),
                        crs = 4269)# NAD83. Difference between NAD83 and WGS84 is only ~1m, so just use NAD83 b/c it's the most common.
    
    temp_points <- sf::st_transform(temp_points, crs = st_crs(rv$unitPoly)) # convert to WGS84
    # subset to the HUC10 boundaries. Did not import using the HUC10's b/c that approaches seems to miss some sites that don't have associated HUC10 information (?)
    
    sitesPoints <- st_filter(temp_points, rv[["HUC10"]]) # These are the ones that fall within HUC10's, so keep them
    
    sitesPoints %<>%
      dplyr::mutate(
        SITELAB = paste0("Monitoring Site: ", MonitoringLocationName, " [", MonitoringLocationIdentifier, "]"),

        SITEPOP = paste0("Org: ", OrganizationFormalName, '<br>Site ID: <a href="https://www.waterqualitydata.us/provider/', ProviderName, '/', OrganizationIdentifier, '/', MonitoringLocationIdentifier, '/" target="_blank">', MonitoringLocationIdentifier, '</a>', "<br>Water Monitoring Station: ", MonitoringLocationName, "<br>Type: ", MonitoringLocationTypeName))
    
    rv$sitesPointsSub <- sitesPoints
    rm(sites, temp_points, sitesPoints)
    unlink("tempSites.csv")
  
  # Get recently active USGS stream gauging station information, within HUC10's, from dashboard files ----
  incProgress(1/7, detail = "...USGS stream gages station information from NWIS")
  cat("Getting gages")
  
  park_gage_overlaps_list <- readRDS(here::here("dashboard_files", "park_gage_overlaps_list.RDS"))                                             
  gages <- park_gage_overlaps_list[[rv$parkID]] # Get stream gage stations for that park unit
  rm(park_gage_overlaps_list)
  if(all(!is.null(nrow(gages)), nrow(gages) >0)) {
    
    # Create sf of gage stations point location
  temp_gagepoints <- sf::st_as_sf(x = gages, 
                        coords = c("Longitude", "Latitude"),
                        crs = 4269)# NAD83.
  
  temp_gagepoints <- sf::st_transform(temp_gagepoints, crs = st_crs(rv$unitPoly)) # convert to WGS84
    # subset to the HUC10 boundaries. 
  
  gagePoints <- st_filter(temp_gagepoints, rv[["HUC10"]]) # These are the ones that fall within HUC10's, so keep them
  
  rv$gageStations <- gagePoints
  } else {
    rv$gageStations <- NULL
    
    showModal(modalDialog(
      title = "No Stream Gage Stations Meet Download Criteria",
      "Could not find active USGS stream gage stations with at least 10 years of data, located within the park's HUC10 watershed boundaries (active = most recent data are less than one year old). These data are not necessary for visualizing water quality data on the dashboard.",
      easyClose = FALSE,
      footer = tagList(
        div(style="display:inline-block; width:100px;", actionButton("dismiss_gages_modal", "Got it!"))
        )
      )
      ) # Require user to click 'Got it!' button for the modal to close
  }
  rm(gages, temp_gagepoints, gagePoints)

  # Get locations of recently active weather stations, for the bounding box, from dashboard files ----
  # This requires a token, so don't want to embed in dashboard
  incProgress(1/7, detail = "...Weather station locations from NOAA")

    park_noaa_overlaps_list <- readRDS(here::here("dashboard_files", "park_noaa_overlaps_list.RDS"))
    noaa <- park_noaa_overlaps_list[[rv$parkID]] # Get stream gage stations for that park unit
    
    if(all(!is.null(nrow(noaa)), nrow(noaa) >0)) {

  # Create sf of gage stations point location
  temp_noaapoints <- sf::st_as_sf(x = noaa, 
                        coords = c("longitude", "latitude"),
                        crs = 4269)# NAD83.
  
  temp_noaapoints <- sf::st_transform(temp_noaapoints, crs = st_crs(rv$unitPoly)) # convert to WGS84
    # subset to the HUC10 boundaries. 

  rv$meteoStations <- temp_noaapoints
    } else {
    rv$meteoStations <- NULL
    
    showModal(modalDialog(
      title = "No Weather Stations Meet Download Criteria",
      "Could not find active weather stations with at least 10 years of data, located within the park's HUC10 watershed boundaries box (active = most recent data are less than one year old). These data are not necessary for visualizing water quality data on the dashboard.",
      easyClose = FALSE,
      footer = tagList(
        div(style="display:inline-block; width:100px;", actionButton("dismiss_weather_modal", "Got it!"))
        )
      )
      ) # Require user to click 'Got it!' button for the modal to close
  }
cat("line2336")

  # Get Discharge facilities locations from ECHO, for the bounding box - restrict to "major" facilities ----
  incProgress(1/7, detail = "...Discharge facilities locations from EPA ECHO Map Services")
  cat("Getting EPA")
  facilitiesPoints <- NULL # make sure previous search information erased
  
 facilitiesURL <- paste0("https://ofmpub.epa.gov/echo/cwa_rest_services.get_facility_info?output=GEOJSON&p_maj=Y&p_wbd=", paste(rv$HUC10$HUC, collapse = ",")) # major facilities only, falls within the HUC10 boundaries
cat("line2614")
  if(http_status(polite_GET(facilitiesURL))$category!="Success") { # make sure the service call is valid
    showModal(modalDialog(
      title = "No Discharge Facilities Data",
      "Error retrieving discharge facilities locations data from EPA ECHO. These data are not necessary for visualizing water quality data on the dashboard.",
      easyClose = FALSE,
      footer = tagList(
        div(style="display:inline-block; width:100px;", actionButton("dismiss_discharge_modal", "Got it!"))
        )
      )
      ) # Require user to click 'Got it!' button for the modal to close
    } else {
      if(length(str_detect(content(polite_GET(facilitiesURL))$message, "invalid:")) > 0) { # if the http is valid, but some HUCs are not found, remove those HUCs from the search
        lostHUCS <- unlist(str_extract_all(content(polite_GET(facilitiesURL))$message, "[[:digit:]]{10}")) # extract the HUC10's
        subsetHUC <- setdiff(rv$HUC10$HUC, lostHUCS) # remove those HUC's from the list, and try again
        facilitiesURL <- paste0("https://ofmpub.epa.gov/echo/cwa_rest_services.get_facility_info?output=GEOJSON&p_maj=Y&p_wbd=", paste(subsetHUC, collapse = ",")) # major facilities only, falls within the HUC10 boundaries
      }
      tempFacilitiesOutput <- "tempFacilities.geojson"
      cat("line2360")
      download.file(facilitiesURL, tempFacilitiesOutput)
      facilitiesPoints <- tryCatch(readOGR(dsn = tempFacilitiesOutput, dropNULLGeometries = FALSE), error=function(e) print("Error retrieving discharge facilities information"))
cat("line2635")
      if(class(facilitiesPoints)!="SpatialPointsDataFrame") {
        rv$facilitiesPointsSub <- NULL
        showModal(modalDialog(
          title = "No Discharge Facilities Data",
          "Error retrieving discharge facilities locations data from EPA ECHO. These data are not necessary for visualizing water quality data on the dashboard.",
          easyClose = FALSE,
          footer = tagList(
            actionButton("dismiss_discharge_modal", "Got it!")
            )
          )
      ) # Require user to click 'Got it!' button for the modal to close
        
        } else {
          facilitiesPoints %<>%
            dplyr::mutate(
              FACLAB = paste0("Discharge Facility: ", CWPName, " [", SourceID, "]"),
              FACPOP = paste0('Discharge Facility: <a href="https://echo.epa.gov/detailed-facility-report?fid=', SourceID, '" target="_blank">', CWPName, '</a>', "<br>Source ID: ", SourceID, "<br>Type: ", CWPFacilityTypeIndicator, "<br>County: ", CWPCounty, "<br>State: ", CWPState)) # CWPName
          rv$facilitiesPointsSub <- facilitiesPoints[rv$HUC10,]
          rm(facilitiesPoints)
        }
      rm(facilitiesURL, tempFacilitiesOutput)
      unlink("tempFacilities.geojson")
    }
    # If displaying shapes, points, etc., Leaflet will automatically project the WGS84 long-lat coordinates when displaying. Leaflet only supports TILES that have been published in EPSG 3857, so if using other tiles (e.g., NPS), need to change projections
  })
  
  shinyjs::showElement("new_data_P2")
    
  cat("set loadMap to TRUE")
  rv_param_temp$loadMap <- TRUE
  cat("reset Filter")
  rv_param_temp$resetFilter <- FALSE # make sure these are still set to FALSE. User can't filter or plot data until they are downloaded/imported.


  showModal(modalDialog(
    title = "Done",
    "In the '2. Filter sites to download' panel of the left sidebar, select monitoring sites by HUC or by distance from an origin site, then click the 'Highlight Selected Sites' button."
  ))

}, ignoreInit = TRUE) # end of run search button
```

```{r action_button_highlightStations}
# Action to highlight selected stations ----
observeEvent(eventExpr = input$button_highlightStations, {
  
  if(is.null(input$sel_Organization)) {
    showModal(modalDialog(
      title = "No organization selected",
      "Please select at least one organization to download WQ data from"))
    shiny::req(!is.null(input$sel_Organization))
    }
  
  if(is.null(input$sel_SiteType)) {
      showModal(modalDialog(
        title = "No site type selected",
        "Please select at least one site type to download WQ data for"))
      shiny::req(!is.null(input$sel_SiteType))
    }

  # Select stations by HUC
  if(input$sel_SelectMethod == "methodHuc") {
    if(is.null(rv$selectedHucs)) {
      showModal(modalDialog(
        title = "No HUCs selected",
        "Please click on the map to select HUC(s)."
      ))
      shiny::req(!is.null(rv$selectedHucs))
    }

    rv$selectedOriginStation <- NULL
    rv$selectedUpstreamLines <- NULL
    rv$selectedDownstreamLines <- NULL
    rv$selectedUpstreamStations <- NULL
    rv$selectedDownstreamStations <- NULL

    # rv$selectedStations <- rv$sitesPointsSub[rv[[input$sel_HUClevel]][rv[[input$sel_HUClevel]]@data$HUC %in% rv$selectedHucs,],]@data %>% # data in selected HUCs
    rv$selectedStations <- rv$sitesPointsSub[rv[[input$sel_HUClevel]][rv[[input$sel_HUClevel]]$HUC %in% rv$selectedHucs,],] %>%
      dplyr::filter(OrganizationFormalName %in% input$sel_Organization) %>% # limit to selected orgs and site types
      dplyr::select(MonitoringLocationIdentifier, OrganizationFormalName) %>%
      dplyr::distinct() %>%
      dplyr::arrange(MonitoringLocationIdentifier) %>%
      as.data.frame
    
    shiny::req(length(rv$selectedStations$MonitoringLocationIdentifier) > 0)
  
    showModal(modalDialog(
    title = "Done",
    "Selected monitoring sites are shown as larger, white-outlined circles on the map. Select gage and weather stations to download (if available) and select characteristic groups to download, then press the green 'DOWNLOAD DATA' button to import the water quality data"
    ))
    } # end of methodHuc
 
  # Select stations by distance from origin
  if(input$sel_SelectMethod == "methodDist") {
     
    if(is.null(input$sel_OriginStationID)) {
      showModal(modalDialog(
        title = "No origin monitoring site entered", 
        "To select monitoring sites based on distance from an origin, please enter an origin monitoring site"
      ))
      shiny::req(!is.null(input$sel_OriginStationID))
    }
    
    if(!input$sel_OriginStationID %in% unique(rv$sitesPointsSub$MonitoringLocationIdentifier[rv$sitesPointsSub$OrganizationFormalName %in% input$sel_Organization])) {
      showModal(modalDialog(
        title = "Cannot find the requested origin monitoring site",
        "The requested origin monitoring site is not available for the Park and organizations of interest."
      ))
      shiny::req(input$sel_OriginStationID %in% unique(rv$sitesPointsSub$MonitoringLocationIdentifier[rv$sitesPointsSub$OrganizationFormalName %in% input$sel_Organization]))
    }
 
  if(input$sel_DistKmUpstream == 0 & input$sel_DistKmDownstream == 0) {
        showModal(modalDialog(
          title = "No distance from origin monitoring site entered",
          "To select monitoring sites based on distance from an origin, please enter a distance (in km) upstream or downstream from the origin monitoring site."
        ))
        shiny::req(input$sel_DistKmUpstream > 0 | input$sel_DistKmDownstream > 0)
      }

    withProgress(message = "Downloading from Hydro Network-Linked Data Index...", value = 0, {
      
        showModal(tags$div(id = "gif_modal", modalDialog(
      HTML('<img src="https://media.giphy.com/media/l44QjgeQ5ium91n9K/source.gif"><br><center>I am just your entertainment.<br><center>The progress bar is below.'), # custom loading gif--raccoon thief
      easyClose = TRUE,
      footer = NULL
      )))
      
    nldiURLS <- list(
      selectedOriginStation = paste0("https://labs.waterdata.usgs.gov/api/nldi/linked-data/nwissite/", input$sel_OriginStationID),
      selectedUpstreamLines = ifelse(input$sel_DistKmUpstream > 0, paste0("https://labs.waterdata.usgs.gov/api/nldi/linked-data/nwissite/", input$sel_OriginStationID, "/navigation/", ifelse(input$sel_IncludeTribs, "UT", "UM"), "?distance=", input$sel_DistKmUpstream), NA),
      selectedDownstreamLines = ifelse(input$sel_DistKmDownstream > 0, paste0("https://labs.waterdata.usgs.gov/api/nldi/linked-data/nwissite/", input$sel_OriginStationID, "/navigation/", ifelse(input$sel_IncludeDiversions, "DD", "DM"), "?distance=", input$sel_DistKmDownstream), NA),
      selectedUpstreamStations = ifelse(input$sel_DistKmUpstream > 0, paste0("https://labs.waterdata.usgs.gov/api/nldi/linked-data/nwissite/", input$sel_OriginStationID, "/navigation/", ifelse(input$sel_IncludeTribs, "UT", "UM"), "/wqp?distance=", input$sel_DistKmUpstream), NA),
      selectedDownstreamStations = ifelse(input$sel_DistKmDownstream > 0, paste0("https://labs.waterdata.usgs.gov/api/nldi/linked-data/nwissite/", input$sel_OriginStationID, "/navigation/", ifelse(input$sel_IncludeDiversions, "DD", "DM"), "/wqp?distance=", input$sel_DistKmDownstream), NA))
    
    saveRDS(nldiURLS, "temp_nldi.RDS")
 
    for(n in names(nldiURLS)) {
   
      incProgress(1/7, detail = paste0("...", n))
      if(!is.na(nldiURLS[[n]])) { # if URL is specified
        tempURL <- nldiURLS[[n]]
      
        if(http_status(polite_GET(tempURL))$category!="Success") { # make sure the service call is valid
          showModal(
            urlModal(tempURL, title = "Data Retrieval Error", subtitle = paste0("Error retrieving data from the Hydro Network-Linked Data Index for the `", n, "` query. The message from the web service is: `", http_status(polite_GET(tempURL))$message, "`.\n\nTo confirm this is a problem with the web service (and not the dashboard), enter the above URL in a browser and see if data successfully downloads."))
            )
          }
   
        shiny::validate(need(http_status(polite_GET(tempURL))$category=="Success", message = FALSE)) # if not a valid service call, abort
        
        checkhydro <- tryCatch(rgdal::readOGR(dsn = tempURL[[1]], verbose = FALSE), error=function(e) NULL)
    
        if(is.null(checkhydro)) {
        showModal(modalDialog(
          title = "No Data",
          "Error retrieving data from the Hydro Network-Linked Data Index",
          footer = modalButton("OK")
          ))
        } else {
          checkhydro <- spTransform(checkhydro, CRS("+proj=longlat +datum=WGS84")) # convert to WGS84
          rv[[n]] <- checkhydro 
        }
      
        # renderText(paste(n, "is of class", class(nldiData[n][[1]])[1], "and has", length(nldiData[n][[1]]), "features"))
      }
    }
    }) # end of with Progress
# 
    rv$selectedStations <- 
      rbind.fill(data.frame(rv$selectedOriginStation), if(!is.null(rv$selectedUpstreamStations)) data.frame(rv$selectedUpstreamStations), if(!is.null(rv$selectedDownstreamStations)) data.frame(rv$selectedDownstreamStations)) %>% # combine into one data frame
      dplyr::rename(MonitoringLocationIdentifier = identifier) %>%
      left_join(unique(data.frame(rv$sitesPointsSub[, c("MonitoringLocationIdentifier", "OrganizationFormalName")])), by = "MonitoringLocationIdentifier") %>%
      dplyr::filter(OrganizationFormalName %in% input$sel_Organization) %>%
      # dplyr::filter(OrganizationFormalName %in% input$sel_Organization & MonitoringLocationTypeName %in% input$sel_SiteType) %>% # limit to selected orgs and site types -----PICK UP FROM HERE
      dplyr::distinct() %>%
      dplyr::arrange(MonitoringLocationIdentifier) %>%
      as.data.frame
    
    shiny::req(length(rv$selectedStations$MonitoringLocationIdentifier) > 0)

    showModal(modalDialog(
    title = "Done",
    "Selected monitoring sites are shown as larger, white-outlined circles on the map. The origin site is outlined in red. The selected streamlines upstream of the origin are shown in white; downstream, in brown. Filter weather stations (if available) and characteristic groups to download, then press the green 'DOWNLOAD DATA' button to get the selected data"
    ))
} # end of methodDist
  
  if(!is.null(rv$meteoStations)|!is.null(rv$gageStations)) {shinyjs::showElement("new_data_P3")}
  shinyjs::showElement("new_data_P4")
  # shinyjs::enable("new_data_P4")
  }, ignoreInit = TRUE) # end of observeEvent
```

```{r action_button_downloadData}
# Action to download WQP data ----
observeEvent(eventExpr = input$button_downloadData, { 

    if(length(input$sel_Organization) == 0) { # make sure organization(s) have been selected
    showModal(modalDialog(
      title = "No organizations selected",
      "Please select (from the checklist) at least one organization from which you would like water quality data."
    ))
    }
  shiny::req(length(input$sel_Organization) > 0)
  
  if(length(input$sel_CharType) == 0) { # make sure characteristic group(s) have been selected
    showModal(modalDialog(
      title = "No characteristic groups selected",
      "Please select (from the checklist) at least one characteristic group of data to import."
    ))
    }
  shiny::req(length(input$sel_CharType) > 0)
  
  if(is.null(rv$selectedStations) | length(rv$selectedStations$MonitoringLocationIdentifier) == 0) {
    showModal(modalDialog(
      title = "No monitoring sites selected",
      "Please select monitoring sites from which you would like to import data (filter sites by HUC or by distance from origin, then click the 'Highlight Selected Stations' button)."
    ))
  }
  shiny::req(!is.null(rv$selectedStations), !is.null(rv$sitesPointsSub))
  shiny::req(length(rv$selectedStations$MonitoringLocationIdentifier) > 0)

    withProgress(message = "Processing data request...", detail = "Importing data from Water Quality Portal", value = 0, { # >>>>>>>>>>>>>> PICK UP FROM HERE--BREAK IT UP https://community.openai.com/t/parallelise-calls-to-the-api-is-it-possible-and-how/35498/10
      
      showModal(tags$div(id = "gif_modal", modalDialog(
        HTML('<img src="https://media.giphy.com/media/33zX3zllJBGY8/source.gif"><br><center>I am just your entertainment.<br><center>The progress bar is below.'), # custom loading gif--running elephant
        easyClose = TRUE,
        footer = NULL
      )))
      
      sel_OrgIdentifier <- sort(unique(rv$sitesPointsSub$OrganizationIdentifier[rv$sitesPointsSub$OrganizationFormalName %in% input$sel_Organization]))
  orgChoiceString <- paste0(sel_OrgIdentifier, collapse = "&organization=") # really I shouldn't need this because I have the site ID's

  charTypeChoiceString <- paste(input$sel_CharType, collapse = "&characteristicType=", sep = ";") %>%
    gsub(",", "%2C", .) %>%
    gsub(" ", "%20", .)
  
  stationChoiceTemp <- 
    rv$selectedStations %>%
    dplyr::filter(OrganizationFormalName %in% input$sel_Organization) %>% # only download data for stations within the selected organizations
    dplyr::select(MonitoringLocationIdentifier) %>%
    dplyr::distinct() %>%
    dplyr::arrange() %>%
    .$MonitoringLocationIdentifier 
  stationChoiceString <- paste0(stationChoiceTemp, collapse = "&siteid=")
  
  # datURL <- paste0("https://www.waterqualitydata.us/data/Result/search?siteType=", siteTypeChoiceString, "&organization=", orgChoiceString, "&siteid=", stationChoiceString, "&characteristicType=", charTypeChoiceString, "&minactivities=", input$sel_MinActivities, "&startDateLo=", format(input$sel_ImportStartDate,"%m-%d-%Y"), "&sampleMedia=Water&mimeType=csv&zip=no") # could not find a way to use dataRetrieval for multiple HUCs or multiple sites
  
  datURL <- paste0("https://www.waterqualitydata.us/data/Result/search?organization=", orgChoiceString, "&siteid=", stationChoiceString, "&characteristicType=", charTypeChoiceString, "&sampleMedia=Water&mimeType=csv&zip=no") # REMOVED SITETYPE & MINACTIVITIES & START & END DATES AS AN OPTION AT THIS STAGE
  
  rv$wqp_url <- datURL
  cat(datURL)

  if(http_status(polite_GET(datURL))$category!="Success") { # make sure the service call is valid
      showModal(
        urlModal(datURL, title = "Data Retrieval Error", subtitle = paste0("Error retrieving data from the Water Quality Portal for the requested query. The message from the web service is: `", http_status(polite_GET(datURL))$message, "`.\n\nTo confirm this is a problem with the web service (and not the dashboard), enter the above URL in a browser and see if data successfully downloads. If an error results, email WQP support (wqx@epa.gov) for assistance."))
        )
      }

  shiny::validate(need(http_status(polite_GET(datURL))$category=="Success", message = FALSE)) # if not a valid service call, abort
  
  setProgress(1/4, detail = "Formatting data")

  download.file(datURL, "tempDat.csv", mode = "w") # in Windows, mode = "w" when opening text files and "wb" for other types, such as .jpg
 
  rawDat <- read.csv("tempDat.csv") # use read.csv instead of read_csv so will convert '/' in column names to '.'
  tempDat <- rawDat

# Format WQP data ----
  
  # Convert to NA, any records with no data reported
  no_data_strings <- c("Not Reported", "No Data", "UNK", "Unknown")
  tempDat$ResultMeasureValue[grep(paste(no_data_strings, collapse = "|"), tempDat$ResultMeasureValue)] <- NA # <<<< ERROR CHECK

  # Detected and Quantified
  tempDat[tempDat==""] <- NA
  tempDat$ResultMeasure.MeasureUnitCode[is.na(tempDat$ResultMeasure.MeasureUnitCode) & !is.na(tempDat$DetectionQuantitationLimitMeasure.MeasureUnitCode)] <- tempDat$DetectionQuantitationLimitMeasure.MeasureUnitCode[is.na(tempDat$ResultMeasure.MeasureUnitCode) & !is.na(tempDat$DetectionQuantitationLimitMeasure.MeasureUnitCode)]
  tempDat$ResultDetectionConditionText[is.na(tempDat$ResultDetectionConditionText)] <- "Detected and Quantified"
 cat("line2918")
 
  # Split survey date
  tempDat$ActivityStartDate = base::as.Date(tempDat$ActivityStartDate)
  tempDat2 <- FuncBreakDates(tempDat) %>%
    dplyr::mutate(CharacteristicSet = paste(OrganizationIdentifier, CharacteristicName, ResultSampleFractionText, ResultMeasure.MeasureUnitCode, ResultAnalyticalMethod.MethodIdentifier, sep = "_")) %>% # this is the column for identifying comparable records (also optionally consider OrganizationIdentifier and LaboratoryName)
    dplyr::arrange(CharacteristicName, MonitoringLocationIdentifier, ActivityStartDate)
 
  # Remove characteristics with string class values
  paramText <- unique(tempDat2$CharacteristicName[grepl(pattern="(text)", x=tempDat2$CharacteristicName)])
  tempDat2 %<>%
    dplyr::filter(!CharacteristicName %in% paramText)

  convert_factors <- c("OrganizationIdentifier", "OrganizationFormalName", "ActivityTypeCode", "ActivityStartTime.TimeZoneCode", "MonitoringLocationIdentifier", "HydrologicCondition", "HydrologicEvent", "ResultDetectionConditionText", "CharacteristicName", "ResultSampleFractionText", "ResultStatusIdentifier", "ResultValueTypeName", "DetectionQuantitationLimitTypeName", "CharacteristicSet")
  tempDat2[convert_factors] <- sapply(tempDat2[convert_factors], as.factor) # convert these to factor class so they can be searched with drop-down lists
  
  rv$dat <- tempDat2 %>%
    dplyr::ungroup() %>%
    dplyr::select(OrganizationIdentifier, OrganizationFormalName, MonitoringLocationIdentifier, ActivityStartDate, ActivityTypeCode, CharacteristicName, ResultSampleFractionText, ResultMeasureValue, ResultMeasure.MeasureUnitCode, ResultDetectionConditionText, everything()) # Most important variables first, followed by everything else
  rm(rawDat, tempDat, tempDat2, paramText)
  unlink("tempDat.csv")
  
  # Get organization information for WQP data ----
  shiny::req(!is.null(rv$dat))
    # Limited to specified date range and minimum activities number
  allOrgs <- paste(paste0("organization=", unique(rv$dat$OrganizationIdentifier)), collapse = "&")
    orgURL <- paste0("https://www.waterqualitydata.us/data/Organization/search?", allOrgs, "&mimeType=csv&zip=no&providers=NWIS&providers=STEWARDS&providers=STORET")

  if(http_status(polite_GET(orgURL))$category!="Success") { # make sure the service call is valid
    showModal(
      urlModal(orgURL, title = "Data Retrieval Error", subtitle = paste0("Error retrieving organization information from the Water Quality Portal. The message from the web service is: `", http_status(polite_GET(orgURL))$message, "`.\n\nTo confirm this is a problem with the web service (and not the dashboard), enter the above URL in a browser and see if data successfully downloads."))
      )
  }
    
  shiny::req(http_status(polite_GET(orgURL))$category=="Success") # if not a valid service call, abort

    download.file(orgURL, "tempOrg.csv", mode = "w")
  
  rv$orgs <- read_csv("tempOrg.csv") %>%
    # dplyr::filter(OrganizationFormalName %in% unique(rv$sitesPointsSub$OrganizationFormalName)) %>%
    # dplyr::filter(OrganizationFormalName %in% unique(rv$sitesPointsSub$OrganizationFormalName)) %>%
    dplyr::select(OrganizationFormalName, Description = OrganizationDescriptionText, `Email/Web` = ElectronicAddress, Phone = Telephonic) %>%
    dplyr::mutate(Selected = TRUE) %>%
    arrange(OrganizationFormalName) %>%
    as.data.frame
  
  rm(orgURL, allOrgs)
  unlink("tempOrg.csv")
  
  # Get streamflow data from selected gage stations ----
  # Waiting to hear back about getting info on Federal Priority Streamgages
  if(all(!is.null(rv$gageStations), !is.null(rv$selectedGages))) {
    if(all(nrow(rv$gageStations) > 0, length(rv$selectedGages) > 0)) {
  setProgress(2/4, detail = "Getting streamflow data from selected USGS gage stations")
      
  # gagesDatURL <- paste0("https://waterservices.usgs.gov/nwis/dv/?format=rdb,1.0&sites=", paste(rv$selectedGages$GageID, collapse = ","), "&startDT=", format(input$sel_ImportStartDate,"%Y-%m-%d"), "&endDT=", format(input$sel_ImportEndDate,"%Y-%m-%d"), "&siteStatus=all")
  
  gagesDatURL <- paste0("https://waterservices.usgs.gov/nwis/dv/?format=rdb,1.0&sites=", paste(rv$selectedGages$GageID, collapse = ","), "&startDT=",range(rv$dat$ActivityStartDate)[1], "&endDT=", range(rv$dat$ActivityStartDate)[2], "&siteStatus=all") # <<<< GOT RID OF START STOP AND END DATE OPTION HERE
  
  if(http_status(polite_GET(gagesDatURL))$category!="Success") { # make sure the service call is valid
    rv$gagesDat <- NULL
    showModal(modalDialog(
      title = "No Streamflow Data",
      "Error retrieving data for selected selected stream gages."
      ))
    } else {
      download.file(gagesDatURL, "tempGagesDat.txt", mode = "w")
      
      gagesDat <- tryCatch(read.delim("tempGagesDat.txt", comment.char = '#'), error=function(e) print("Error retrieving USGS streamflow data")) # These daily data are  'Discharge, cubic feet per second (Mean)'. QC: 'A' means approved for publication, processing and review completed; 'e' means value has been estimated
     
    shiny::req(!is.null(gagesDat))
    names(gagesDat) <- c("Agency", "GageID", "ActivityStartDate", "MeanDailyDischarge", "MeanDailyDischargeQC")
    gagesDat <- subset(gagesDat, Agency == "USGS") %>%
      dplyr::select(Agency, GageID, ActivityStartDate, MeanDailyDischarge, MeanDailyDischargeQC) %>%
      left_join(unique(rv$selectedGages[c("GageName", "GageID")]), by = "GageID")
    gagesDat$ActivityStartDate<- base::as.Date(gagesDat$ActivityStartDate)
    gagesDat$MeanDailyDischarge <- as.integer(gagesDat$MeanDailyDischarge)
    rv$gagesDat <- FuncBreakDates(gagesDat)
    rm(gagesDat, gagesDatURL)
    unlink("tempGagesDat.txt")
    }
    }
  }
  
  # Get precipitation data from selected weather stations ----
  if(all(!is.null(rv$meteoStations), !is.null(rv$selectedMeteo))) {
    if(all(nrow(rv$meteoStations) > 0, length(rv$selectedMeteo) > 0)) {
  setProgress(3/4, detail = "Getting precipitation data from selected weather stations")
  
  tempMeteoDat <- rnoaa::meteo_pull_monitors(monitors = sort(unique(rv$selectedMeteo$MeteoShortID)), keep_flags = TRUE, date_min = range(rv$dat$ActivityStartDate)[1], date_max = range(rv$dat$ActivityStartDate)[2], var = "PRCP") %>% # pull precipitation data (tenths of mm) for the stations and date range corresponding with downloaded WQP data
    dplyr::filter(!is.na(prcp)) %>%
    dplyr::mutate(prcp = as.numeric(prcp))
  if(!is.null(tempMeteoDat)) {
    if(nrow(tempMeteoDat) > 0 ) {
    tempMeteoDat %<>%
    dplyr::mutate(PRCP_cm = prcp/100) %>% # prcp is in tenths of mm. Convert precip measure to cm
    dplyr::filter(qflag_prcp == " ") %>% # only keep data without quality flags
    dplyr::select(MeteoShortID = id, ActivityStartDate = date, PRCP_cm) 
  
  tempMeteoDat2 <- tempMeteoDat[complete.cases(tempMeteoDat), ] %>% left_join(rv$selectedMeteo[, c("MeteoName", "MeteoShortID")])
  tempMeteoDat2$ActivityStartDate <- base::as.Date(tempMeteoDat2$ActivityStartDate)
  rv$meteoDat <- FuncBreakDates(tempMeteoDat2)
  rm(tempMeteoDat, tempMeteoDat2)
  }
    # } else {
    # rv$meteoDat <- NULL
    # rv$meteoStations <- NULL
    # rv$selectedMeteo <- NULL
  }
    }
  }
  
  # Save query ----
  
  # Update rv$userSelect with the import settings
  import_input <- c("sel_UnitCode", "sel_SiteType", "sel_HUClevel", "sel_SelectMethod", "sel_OriginStationID", "sel_DiskKmUpstream", "sel_IncludeTribs", "sel_DistKmDownstream", "sel_IncludeDiversions", "sel_Organization", "sel_Gages", "sel_Meteo", "sel_CharType") # >>>> REMOVED THESE: "sel_ImportStartDate", "sel_ImportEndDate", "sel_MinActivities"
  FuncUpdateUserSelect(inputs_to_update = import_input) 
  
    rv$orgs$Selected <- FALSE
    rv$orgs$Selected[rv$orgs$OrganizationFormalName %in% input$sel_Organization] <- TRUE # identify if each organization was selected for import or not

  rv_param_temp$resetFilter <- TRUE
  rv_param_temp$newImport <- TRUE
 
    showModal(modalDialog(
      title = "Done",
      paste0("Data import SUCCESSFUL. You may now navigate to the FILTER DATA tab to choose a subset of data to work with. OPTIONAL: To download the formatted data file (.RDS) to your computer, press the `Download Formatted RDS` button in the left side panel. ") 
    ))
  })
}, ignoreInit = TRUE) # end of observeEvent
```
  
```{r if_resetFilter_TRUE}
# When new data loaded, reset filter inputs to default values ----
renderUI({
  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$resetFilter))
  if(rv_param_temp$resetFilter == TRUE) {

    # Update the input values on Filter page - note that the updates won't activate until the Filter page is in focus (at least once during session)
    FuncUpdateFilter() 
    
    rv_param_temp$subDatYears <- NULL
    rv_param_temp$subDat <- NULL
    rv_param_temp$resetFilter <- FALSE # once the inputs have updated, set resetFilter back to FALSE and update the plot inputs

  }

})
```

```{r events_import_page}
observeEvent(eventExpr = input$dismiss_discharge_modal, {
  removeModal()
  })

observeEvent(eventExpr = input$dismiss_weather_modal, {
  removeModal()
  })

observeEvent(eventExpr = input$dismiss_gages_modal, {
  removeModal()
  })
  
renderUI({
  shiny::req(!is.null(rv$meteoStations), !is.null(input$sel_GetData), is.null(rv$dat))
  shiny::req(input$sel_GetData == "new_data")
  rv$selectedMeteo <- switch(is.null(input$sel_Meteo)+1, rv$meteoStations[rv$meteoStations$MeteoName %in% input$sel_Meteo,], NULL)
})

renderUI({
  shiny::req(!is.null(rv$gageStations), !is.null(input$sel_GetData), is.null(rv$dat))
  shiny::req(input$sel_GetData == "new_data")
  cat("updating SELECTED GAGES")

  rv$selectedGages <- switch(is.null(input$sel_Gages)+1, rv$gageStations[rv$gageStations$GageName %in% input$sel_Gages,], NULL)
  # Sys.sleep(1)
})
```

```{r events_filter_page}
# Show or hide the well panels based on checkbox selection, but enable them as soon as rv$dat is available ----

# Action to attach a thresholds file ----
observeEvent(eventExpr = input$button_getThreshFile, { 
  if(is.null(rv$dat)) { # can't print validation message within observeEvent, so use modalDialogs
    rv_param_temp$threshList <- NULL
    showModal(modalDialog(
      title = "No Data",
      "Could not find any water quality data to associate with a threshold limits file. To import or load water quality data, use the dashboard page titled 'Get WQP Data'."
    ))
  }
  
  shiny::req(!is.null(input$sel_GetThreshFile))
  if (input$sel_GetThreshFile == "existing_data") {
    showModal(modalDialog(
      fileInput("saved_thresh_file", label = "Attach a threshold limits file ('csv' extension)", placeholder = "Click 'Browse...' button then navigate to file", accept = c('.csv'), width = "100%"),
               footer = tagList(
                 modalButton("Cancel")
               )
    ))
  }
}) # end observeEvent

# Action to load optional threshold limits .csv file ----
observeEvent(eventExpr = input$saved_thresh_file, {
  shiny::req(!is.null(input$saved_thresh_file$datapath))
  if(!tools::file_ext(input$saved_thresh_file$datapath) == "csv") {
    showModal(modalDialog(
    title = "Error",
    "File must have .csv extension. Please select a different file."
    ))
  } else {

    tryCatch(out_thresh_file <- read_csv(input$saved_thresh_file$datapath),
             error = function(e) {out_categ_file <- NULL; print("Cannot import the selected file")})
    
  shiny::req(!is.null(out_thresh_file))
  
  FuncClearAll()
  tempThresh_df <- out_thresh_file %>%
      dplyr::mutate(ID = paste0(CharacteristicName, " (", MeasureUnit, ")")) # unique ID, for user choice

    tempThresh_list <- list()
    for (i in 1:nrow(tempThresh_df)) {
      threshID <- unlist(tempThresh_df[i, "ID"])
      tempThresh_list[[threshID]]$CharacteristicName <- tempThresh_df$CharacteristicName[i]
      tempThresh_list[[threshID]]$ResultMeasure.MeasureUnitCode <- tempThresh_df$MeasureUnit[i]
      tempThresh_list[[threshID]]$Notes <- tempThresh_df$Notes[i]
      tempThresh_list[[threshID]]$cut_breaks <- as.numeric(unlist(base::strsplit(str_replace_all(tempThresh_df$ThreshBreaks[i], "[()]", ""), split=",")))
      tempThresh_list[[threshID]]$cut_categ <- unlist(base::strsplit(str_replace_all(tempThresh_df$ThreshCateg[i], "[()]", ""), split=","))
      tempThresh_list[[threshID]]$cut_colors <- unlist(base::strsplit(str_replace_all(tempThresh_df$ThreshColor[i], "[()]", ""), split=","))
    }
    
    rv_param_temp$threshList <- tempThresh_list
    rm(tempThresh_df, tempThresh_list)
    
    showModal(modalDialog(
    title = "Done",
    "Threshold limits file has been imported"
    ))
  }
}, ignoreInit = TRUE) # end of observeEvent

```

```{r events_datacheck_page}
# Conditions for showing vs. hiding well panels ----
renderUI({
  if(!is.null(rv_param_temp$subDat) & !is.null(input$sel_CheckChar)) {
  shinyjs::showElement("data_check_stations")
  } else {
    shinyjs::hideElement("data_check_stations")
  }
})

renderUI({
  if(!is.null(rv_param_temp$subDat) & !is.null(input$sel_CheckChar) & !is.null(input$sel_CheckStations)) {
  shinyjs::showElement("data_check_var")
  } else {
    shinyjs::hideElement("data_check_var")
  }
})

# Action to select all stations ----
observeEvent(eventExpr = input$button_allStationCheck, {
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_CheckChar))
  
  updateCheckboxGroupInput(session,
                           "sel_CheckStations",
                           # label = h6("Monitoring sites to include: "),
                           choices = sort(unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharacteristicName==input$sel_CheckChar])),
                           selected = sort(unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharacteristicName==input$sel_CheckChar])))}, ignoreInit = TRUE) # end of observeEvent

# Action to select no stations ----
observeEvent(eventExpr = input$button_noStationCheck, {
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_CheckChar))
  
  updateCheckboxGroupInput(session,
                           "sel_CheckStations",
                           # label = h6("Monitoring sites to include: "),
                           choices = sort(unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharacteristicName==input$sel_CheckChar])),
                           selected = character(0))
  }, ignoreInit = TRUE) # end of observeEvent

```

```{r events_categfiles_page}
# Action to define categorical characteristics ----
observeEvent(eventExpr = input$button_getCategFile, { 
  # initiate categorical levels data frame
  if(is.null(rv$dat)) { # can't print validation message within observeEvent, so use modalDialogs
    rv_param_temp$categLevelsPlot <- NULL
    showModal(modalDialog(
      title = "No Data",
      "Could not find any water quality data to associate with a color coding file. To import or load water quality data, use the dashboard page titled 'Get WQP Data'."
    ))
    }
  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$subDatTypes))
  
  if(length(rv_param_temp$subDatTypes$CharacteristicName[rv_param_temp$subDatTypes$DataType == "categorical"])==0) { # can't print validation message within observeEvent, so use modalDialogs
    rv_param_temp$categLevelsPlot <- NULL
    showModal(modalDialog(
      title = "No categorical parameters",
      "Could not find any categorical parameters among the filtered water quality data."
    ))
    }
  shiny::req(length(rv_param_temp$subDatTypes$CharacteristicName[rv_param_temp$subDatTypes$DataType == "categorical"]) > 0)
  
    rv_param_temp$categLevelsPlot <- tibble("CharacteristicName" = as.character(), "CategOrder" = as.character(), "CategColor" = as.character())
  
shiny::req(!is.null(input$sel_GetCategFile))
  if (input$sel_GetCategFile == "new_data" & !is.null(rv_param_temp$categLevelsPlot)) { # if user chooses to create a new file...
    shinyjs::showElement("create_categfile_P1")
    shinyjs::showElement("create_categfile_P2")
    shinyjs::showElement("create_categfile_P3")
    } else { # if user chooses to load existing data...
      shinyjs::hideElement("create_categfile_P1")
      shinyjs::hideElement("create_categfile_P2")
      shinyjs::hideElement("create_categfile_P3")
      
      showModal(modalDialog(
        fileInput("saved_categ_file", label = "Attach a categorical definitions file ('csv' extension)", placeholder = "Click 'Browse...' button then navigate to file", accept = c('.csv'), width = "100%"),
               footer = tagList(
                 modalButton("Cancel")
               )
             ))
           }
         }) # end observeEvent

# Action to load optional color-coding .csv file ----
observeEvent(eventExpr = input$saved_categ_file, {
  shiny::req(!is.null(input$saved_categ_file$datapath))
  if(!tools::file_ext(input$saved_categ_file$datapath) == "csv") {
    showModal(modalDialog(
    title = "Error",
    "File must have .csv extension. Please select a different file."
    ))
  } else {

    tryCatch(out_categ_file <- read_csv(input$saved_categ_file$datapath),
             error = function(e) {out_categ_file <- NULL; print("Cannot import the selected file")})
    
  shiny::req(!is.null(out_categ_file))
  rv_param_temp$categLevelsPlot <- out_categ_file
  showModal(modalDialog(
    title = "Done",
    "Categorical definitions have been imported"
    ))
  }
  })

# Action to add category level ----
observeEvent(eventExpr = input$button_addCategLevel, {
  showModal(
    modalDialog(
      textInput("new_categlevel_text", "Enter a new level for the categorical characteristic: "),
      footer = tagList(
        div(style="display:inline-block; width:100px; margin-right:10px;", actionButton("button_cancelModal", "Cancel")),
        div(style="display:inline-block; width:180px;", actionButton("button_okAddCategLevelsModal", "Add to List"))
        ) # end footer tagList
      )
    )
  })

observeEvent(eventExpr = input$button_okAddCategLevelsModal, {
  shiny::req(!is.null(rv_param_temp$categLevels), !is.null(input$new_categlevel_text), nzchar(input$new_categlevel_text))
  rv_param_temp$categLevels <- data.frame(ResultMeasureValue = c(input$categ_ranked, input$new_categlevel_text)) # append the new category level, preserving the user-defined rank order
  removeModal()

  })

# Action to delete category level ----
observeEvent(eventExpr = input$button_deleteCategLevel, {
  shiny::req(!is.null(rv_param_temp$categLevels))
  if(nrow(rv_param_temp$categLevels)==0) { # can't print validation message within observeEvent, so use modalDialogs
    showModal(modalDialog(
      title = "No Data",
      "No categorical levels in list."
    ))
    }
  
  shiny::req(nrow(rv_param_temp$categLevels) > 0)
  showModal( 
    modalDialog(
      renderUI({
        selectInput("remove_categ_level",
                    label = "Categorical level to remove from list (will be color-coded as NA): ",
                    choices = rv_param_temp$categLevels$ResultMeasureValue,
                    selected = rv_param_temp$categLevels$ResultMeasureValue[1]
                    )
        }),
      footer = tagList(
        div(style="display:inline-block; width:100px; margin-right:10px;",
            
            actionButton("button_cancelModal", "Cancel")), # use actionButton instead of modalButton to ensure consistent sizing with other actionButton
        div(style="display:inline-block; width:180px;",
            actionButton("button_okDeleteCategLevelsModal", "Remove From List"))
        ) # end footer tagList
      )
    )
  })

observeEvent(eventExpr = input$button_okDeleteCategLevelsModal, {
  shiny::req(nrow(rv_param_temp$categLevels) > 0, !is.null(input$remove_categ_level))
  rv_param_temp$categLevels <- data.frame(ResultMeasureValue = setdiff(input$categ_ranked, input$remove_categ_level)) # remove the category level
  removeModal()
  })

# Action to show color palette options ----
observeEvent(eventExpr = input$button_showPalettes, {
  removeModal()
  showModal(
    modalDialog(
      renderPlot({display.brewer.all()}, height = 700),
      size = "l"
    )
  )
}) # originally tried bsModal() from package 'shinyBS' but it seems to have problems with the current shiny version

# Action to update the categorical definitions file ----
observeEvent(eventExpr = input$button_updateCategFile, {

  shiny::req(!is.null(rv_param_temp$categLevelsPlot), !is.null(input$sel_CategParam), !is.null(input$categ_ranked), !is.null(input$sel_CategPalette))  
  
  rv_param_temp$categLevelsPlot %<>%
    add_row(
      CharacteristicName = input$sel_CategParam, # characteristic name
      CategOrder = paste0("(", paste(input$categ_ranked, collapse = "//"), ")"), # categ order
      CategColor = paste0("(", paste(get_brewer_pal(input$sel_CategPalette, length(input$categ_ranked), plot = FALSE), collapse = "//"), ")") # categ color
    )
  })             
              
# Action to edit table cells ----
observeEvent(input$categDT_cell_edit, {
info = input$categDT_cell_edit
i = info$row
j = info$col
v = info$val
rv_param_temp$categLevelsPlot[i, j] <<- DT::coerceValue(v, rv_param_temp$categLevelsPlot[i, j])
replaceData(proxyDT, rv_param_temp$categLevelsPlot, resetPaging = FALSE)
})

# Action to delete table row ----
observeEvent(input$button_categDeleteRow, {
  shiny::req(!is.null(rv_param_temp$categLevelsPlot), !is.null(input$categDT_rows_selected))
    i = input$categDT_rows_selected
    rv_param_temp$categLevelsPlot <- rv_param_temp$categLevelsPlot[-i,]
    replaceData(proxyDT, rv_param_temp$categLevelsPlot, resetPaging = FALSE)
})

# Action to add table row ----
observeEvent(input$button_categAddRow, {
  shiny::req(!is.null(rv_param_temp$categLevelsPlot))
  rv_param_temp$categLevelsPlot %<>% 
    add_row()
  replaceData(proxyDT, rv_param_temp$categLevelsPlot, resetPaging = FALSE)
})
```

```{r events_plots_page}

# Action to select all parameters for filter----
observeEvent(eventExpr = input$button_allSummaryParam, {
  shiny::req(!is.null(rv_param_temp$selectParam))

  updateCheckboxGroupInput(session,
                           "sel_SummaryParam",
                           selected = sort(rv_param_temp$selectParam))
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select no parameters for filter ----
observeEvent(eventExpr = input$button_noSummaryParam, {
  shiny::req(!is.null(rv_param_temp$selectParam))

  updateCheckboxGroupInput(session,
                           "sel_SummaryParam",
                           selected = character(0))
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select all stations ----
observeEvent(eventExpr = input$button_allStations, {
  shiny::req(!is.null(rv_param_temp$subDat), input$sel_SummarizeBy == "by_char")
  updateCheckboxGroupInput(session,
                           "sel_ShowStations",
                           selected = sort(unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowChar])))
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select no stations ----
observeEvent(eventExpr = input$button_noStations, {
  shiny::req(!is.null(rv_param_temp$subDat), input$sel_SummarizeBy == "by_char")
  updateCheckboxGroupInput(session,
                           "sel_ShowStations",
                           selected = character(0))
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select all characteristics ----
observeEvent(eventExpr = input$button_allStationChars, {
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
  updateCheckboxGroupInput(session,
                           "sel_ShowStationChars",
                           selected = sort(intersect(unique(rv_param_temp$subDat$CharacteristicName[rv_param_temp$subDat$MonitoringLocationIdentifier == input$sel_ShowOneStation]), rv_param_temp$subDatTypes$CharacteristicName[rv_param_temp$subDatTypes$DataType == "numeric"]))
  )
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select no characteristics ----
observeEvent(eventExpr = input$button_noStationChars, {
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
  updateCheckboxGroupInput(session,
                           "sel_ShowStationChars",
                           # label = h6("Select characteristic(s):"),
                           selected = character(0))
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select all characteristic sets for one characteristic ----
observeEvent(eventExpr = input$button_allCharSets, {
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowChar), !is.null(input$sel_ShowStations))
  shiny::req(input$sel_SummarizeBy == "by_char")
  updateCheckboxGroupInput(session,
                           "sel_ShowCharSets",
                           selected = sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName==input$sel_ShowChar & rv_param_temp$subDat$MonitoringLocationIdentifier %in% input$sel_ShowStations]))
  )
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select no characteristic sets for one characteristic ----
observeEvent(eventExpr = input$button_noCharSets, {
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowChar), !is.null(input$sel_ShowStations))
  shiny::req(input$sel_SummarizeBy == "by_char")
  updateCheckboxGroupInput(session,
                           "sel_ShowCharSets",
                           selected = character(0)
  )
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select all characteristic sets for one station ----
observeEvent(eventExpr = input$button_allStationCharSets, {
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
  updateCheckboxGroupInput(session,
                           "sel_ShowStationCharSets",
                           selected = switch((!is.null(input$sel_ShowStationChars))+1, NULL, sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowStationChars & rv_param_temp$subDat$MonitoringLocationIdentifier == input$sel_ShowOneStation])))
  )
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select no characteristic sets for one station ----
observeEvent(eventExpr = input$button_noStationCharSets, {
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
  updateCheckboxGroupInput(session,
                           "sel_ShowStationCharSets",
                           selected = character(0))
  }, ignoreInit = TRUE) # end of observeEvent
      
```

```{r action_button_update_param_map}
# Action to update data parameter map ----
# User selects stations by CLICKING MAP (to show data plots)
observeEvent(input$param_map_marker_click, {
  isolate({

  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(input$param_map_marker_click$id))# the last one keeps the map from aborting when user clicks on a marker that is not a site marker
shiny::req(any(is.null(input$sel_ParamMapShow), input$sel_ParamMapShow == "show"))  

    clicked_site <- input$param_map_marker_click$id
    cat("GRABBED CLICKED SITE\n")

    if(clicked_site %in% isolate(rv_param_temp$param_map_highlight)) { # if the click is in a selected site
      cat("WAS ALREADY SELECTED\n")

      if(all(input$sel_SummarizeBy == "by_station", length(isolate(rv_param_temp$param_map_highlight)) == 1, identical(clicked_site, isolate(rv_param_temp$param_map_highlight)))) {
        showModal(modalDialog(
          title = "Cannot de-select station",
          "You must highlight at least one station to summarize."
        ))
            } else {
              isolate(rv_param_temp$param_map_highlight <- rv_param_temp$param_map_highlight[rv_param_temp$param_map_highlight != clicked_site]) # then remove it from the list of selected sites
        cat("REMOVED CLICKED SITE FROM VECTOR\n")
            }
      
        
        } else { # if the click is in an unselected site
          cat("CLICKED SITE IS NEW\n")
          if(input$sel_SummarizeBy == "by_station") { # if summarizing by station
            rv_param_temp$param_map_highlight <- clicked_site
            cat("UPDATED VECTOR WITH ONLY CLICKED SITE\n")
          } 
          if(input$sel_SummarizeBy == "by_char") {# if summarizing by characteristic
            rv_param_temp$param_map_highlight <- c(rv_param_temp$param_map_highlight, clicked_site) # append the ID of clicked site
            cat("UPDATED VECTOR BY APPENDING CLICKED SITE\n")
          }

           cat("ADDED CLICKED SITE ON MAP\n")
      }
    
    # Also update the user select in left side panel

    if(input$sel_SummarizeBy == "by_char") {
      updateCheckboxGroupInput(session,
                               "sel_ShowStations",
                               selected = rv_param_temp$param_map_highlight)
    }

    if(input$sel_SummarizeBy == "by_station") {
      updateSelectInput(session,
                        "sel_ShowOneStation",
                        selected = rv_param_temp$param_map_highlight)

    }
      
    # rv_param_temp$update_from_sidebar <- TRUE 
}) # end isolate


    }, ignoreInit = TRUE) # end of observeEvent

```

```{r action_button_refreshPlotData}
# Action to update data summaries with current user inputs----

observeEvent(eventExpr = input$button_refreshPlotData, { 
  # FuncUpdateTSPlots()
  
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_SummarizeBy))

  # These are the user inputs that should only update when plots are refreshed.
  rv_param_temp$sel_summarize_by <- isolate(input$sel_SummarizeBy)
  rv_param_temp$sel_show_thresholds <- isolate(input$sel_ShowThresholds) # save the input setting so plots don't change unless the plot data has been refreshed

  if(isolate(rv_param_temp$sel_summarize_by) == "by_char") {
    rv_param_temp$showStations <- isolate(input$sel_ShowStations)
    rv_param_temp$showCharSets <- isolate(input$sel_ShowCharSets)
  }

  rv_param_temp$sel_add_gage_precip <- isolate(input$sel_AddGagePrecip)
  rv_param_temp$sel_gage_station <- isolate(input$sel_GageStation)
  rv_param_temp$sel_gage_yscale <- isolate(input$sel_gage_YScale)
  rv_param_temp$sel_precip_station <- isolate(input$sel_PrecipStation)
  rv_param_temp$sel_precip_yscale <- isolate(input$sel_precip_YScale)

  if(rv_param_temp$sel_summarize_by == "by_station") {
    rv_param_temp$showStations <- isolate(input$sel_ShowOneStation)
    rv_param_temp$showCharSets <- isolate(input$sel_ShowStationCharSets)
   }
  
    saveRDS(isolate(reactiveValuesToList(rv)), "TEMP_rv.RDS")
saveRDS(isolate(reactiveValuesToList(rv_param_temp)), "TEMP_rv_param_temp.RDS")
saveRDS(isolate(reactiveValuesToList(input)), "TEMP_input.RDS")
  #   # These are the user inputs that should only update when plots are refreshed.
  # rv_param_temp$sel_summarize_by <- input$sel_SummarizeBy
  # rv_param_temp$sel_show_thresholds <- input$sel_ShowThresholds # save the input setting so plots don't change unless the plot data has been refreshed
  # 
  # # if(isolate(rv_param_temp$sel_summarize_by) == "by_char") {
  #   if(rv_param_temp$sel_summarize_by == "by_char") {
  #   rv_param_temp$showStations <- input$sel_ShowStations
  #   rv_param_temp$showCharSets <- input$sel_ShowCharSets
  # }
  # 
  # rv_param_temp$sel_add_gage_precip <- input$sel_AddGagePrecip
  # rv_param_temp$sel_gage_station <- input$sel_GageStation
  # rv_param_temp$sel_gage_yscale <- input$sel_gage_YScale
  # rv_param_temp$sel_precip_station <- input$sel_PrecipStation
  # rv_param_temp$sel_precip_yscale <- input$sel_precip_YScale
  # 
  # if(rv_param_temp$sel_summarize_by == "by_station") {
  #   rv_param_temp$showStations <- input$sel_ShowOneStation
  #   rv_param_temp$showCharSets <- input$sel_ShowStationCharSets
  #  }
  
  if(is.null(rv_param_temp$showStations)) {
    showModal(modalDialog(
      title = "No Monitoring Sites Selected",
      "From the left sidebar, please select at least one monitoring site to plot"
      ))
    }
  shiny::req(!is.null(rv_param_temp$showStations))
  
  if(is.null(rv_param_temp$showCharSets)) {
    showModal(modalDialog(
      title = "No Characteristic Sets Selected",
      "From the left sidebar, please select at least one characteristic and at least one characteristic set to plot"
      ))
    }
  shiny::req(!is.null(rv_param_temp$showCharSets))
      rv_param_temp$finalPlot <- rv_param_temp$seasonalPlot <- list(plotly_page = NULL, shared_legend = NULL)

# Format plot data for time series plot tab
  if(any(is.null(rv_param_temp$subDat),  is.null(rv_param_temp$showStations), is.null(rv_param_temp$showCharSets), is.null(rv_param_temp$sel_summarize_by), is.null(input$sel_AddQuantile), is.null(rv_param_temp$sel_add_gage_precip), is.null(rv_param_temp$sel_show_thresholds))) { 
   
    rv_param_temp$plotDat <- NULL

  } else {          

      withProgress(message = "Formatting plot data...", value = 0, {
          
          rv_param_temp$plotDat <- FuncPlotDat() # this function also assigns data to rv_param_temp$quantDat
      })
  }
})
```

```{r map_card}
output$param_map <- renderLeaflet({

  FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = FALSE) # make sure data have been imported and filtered, and plot data have been generated
  cat("line3730")
    shiny::req(!is.null(rv_param_temp$subDat), !is.null(rv$sitesPointsSub), !is.null(rv$unitPoly), !is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$palOrg))
  
cat("RENDERING ENTIRE MAP AGAIN\n") 

sel_param_map_show <- switch(is.null(input$sel_ParamMapShow)+1, input$sel_ParamMapShow, "show")

map_point_size <- switch(is.null(input$sel_MapPointSize)+1, input$sel_MapPointSize, 0)

  iconGages = makeAwesomeIcon(
    text = fa("water"),
    iconColor = "black",
    markerColor = "blue")
  
  iconGagesSelected = makeAwesomeIcon(
    text = fa("water"),
    iconColor = "black",
    markerColor = "orange")
  
  iconMeteo = makeAwesomeIcon(icon= "fa-cloud", library = "fa", squareMarker = TRUE, markerColor = "white")
  
  iconMeteoSelected = makeAwesomeIcon(icon= "fa-cloud", library = "fa", squareMarker = TRUE, markerColor = "orange") #
  
  iconCWA = makeAwesomeIcon(icon= "fa-building", library = "fa", markerColor = "lightgray")

    param_map <- leaflet(options = leafletOptions(zoomControl = FALSE, zoomSnap = 0.25)) %>%
    addMapPane("pane_param_selectedStations", zIndex = 250) %>% # higher index is on top
    addMapPane("pane_param_importedStations", zIndex = 245) %>%
    addMapPane("pane_param_polylines", zIndex = 230) %>%
    addMapPane("pane_param_facilitiesPointsSub", zIndex = 226) %>%
    addMapPane("pane_param_gageStations_selected", zIndex = 227) %>%
    addMapPane("pane_param_meteoStations_selected", zIndex = 227) %>%
    addMapPane("pane_param_HUC", zIndex = 220) %>%
    addMapPane("pane_param_unitPoly", zIndex = 210) %>%
    addTiles(options = tileOptions(noWrap = TRUE), group = "Street") %>%
    addProviderTiles("Esri.WorldImagery", options = providerTileOptions(noWrap = TRUE), group="Satellite") %>%
    addPolygons(data = rv$unitPoly, group = "NPS unit", color = "black", fillColor = "yellow", fillOpacity = 1, weight = 1, options = pathOptions(pane = "pane_param_unitPoly")) %>% # park unit outline
    addPolygons(data = rv[[rv$userSelect$sel_HUClevel]], group = paste0(rv$userSelect$sel_HUClevel, " boundaries"), color = "blue", fillColor = "lightblue", fillOpacity = 0.3, weight = 0.7, options = pathOptions(pane = "pane_param_HUC")) %>% # HUC polygons
    addScaleBar() %>%
    addControl(rv$parkID, position = "topleft", className="map-unitcode") # add 4-letter UNIT code on map

  

cat("DONE WITH STANDARD MAP")

  # Done with the standard mapping. Now to conditional layers.

  show_layers <- data.frame(layer = c(paste0(rv$userSelect$sel_HUClevel, " boundaries"), "Imported monitoring sites", "Selected monitoring sites", "Imported stream lines", "Discharge facilities", "Selected gage stations", "Selected weather stations"), show = c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, TRUE)) # dataframe to track what layers to show
  cat("line1796")
  if(input$sel_SummarizeBy == "by_char") { # if multiple sites per characteristic, then available sites are only those that actually have the selected characteristic
    shiny::req(!is.null(input$sel_ShowChar))
    avail_sites_data <- rv$sitesPointsSub[rv$sitesPointsSub$MonitoringLocationIdentifier %in% unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowChar]),]
  } else {
    avail_sites_data <- rv$sitesPointsSub[rv$sitesPointsSub$MonitoringLocationIdentifier %in% unique(rv_param_temp$subDat$MonitoringLocationIdentifier),]
  }
cat("line1803")
cat("RENDERING AVAILABLE SITES IN FULL MAP\n")
  param_map %<>%
    addCircleMarkers(data = avail_sites_data, group = "Imported monitoring sites", layerId = ~MonitoringLocationIdentifier, label = ~SITELAB, radius = 12, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 0.8, stroke = TRUE, color = ~rv_param_temp$palOrg(OrganizationFormalName), opacity = 0.7, options = pathOptions(pane = "pane_param_importedStations")) # WQ stations for which data (for selected parameter) are available  
cat("line1988")
# })
  

  # If UP-DOWN selection, show stream lines
  if(rv$userSelect$sel_SelectMethod=="methodDist") {
    show_layers$show[show_layers$layer == "Imported stream lines"] <- TRUE
  cat("line2693")
    if(!is.null(rv$selectedDownstreamLines)) { # add selected downstreams in brown
      param_map %<>%
        addPolylines(data = rv$selectedDownstreamLines, color = "brown", weight = 2, opacity = 1, options = pathOptions(pane = "pane_param_polylines"), group = "Imported stream lines")
    }
  cat("line2698")
        if(!is.null(rv$selectedUpstreamLines)) { # add selected upstreams in blue
      param_map %<>%
        addPolylines(data = rv$selectedUpstreamLines, color = "blue", weight = 2, opacity = 1, options = pathOptions(pane = "pane_param_polylines"), group = "Imported stream lines")
    }

  } else {
    show_layers$show[show_layers$layer == "Imported stream lines"] <- FALSE
  }

  cat("line2707")
  
  # Show selected stream gages
  if(all(!is.null(rv$gageStations), !is.null(rv$selectedGages), rv$selectedGages$GageID %in% rv$gageStations$GageID)) {
    show_layers$show[show_layers$layer == "Selected gage stations"] <- TRUE
    
    param_map %<>%
      addAwesomeMarkers(icon = iconGagesSelected, data = rv$selectedGages, group = "Selected gage stations", label = ~GAGELAB, popup = ~GAGEPOP, options = pathOptions(pane = "pane_param_gageStations_selected")) # selected stream gage stations
  } else {
      show_layers$show[show_layers$layer == "Selected gage stations"] <- FALSE
    }
  
 
   # If weather stations have been found
  if(all(!is.null(rv$meteoStations), !is.null(rv$selectedMeteo), rv$selectedMeteo$MeteoID %in% rv$meteoStations$MeteoID)) {
    show_layers$show[show_layers$layer == "Selected weather stations"] <- TRUE
    
    param_map %<>%
      addAwesomeMarkers(icon = iconMeteoSelected, data = rv$selectedMeteo, group = "Selected weather stations", label = ~METEOLAB, popup = ~METEOPOP, options = pathOptions(pane = "pane_param_meteoStations_selected")) # selected weather stations
    } else {
      show_layers$show[show_layers$layer == "Selected weather stations"] <- FALSE
      }
 

  # If Discharge facilities have been found <<<<<<< DECIDE WHAT TO DO HERE
  if(!is.null(rv$facilitiesPointsSub)) {
    param_map %<>%
      addAwesomeMarkers(icon = iconCWA, data = rv$facilitiesPointsSub, group = "Discharge facilities", label = ~FACLAB, popup = ~FACPOP, options = pathOptions(pane = "pane_param_facilitiesPointsSub"))
    show_layers$show[show_layers$layer == "Discharge facilities"] <- TRUE
  } else {
    show_layers$show[show_layers$layer == "Discharge facilities"] <- FALSE
  }
  cat("line2745")
  #

  cat("line3098")
  
# Highlight selected stations
cat("START OF HIGHLIGHT SELECTED")
# if(any(is.null(input$sel_ParamMapShow), input$sel_ParamMapShow == "show")) {
if(sel_param_map_show == "show") {
    # if(all(any(is.null(input$sel_ParamMapShow), input$sel_ParamMapShow == "show"), any(isolate(is.null(rv_param_temp$update_from_sidebar)), isolate(rv_param_temp$update_from_sidebar != FALSE)))) # may be TRUE or NULL
# if(all(any(is.null(input$sel_ParamMapShow), input$sel_ParamMapShow == "show"), isolate(is.null(rv_param_temp$update_from_sidebar))))
      # {
            cat("START UPDATE ON FIRST GO AROUND ONLY")
    # isolate({
    # if(is.null(rv_param_temp$param_map_highlight)) { # White outline on sites selected from left panel

    # Need to do this on first go-around because don't yet have a param_map to update with proxy.
      sel_sites <- switch((input$sel_SummarizeBy == "by_char") + 1, input$sel_ShowOneStation, input$sel_ShowStations)


          # if(all(any(is.null(rv_param_temp$update_from_sidebar), rv_param_temp$update_from_sidebar==TRUE), !identical(rv_param_temp$param_map_highlight, sel_sites))) {
          # if(!identical(rv_param_temp$param_map_highlight, sel_sites)) {
                  # isolate({ # THIS isolate(local()) is the key to keeping the dashboard from blitzing out
        # local(
        rv_param_temp$param_map_highlight <- sel_sites
        
        # )
      # })
      cat("START CHANGING MAP")
      if(length(sel_sites) > 0) {
        # Add white border on selected stations
        param_map %<>%
      addCircleMarkers(data = rv$sitesPointsSub[rv$sitesPointsSub$MonitoringLocationIdentifier %in% sel_sites,], group = "Selected monitoring sites", layerId = ~MonitoringLocationIdentifier, label = ~SITELAB, radius = 15, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 1, stroke = TRUE, weight = 4, color = "white", opacity = 1, options = pathOptions(pane = "pane_param_selectedStations"))
      }

    # } # selected WQ stations are shown as larger, white-outlined points
    # })

      # rv_param_temp$update_from_sidebar <- TRUE # so it's no longer NULL and can now be activated
    cat("RENDERING SELECTED SITES IN FULL MAP\n")
          # }
}
  
cat("line3881")
  # If summarizing by characteristic, then additional summary options are available
  if(input$sel_SummarizeBy == "by_char" & !is.null(input$sel_SurvYr)){

    # summarize stations by a single characteristic, user can choose from several summary functions...
    ## MEDIAN
    if(sel_param_map_show == "median") {
      shiny::validate(need(sum(!is.na(rv_param_temp$plotDat$ResultMeasureValue)) > 0, message = "No monitoring results available for these data"))

      temp_median <- rv_param_temp$plotDat %>%
        dplyr::group_by(MonitoringLocationIdentifier, Yr) %>%
        dplyr::filter(!is.na(ResultMeasureValue)) %>%
        dplyr::summarise(
          N = n(),
          median_val = round(median(ResultMeasureValue), 2))
      
      palNumeric <- colorNumeric(
        palette = "Reds",
        domain = temp_median$median_val) # Do this before filtering to site, because want same color range across all sites
            
      median_sf <- rv$sitesPointsSub %>%
        dplyr::filter(MonitoringLocationIdentifier %in% temp_median$MonitoringLocationIdentifier) %>%
        dplyr::select(MonitoringLocationIdentifier, SITELAB) %>%
        dplyr::left_join(temp_median, by = "MonitoringLocationIdentifier") %>%
        filter(Yr == as.numeric(input$sel_SurvYr)) %>%
        dplyr::mutate(SITEPOP = paste0("Site: ", MonitoringLocationIdentifier, "<br>Year: ", Yr, "<br># of Samples: ", N, "<br><font size ='+.5'><b>Median Value: ", median_val, "</b></font>")) # Median value show as larger bold font
      
      param_map %<>%
        addControl(tags$div(tag.map.title, HTML(input$sel_ShowChar, " in Year ", input$sel_SurvYr)), position = "topleft", className="map-title") %>%
        addCircleMarkers(data = median_sf, label = ~SITELAB, popup = ~SITEPOP, radius = 12, fillColor = ~palNumeric(median_val), fillOpacity = 1, color = ~palNumeric(median_val), stroke = TRUE, opacity = 1, options = pathOptions(pane = "pane_param_selectedStations")) %>%
        addLegend(pal = palNumeric, values = temp_median$median_val, position = "topleft", title = input$sel_ShowChar) %>%
        hideGroup("Imported monitoring sites") %>%
        hideGroup("Selected monitoring sites") %>%
        hideGroup("Selected gage stations") %>%
        hideGroup("Selected weather stations")
    }

    ## THRESH
    if(sel_param_map_show == "thresh") {
      shiny::validate(need(sum(!is.na(rv_param_temp$plotDat$ThreshCateg)) > 0, message = "No threshold limits defined for these data."))

      thresh_mat <- rv_param_temp$plotDat %>%
        dplyr::filter(!is.na(ThreshCateg)) # NA's occur when is.na(ResultMeasureValue_replaced)--these should not be included, they are just missing values

      thresh_list <- switch(rv_param_temp$sel_show_thresholds,
                          showthresh_file = rv_param_temp$threshList,
                          showthresh_custom = rv_param_temp$threshCustom,
                          showthresh_none = NULL)

      thresh_mat$ThreshCateg <- factor(thresh_mat$ThreshCateg, levels = thresh_list[[1]]$cut_categ) # ensures that a column is created even if a factor level is not in the data
      thresh_mat %<>%
        filter(Yr == as.numeric(input$sel_SurvYr)) %>%
        group_by(MonitoringLocationIdentifier, Yr) %>%
        dplyr::count(ThreshCateg) %>%
        tidyr::spread(key = ThreshCateg, value = n, drop = FALSE, fill = 0) %>%
        dplyr::left_join(
          cbind(rv$sitesPointsSub, sf::st_coordinates(rv$sitesPointsSub)) %>%
            dplyr::select(MonitoringLocationIdentifier, SITELAB, X, Y), by = "MonitoringLocationIdentifier") %>%
        ungroup()
      
      param_map %<>%
        addControl(tags$div(tag.map.title, HTML(input$sel_ShowChar, " in Year ", input$sel_SurvYr)), position = "topleft", className="map-title") %>%
        addMinicharts(
          lng = thresh_mat$X,
          lat = thresh_mat$Y,
          time = thresh_mat$Yr,
          type = "pie",
          transitionTime = 0,
          layerId = thresh_mat$SITELAB,
          height = 30+(10*map_point_size),
          width = 30+(10*map_point_size),
          showLabels = TRUE,
          legend = TRUE,
          chartdata = as.matrix(subset(thresh_mat, select = thresh_list[[1]]$cut_categ)),
          colorPalette = thresh_list[[1]]$cut_colors,
          opacity = 1) %>%
        hideGroup("Imported monitoring sites")%>%
        hideGroup("Selected monitoring sites") %>%
        hideGroup("Selected gage stations") %>%
        hideGroup("Selected weather stations")
    }
    
    ## PERCENTILE
    if(sel_param_map_show == "perc") {
      shiny::validate(need(sum(!is.na(rv_param_temp$plotDat$PercCateg)) > 0, message = "No percentile limits set for these data"))
  
      perc_mat <- rv_param_temp$plotDat %>%
        dplyr::filter(!is.na(PercCateg)) %>% # NA's occur when is.na(ResultMeasureValue_replaced)--these should not be included, they are just missing values
        filter(Yr == as.numeric(input$sel_SurvYr)) %>%
        group_by(MonitoringLocationIdentifier, Yr) %>%
        dplyr::count(PercCateg) %>%
        tidyr::spread(key = PercCateg, value = n, drop = FALSE, fill = 0) %>%
        dplyr::left_join(
          cbind(rv$sitesPointsSub, sf::st_coordinates(rv$sitesPointsSub)) %>%
            dplyr::select(MonitoringLocationIdentifier, SITELAB, X, Y), by = "MonitoringLocationIdentifier") %>%
        ungroup()
      
      param_map %<>% addControl(tags$div(tag.map.title, HTML(input$sel_ShowChar, " in Year ", input$sel_SurvYr)), position = "topleft", className="map-title") %>%
        addMinicharts(
          lng = perc_mat$X,
          lat = perc_mat$Y,
          time = perc_mat$Yr,
          type = "pie",
          transitionTime = 0,
          height = 30+(10*map_point_size),
          width = 30+(10*map_point_size),
          showLabels = TRUE,
          legend = TRUE,
          layerId = perc_mat$SITELAB,
          chartdata = as.matrix(perc_mat[, c("below", "between", "above")]),
          colorPalette = c("lightgray", "#56B4E9", "orange"),
          opacity = 1) %>%
        hideGroup("Imported monitoring sites") %>%
        hideGroup("Selected monitoring sites") %>%
        hideGroup("Selected gage stations") %>%
        hideGroup("Selected weather stations")
    }
  }

# FINISH OFF for all map types
  param_map %<>%
    hideGroup("Selected gage stations") %>%
    hideGroup("Selected weather stations") %>%
    hideGroup("Discharge facilities") %>%
    addLayersControl(
      baseGroups = c("Street", "Satellite"),
      overlayGroups = show_layers$layer[show_layers$show == TRUE],
      options = layersControlOptions(collapsed = TRUE)) %>% # set map view at current settings or, if initial map viewing, set to initial defaults. Irritating that it blinks every time, but it seems this can't be easily addressed with leaflet (html-based) outputs
    setView(lng = switch(any(is.null(isolate(input$param_map_center$lng)), isolate(input$param_map_center$lng) == 0, isolate(input$param_map_center$lng) > st_bbox(rv[["HUC10"]])$xmax, isolate(input$param_map_center$lng) < st_bbox(rv[["HUC10"]])$xmin)+1, isolate(input$param_map_center$lng), mean(c(st_bbox(rv$sitesPointsSub)$xmin, st_bbox(rv$sitesPointsSub)$xmax))), lat = switch(any(is.null(isolate(input$param_map_center$lat)), isolate(input$param_map_center$lat) == 0, isolate(input$param_map_center$lat) > st_bbox(rv[["HUC10"]])$ymax, isolate(input$param_map_center$lat) < st_bbox(rv[["HUC10"]])$ymin)+1, isolate(input$param_map_center$lat), mean(c(st_bbox(rv$sitesPointsSub)$ymin, st_bbox(rv$sitesPointsSub)$ymax))), zoom = input$sel_ParamMapZoom)
  }) # end of renderLeaflet

tags$style("#param_map {height: calc(100vh - 180px) !important;}") # expand map to fill screen
```

```{r ts_cards}
output$out_ts_plots <- renderPlotly({ # separate validation statements so they are checked in sequence

  FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = FALSE)
cat("line5039")

  shiny::validate(
    need(!is.null(rv_param_temp$showCharSets) & !is.null(rv_param_temp$showStations), message = "From the left sidebar, please select characteristic(s), characteristic set(s) and monitoring site(s) to plot, then click the green 'REFRESH PLOT DATA' button"))

  shiny::validate(
    need(length(unique(na.omit(rv_param_temp$subDat$ResultSampleFractionText[rv_param_temp$subDat$CharacteristicSet %in% rv_param_temp$showCharSets]))) < 2 | rv_param_temp$sel_summarize_by == "by_station", message = "Cannot combine characteristic sets with different sample fractions (e.g., dissolved vs. total)"))

    if(all(!is.null(input$sel_CombineSites), !is.null(rv_param_temp$showStations))) {
      shiny::validate(need(length(rv_param_temp$showStations) < 6 | input$sel_CombineSites == FALSE, message = "The maximum number of monitoring sites to display in a single plot is FIVE. From the left sidebar, please either UNSELECT 'Combine sites in one plot' or reduce the number of sites to display."))
    }

cat("line2220")
  # shiny::req(!is.null(rv_param_temp$plotDat), !is.null(rv_param_temp$quantDat))
  cat("line2222")
  if(all(!is.null(rv_param_temp$plotDat), !is.null(rv_param_temp$quantDat))) {
    
    rv_param_temp$finalPlot <- FuncPlotPage(plot_type = input$sel_PlotType, plot_dat = rv_param_temp$plotDat, quant_dat = rv_param_temp$quantDat, time_unit = "ActivityStartDate", free_y = switch(is.null(input$sel_FreeY)+1, input$sel_FreeY, FALSE), sel_combine_sites = switch(is.null(input$sel_CombineSites)+1, input$sel_CombineSites, FALSE), trans_log_y = input$sel_log_y)
    cat("line2224")
  }
    
    shiny::req(!is.null(rv_param_temp$finalPlot$plotly_page))
    cat("line2226")
  
    rv_param_temp$finalPlot$plotly_page
    })
unlink("Rplots.pdf")
tags$style("#out_ts_plots{height: calc(100vh - 350px) !important;overflow-y:scroll}")

output$out_season_plots <- renderPlotly({
  
    FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = FALSE)
  
  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$subDat),  !is.null(rv_param_temp$subDatTypes))

  shiny::validate(
    need(!is.null(rv_param_temp$showCharSets) & !is.null(rv_param_temp$showStations), message = "From the left sidebar, please select characteristic set(s) and monitoring site(s) to plot, then click the green 'REFRESH PLOT DATA' button"))

  shiny::validate(
    need(length(unique(na.omit(rv_param_temp$subDat$ResultSampleFractionText[rv_param_temp$subDat$CharacteristicSet %in% input$sel_ShowCharSets]))) < 2, message = "Cannot combine characteristic sets with different sample fractions (e.g., dissolved vs. total)"))

  if(!is.null(input$sel_CombineSites) & !is.null(rv_param_temp$showStations)) {
    shiny::validate(need(length(rv_param_temp$showStations) < 6 | input$sel_CombineSites == FALSE, message = "The maximum number of monitoring sites to display in a single plot is FIVE. From the left sidebar, please either UNSELECT 'Combine sites in one plot' or reduce the number of sites to display."))
  }
    
  shiny::req(!is.null(rv_param_temp$plotDat), !is.null(rv_param_temp$quantDat))

    rv_param_temp$seasonalPlot <- FuncPlotPage(plot_type = input$sel_PlotType, plot_dat = rv_param_temp$plotDat, quant_dat = rv_param_temp$quantDat, time_unit = switch(is.null(input$sel_SeasonalTimeUnit)+1, input$sel_SeasonalTimeUnit, "Wk"), free_y = switch(is.null(input$sel_FreeY)+1, input$sel_FreeY, FALSE), sel_combine_sites = switch(is.null(input$sel_CombineSites)+1, input$sel_CombineSites, FALSE), trans_log_y = input$sel_log_y)

  shiny::req(!is.null(rv_param_temp$seasonalPlot$plotly_page))
  rv_param_temp$seasonalPlot$plotly_page
})
unlink("Rplots.pdf")
tags$style("#out_season_plots{height: calc(100vh - 350px) !important;overflow-y:scroll}")

output$out_thresh_plots <- renderPlotly({

  # FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = TRUE)

  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$subDat),  !is.null(rv_param_temp$subDatTypes), !is.null(rv_param_temp$plotDat))
shiny::req(!is.null(rv_param_temp$sel_summarize_by))
shiny::validate(need(rv_param_temp$sel_summarize_by == "by_char", message = "Currently, this display is available only when summarizing by characteristic (not by station)"))

shiny::req(!is.null(rv_param_temp$sel_show_thresholds))
shiny::validate(need(!is.null(rv_param_temp$sel_show_thresholds != "showthresh_none"), "In the left sidebar, choose to define custom threshold limits or import limits from a file, then click the green 'REFRESH PLOT DATA' button"))

thresh_list <- switch(rv_param_temp$sel_show_thresholds,
                          showthresh_file = rv_param_temp$threshList,
                          showthresh_custom = rv_param_temp$threshCustom)

shiny::validate(need(!is.null(thresh_list), message = "No threshold limits defined"))

thresh_ID = paste0(unique(na.omit(rv_param_temp$plotDat$CharacteristicName)), " (", unique(na.omit(rv_param_temp$plotDat$ResultMeasure.MeasureUnitCode)), ")")
shiny::validate(need(!is.null(thresh_list[[thresh_ID]]), message = paste0("No threshold limits defined for ", thresh_ID)))

  threshPieDat <- FuncPieDat(limit_type = "ThreshCateg")
  
  shiny::validate(
    need(!is.null(threshPieDat), message = "No threshold limits defined"))
  
  thresh_named_colors <- thresh_list[[thresh_ID]]$cut_colors
  thresh_named_levels <- thresh_list[[thresh_ID]]$cut_categ
  
  thresh_plot_title <- paste0("Threshold levels by ", switch((rv_param_temp$sel_summarize_by == "by_char")+1, "water quality characteristic", "monitoring site"), " (rows) and year (cols) for ", switch((rv_param_temp$sel_summarize_by == "by_char")+1, unique(rv_param_temp$plotDat$MonitoringLocationIdentifier), unique(rv_param_temp$plotDat$CharacteristicName)))
  
  thresh_pie <- FuncPlotlyPieMatrix(dat = threshPieDat %>% dplyr::filter(!is.na(CategVar)), discrete_cols = thresh_named_colors, discrete_levels = thresh_named_levels, plot_title = thresh_plot_title)
  })
tags$style("#out_thresh_plots{height: calc(100vh - 350px) !important;overflow-x:scroll;overflow-y:scroll}")

output$out_perc_plots <- renderPlotly({
  # FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = TRUE)
  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$subDat),  !is.null(rv_param_temp$subDatTypes), !is.null(rv_param_temp$plotDat))
          
  percPieDat <- FuncPieDat(limit_type = "PercCateg")
  
  shiny::validate(
    need(!is.null(percPieDat), message = "No percentile data calculated"))
  shiny::req(!is.null(rv_param_temp$sel_summarize_by), !is.null(input$sel_AddQuantile))

  perc_named_colors <- c("lightgray", "#56B4E9", "orange")

  perc_named_levels <- c("below", "between", "above")

  plot_title <- paste0("Percentile levels by ", switch((rv_param_temp$sel_summarize_by == "by_char")+1, "WQ characteristic", "monitoring site"), " (rows) and year (cols) for ", switch((rv_param_temp$sel_summarize_by == "by_char")+1, unique(rv_param_temp$plotDat$MonitoringLocationIdentifier), unique(rv_param_temp$plotDat$CharacteristicName)), " calculated", switch((input$sel_QuantileGroupBy=="quant_all")+1, " separately by site", " for all sites combined"))

  perc_pie <- FuncPlotlyPieMatrix(dat = percPieDat %>% dplyr::filter(!is.na(CategVar)), discrete_cols = perc_named_colors, discrete_levels = perc_named_levels, plot_title = plot_title)
  })
tags$style("#out_perc_plots{height: calc(100vh - 350px) !important;overflow-x:scroll;overflow-y:scroll}")
```

HOME
====================================== 
Spacer Column {data-width=5}
-------------------------------------

Column {data-width=750}
-------------------------------------

###
```{r}
htmltools::img(src="Images/secchi_transparent.png", width = "7%", style="position:absolute; top:20px; right:25px;")
```
<br>

#### <font size="2">**Quick-Start Instructions**</font>

* <font size="1">To import water quality data from Water Quality Portal (or load an existing .RDS file), follow the red-font instructions on the 'Get WQP Data' page.</font>

* <font size="1">Then (optionally) proceed to the 'Filter WQP Data' page to examine sample sizes and filter a subset of data to summarize on the 'Explore Filtered Data' page. Alternatively, use the default filter criteria.</font>

* <font size="1">The 'Explore Data' page presents time series plots, time lapse maps, and summary tables of the filtered WQP data.</font>

<br>

#### <font size="2">**About This Dashboard**</font>

<font size="1">This dashboard is an interactive tool for you to explore water quality trends in and around national park units. Use it to:</font>

* <font size="1">See what water monitoring sites, weather stations, and EPA-regulated facilities occur in and near our parks</font>

* <font size="1">Examine scatterplots, boxplots, and line graphs of water quality and precipitation data</font>

* <font size="1">Identify unusually high or low water quality measurements and examine the underlying data records</font>

* <font size="1">Use a map time slider to see how water quality patterns change over space and time</font>

<br>

#### <font size="2">**About The Data**</font>

<font size="1">Click on the links below to learn more about each data source and the data used in this dashboard:</font>

* <font size="1">[Administrative Boundaries of National Park System Units](https://irma.nps.gov/DataStore/Reference/Profile/2224545?lnv=True) (NPS) </font>

* <font size="1">[National Watershed Boundary Dataset](https://www.usgs.gov/national-hydrography/watershed-boundary-dataset) (USGS), for watershed (HUC10) and subwatershed (HUC12) boundaries</font>

* <font size="1">[Water Quality Portal](https://www.waterqualitydata.us/) (a cooperative service sponsored by the USGS, EPA, and NWQMC), for water quality data</font> 

* <font size="1">[National Climatic Data Center](https://www.ncei.noaa.gov/cdo-web/) (NOAA), for precipitation data</font>

* <font size="1">[Enforcement and Compliance History Online](https://echo.epa.gov/) (EPA), for compliance information for facilities regulated under the Clean Water Act</font>

Spacer Column {data-width=5}
-------------------------------------

Data Sources {data-width=200}
-------------------------------------
```{r images}
htmltools::img(src="Images/US-NationalParkService-Logo.svg", width = "50%",  style="display:block; margin:auto; padding:15px")
  
htmltools::img(src="Images/USGS_logo.png",width = "75%",  style="display:block; margin:auto; padding:15px")

htmltools::img(src="Images/waterquality_logo.jpg", width = "100%", style="display:block; margin:auto; padding:15px")

htmltools::img(src="Images/ncei_icon_550px.jpg", width = "81%", style="display:block; margin:auto; padding:15px")

htmltools::img(src="Images/epa-seal-large.png", width = "52%", style="display:block; margin:auto; padding:15px") # height = "25%", 
```

Spacer Column {data-width=5}
-------------------------------------

Get WQP Data
====================================== 
Inputs {.sidebar data-width=300}
-------------------------------------
```{r main_data_sidebar}  

useShinyjs(rmd = TRUE)

FuncAboutButton(nam = "button_aboutGetData")
observeEvent(eventExpr = input$button_aboutGetData, {
  browseURL(here::here("About_files", "aboutGetData.html"))})

br()

br()

# UI panel to import or load data----
wellPanel(
  id = "new_data_P0",
  p(strong("Choose data source")),
  
  br(),
  
  radioButtons("sel_GetData",
               label = NULL,
               choices = c("Load data file (.RDS) from computer"  = "existing_data",
                           "Download data from web services" = "new_data")),
  
  
  actionButton("button_beginSearch", "BEGIN DATA SEARCH", width = "100%", style="color:black; background-color: lightgreen; display:inline-block; border:1px; margin:5px")
) # end import-load-data panel


# UI panel to show WQP stations ----
shinyjs::hidden( # initially hide this well panel, show only if user wants to import data from WQP
  wellPanel(
    id = "new_data_P1",
    p(strong("1. Show monitoring sites for selected park unit and date range")),
    
    selectInput("sel_UnitCode", label = h6("Enter a park name or 4-digit park code (e.g., BITH): "), choices = c("Choose a park" = "", unique_parks_df$unit_name_combined), selectize = TRUE),
    
    numericInput("sel_ActiveWithinYrs",
                 label = h6("Limit to sites that have been sampled within the past [ENTER AN INTEGER] years: "),
                 value = 8,
                 min = 1),
    
    actionButton("button_showStations", "Show Monitoring Sites", width = "100%", style="color:black; background-color: lightgreen; display:inline-block; border:1px; margin:5px")
    ) # end show-stations panel
) # end hide for show-stations panel

conditionalPanel(
  condition = "rv_param_temp.loadMap == true", # show map zoom slider only after map data have been uploaded,
  renderUI({
    shiny::req(!is.null(rv[["HUC10"]]))
    map_zoom <- min(RgoogleMaps::MaxZoom(lonrange = c(st_bbox(rv[["HUC10"]])$xmin, st_bbox(rv[["HUC10"]])$xmax), latrange = c(st_bbox(rv[["HUC10"]])$ymin, st_bbox(rv[["HUC10"]])$ymax)))
    sliderInput("sel_MapZoom", label = h6("Set map zoom:"), min = max(1, map_zoom - 6), max = 15, value = map_zoom, step = 0.5, ticks = FALSE, dragRange = FALSE, width = "95%")
    })
)
  
# UI panel to select subset of WQP stations ----
shinyjs::hidden( # initially hide this well panel
  wellPanel(
    id = "new_data_P2",
    p(strong("2. Filter sites to download")),
    
    renderUI({
    shiny::req(!is.null(rv))
    huc_vec <- c("HUC10" = "HUC10 (watershed)", "HUC12" = "HUC12 (subwatershed)")
    huc_choice_names <- huc_vec[intersect(c("HUC10", "HUC12"), names(isolate(reactiveValuesToList(rv)) %>% purrr::discard(is.null)))]
    
    radioButtons("sel_HUClevel", label = h6("Display HUC level: "),
                 choiceNames = unname(huc_choice_names),
                 choiceValues = names(huc_choice_names),
                 selected = names(huc_choice_names)[1])
    }),
    
    radioButtons("sel_SelectMethod", label = h6("Select WQP monitoring sites based on: "),
                 choiceNames = c("HUCs (click on map to select)", "Distance from origin site (enter query filters below)"),
                 choiceValues = c("methodHuc", "methodDist"),
                 selected = "methodHuc"),
    
    renderUI({ # conditional panel if user selects from origin station
      shiny::req(!is.null(input$sel_SelectMethod))
      shiny::req(input$sel_SelectMethod == "methodDist")
      conditionalPanel(
        condition = "input.sel_SelectMethod == 'methodDist'",
        textInput("sel_OriginStationID",
                  label = "Enter an origin WQP monitoring site ID (e.g., USGS-08041745)",
                  value = ""),
        numericInput("sel_DistKmUpstream",
                     label = "How many km upstream of origin?",
                     value = 0,
                     min = 0),
        checkboxInput("sel_IncludeTribs",
                      label = "Include upstream tributaries",
                      value = FALSE),
        numericInput("sel_DistKmDownstream",
                     label = "How many km downstream of origin?",
                     value = 0,
                     min = 0),
        checkboxInput("sel_IncludeDiversions",
                      label = "Include downstream diversions",
                      value = FALSE)
      )
      }),
    
    renderUI({
      shiny::req(!is.null(rv$sitesPointsSub))
      checkboxGroupInput("sel_Organization",
                         label = h6("Import WQP data only from these organizations: "),
                         choices = sort(unique(rv$sitesPointsSub$OrganizationFormalName)),
                         selected = unique(rv$sitesPointsSub$OrganizationFormalName)
                         # selected = sort(unique(rv$sitesPointsSub$OrganizationFormalName[rv$sitesPointsSub$Selected==TRUE]))
                         )
      }),
    
        renderUI({
      shiny::req(!is.null(rv$sitesPointsSub))
      checkboxGroupInput("sel_SiteType",
             label = h6("Type(s) of water body to map: "),
             choices = sort(unique(rv$sitesPointsSub$MonitoringLocationTypeName)),
             selected = unique(rv$sitesPointsSub$MonitoringLocationTypeName))
    }),
    
    actionButton("button_highlightStations", "Highlight Selected Sites", width = "100%", style="color:black; background-color: lightgreen; display:inline-block; border:1px; margin:5px")
    ) # end subset-stations panel
  ) # end hide for subset-stations panel

# UI panel to select subset of Meteo stations ----
shinyjs::hidden( # initially hide this well panel
  wellPanel(
    id = "new_data_P3",
    p(strong("3. Filter stream gage and weather station data to download")),
    p("Data will download only for selected gage and weather stations. When selected, these stations will show as orange-colored on the map."),
    
    renderUI({
      shiny::req(!is.null(rv$gageStations))
      checkboxGroupInput("sel_Gages",
                         label = h6("Import data only from these USGS gage stations: "),
                         choices = sort(unique(rv$gageStations$GageName)))
      }),
    
    renderUI({
      shiny::req(!is.null(rv$meteoStations))
      checkboxGroupInput("sel_Meteo",
                         label = h6("Import data only from these weather stations: "),
                         choices = sort(unique(rv$meteoStations$MeteoName)))
      })
    ) # end subset-Meteo panel
  ) # end hide for subset-Meteo panel

# UI panel for finer data filter and to import the data ----
shinyjs::hidden( # initially hide this well panel
  wellPanel(
    id = "new_data_P4",
    p(strong("4. Filter characteristic groups to download")),

    checkboxGroupInput("sel_CharType",
                       label = h6("Import WQP data only from these characteristic groups: "),
                       choices = c("Biological",
                                   "Inorganics, Major, Metals",
                                   "Inorganics, Major, Non-metals",
                                   "Microbiological",
                                   "Nutrient",
                                   "Organics, Other",
                                   "Organics, PCBs",
                                   "Organics, Pesticide",
                                   "Physical",
                                   "Sediment",
                                   "Toxicity"),
                       selected = c("Inorganics, Major, Metals", "Inorganics, Major, Non-metals", "Microbiological", "Nutrient", "Physical")),
  
    actionButton("button_downloadData", "DOWNLOAD SELECTED DATA", width = "100%", style="color:black; background-color: lightgreen; display:inline-block; border:1px; margin:5px"),
    
    br(),
    renderUI({
  shiny::req(!is.null(rv))
  
  shiny::req(rv_param_temp$newImport == TRUE)
             
  download_button(
  outputId = "download_RDS", 
  label = "Download Formatted RDS File")
})
    
    ) # end filter-import panel
  ) # end hide for filter-import panel

# Download RDS to user location ----


output$download_RDS <- downloadHandler(
  shiny::req(!is.null(rv)),
  filename = function() {
    paste0("WQdash_", rv$parkID, "_", paste0(gsub(pattern = "-", replacement = "", x = Sys.Date()), ".RDS"))
    },
    content = function(file) {
      saveRDS(isolate(reactiveValuesToList(rv)), file)
    }
  )

```

Data for Import {.tabset .tabset-fade}
-------------------------------------
<center>*NOTE:  Data collected by NPS Inventory & Monitoring are listed as 'National Park Service Water Resources Division'*</center>

<br>

### Map
```{r initial_map}

output$map <- renderLeaflet({
  shiny::req(!is.null(rv_param_temp$loadMap))
  
  shiny::validate(
      need(rv_param_temp$loadMap == TRUE, message = "No data to show. From the left sidebar, please choose to load a data file or download data from web services and then click the green 'BEGIN DATA SEARCH' button"))
  
  shiny::req(!is.null(input$sel_GetData))
  if(input$sel_GetData == "new_data"){
      rv$userSelect <- list(sel_SelectMethod = input$sel_SelectMethod, sel_HUClevel = input$sel_HUClevel, sel_Organization = input$sel_Organization, sel_SiteType = input$sel_SiteType)} # make sure the map will show even if WQP data have not yet been imported
  
  shiny::req(!is.null(rv$parkID))
  
  if(any(is.null(rv$userSelect$sel_SelectMethod), is.null(rv$userSelect$sel_HUClevel), is.null(rv$userSelect$sel_Organization), is.null(rv$userSelect$sel_SiteType), is.null(rv$unitPoly), is.null(rv$HUC10), is.null(rv$sitesPointsSub), rv$parkID=="", !rv$userSelect$sel_Organization %in% rv$sitesPointsSub$OrganizationFormalName)) {
      map <- leaflet()
      } else {
  
        map <- FuncBaseMap(maptype = "initial") # Base map, which will not react to user selections
        
        # Initial map controls
        map %<>%
          addLegend(title = "Data source for water quality monitoring data", pal = rv_param_temp$palOrg, values = sort(rv$userSelect$sel_Organization), group = "Map legend", position = "bottomleft") %>%
          addLayersControl(
            baseGroups = c("Street", "Satellite"),
            overlayGroups = na.omit(c("NPS unit", rv$userSelect$sel_HUClevel, "Available monitoring sites", ifelse(!is.null(rv$selectedStations), "Selected monitoring sites", NA), ifelse(!is.null(rv$facilitiesPointsSub), "Discharge facilities", NA), ifelse(!is.null(rv$gageStations), "Gage stations", NA), ifelse(!is.null(rv$meteoStations), "Weather stations", NA), "Map legend")),
            options = layersControlOptions(collapsed = TRUE)) %>%
          setView(lng = ifelse(any(is.null(isolate(input$map_center$lng)), isolate(input$map_center$lng) == 0), mean(c(st_bbox(rv[["HUC10"]])$xmin, st_bbox(rv[["HUC10"]])$xmax)), isolate(input$map_center$lng)), lat = ifelse(any(is.null(isolate(input$map_center$lat)), isolate(input$map_center$lat) == 0), mean(c(st_bbox(rv[["HUC10"]])$ymin, st_bbox(rv[["HUC10"]])$ymax)), isolate(input$map_center$lat)), zoom = input$sel_MapZoom)
      }
})

leafletOutput("map", width = "100%")
  
  # User selects HUCs by clicking (when new data imported) ----
observeEvent(input$map_shape_click, {
  shiny::req(rv$userSelect$sel_SelectMethod=="methodHuc", !is.null(rv), !is.null(rv$userSelect$sel_HUClevel), !is.null(input$sel_GetData))
  shiny::req(input$sel_GetData=="new_data")
    click <- input$map_shape_click

      if(click$id %in% rv$selectedHucs) { # check if the click is in a selected HUC
          rv$selectedHucs <- rv$selectedHucs[rv$selectedHucs != click$id] # then remove it from the list of selected HUCs
      leafletProxy("map") %>% addPolygons(data = rv[[rv$userSelect$sel_HUClevel]][rv[[rv$userSelect$sel_HUClevel]]$HUC==click$id,], group = rv$userSelect$sel_HUClevel, color = "blue", fillColor = "lightblue", fillOpacity = 0.4, weight = 0.5, layerId = ~HUC, options = pathOptions(pane = "pane_HUC")) # and change the polygon to unselected color
      } else { # if the click is in an unselected HUC
        rv$selectedHucs <- c(rv$selectedHucs, click$id) # append the ID of clicked HUC polygon
        leafletProxy("map") %>% addPolygons(data = rv[[rv$userSelect$sel_HUClevel]][rv[[rv$userSelect$sel_HUClevel]]$HUC==click$id,], group = rv$userSelect$sel_HUClevel, color = "blue", fillColor = "lightblue", fillOpacity = 0.7, opacity = 1, weight = 1.5, layerId = ~HUC, options = pathOptions(pane = "pane_HUC"))
      } # and change the polygon to selected color
  }, ignoreInit = TRUE) # end of observeEvent
```

### Selected Sites

```{r summarize_locations}
output$table_selected_orgs <- renderReactable({
  shiny::validate(
  need(!is.null(rv$dat), message = "No data available. Please first import or load water quality data.")) # can't call FuncOrderCheck from in here
  shiny::req(!is.null(rv$dat), !is.null(rv$sitesPointsSub), !is.null(rv$userSelect$sel_Organization))
          
  df_site <- rv$sitesPointsSub %>%
    dplyr::filter(MonitoringLocationIdentifier %in% rv$selectedStations$MonitoringLocationIdentifier & OrganizationFormalName %in% rv$userSelect$sel_Organization) %>%
    dplyr::mutate(Longitude = sf::st_coordinates(.)[,1],
                Latitude = sf::st_coordinates(.)[,2]) %>%
        sf::st_drop_geometry() %>%
    dplyr::select(OrganizationFormalName, MonitoringLocationIdentifier, MonitoringLocationName, MonitoringLocationTypeName, Latitude, Longitude) %>%
    dplyr::inner_join(rv$dat %>% dplyr::select(MonitoringLocationIdentifier, MeteoYr, CharacteristicName), by = "MonitoringLocationIdentifier") %>%
    dplyr::distinct() %>%
    dplyr::group_by(across(c(-MeteoYr, -CharacteristicName))) %>%
    dplyr::mutate(SiteStartYr = min(MeteoYr, na.rm = TRUE),
           SiteEndYr = max(MeteoYr, na.rm = TRUE),
           TotalSurveyYrs = dplyr::n_distinct(MeteoYr)) %>%
    dplyr::group_by(across(c(-MeteoYr))) %>%
    dplyr::mutate(PercParamYrs = n()/TotalSurveyYrs) %>%
    dplyr::filter(PercParamYrs >=.8) %>% # only keep parameters that were surveyed in at least 80% of years the site was surveyed
    dplyr::select(-MeteoYr, -PercParamYrs) %>%
    dplyr::distinct() %>%
    dplyr::arrange(CharacteristicName) %>%
    dplyr::group_by(across(c(-CharacteristicName))) %>%
    dplyr::summarise(across(everything(), ~paste(na.omit(.), collapse = " // "))) %>% # for each site, the characteristics surveyed in at least 80% of survey years
    dplyr::rename(TopCharacteristics = CharacteristicName) 
  
  df_site$TopCharacteristics[df_site$TotalSurveyYrs < 3] <- NA # if a site was surveyed less than 3 years, TopCharacteristics is NA (otherwise can get, e.g., huge list of characteristics surveyed only once because site surveyed only once)
  
    df_org <- rv$orgs %>% # alternatively, these column calculations can all be done within reactable()
      dplyr::filter(OrganizationFormalName %in% rv$userSelect$sel_Organization) %>%
      dplyr::select(-Selected) %>%
      left_join(df_site %>% ungroup() %>% dplyr::select(OrganizationFormalName, TotalSurveyYrs), by = "OrganizationFormalName") %>%
      dplyr::add_count(OrganizationFormalName) %>%
      dplyr::rename(NumSites = n) %>%
      dplyr::group_by(across(c(-TotalSurveyYrs))) %>%
      dplyr::mutate(MinYrsSiteSurveyed = min(TotalSurveyYrs, na.rm = TRUE),
                    MedianYrsSiteSurveyed = median(TotalSurveyYrs, na.rm = TRUE),
                    MaxYrsSiteSurveyed = max(TotalSurveyYrs, na.rm = TRUE)) %>%
      dplyr::select(-TotalSurveyYrs) %>%
      dplyr::distinct() %>%
      arrange(OrganizationFormalName)
    
  reactable(
    df_org,
    columns = list(
      OrganizationFormalName = colDef(name = "Organization"),
      Phone = colDef(minWidth = 170),
      NumSites = colDef(header = with_tooltip("# of Sites", "# of sites with data imported (based on user-defined import filters)"), width = 100, align = "center"),
      MinYrsSiteSurveyed = colDef(header = with_tooltip("Min", "Minimum # of years surveyed at a site"), width = 70, align = "center"),
      MedianYrsSiteSurveyed = colDef(header = with_tooltip("Median", "Median # of years surveyed at a site (50% of sites have been surveyed for longer)"), width = 75, align = "center"),
      MaxYrsSiteSurveyed = colDef(header = with_tooltip("Max", "Maximum # of years surveyed at a site"), width = 70, align = "center")
      ),
    columnGroups = list(
      colGroup(name = "# of Years Surveyed", columns = c("MinYrsSiteSurveyed", "MedianYrsSiteSurveyed", "MaxYrsSiteSurveyed"))
      ),
    details = function(index) {
      site_info <- df_site[df_site$OrganizationFormalName == df_org$OrganizationFormalName[index], ]
      htmltools::div(style = "padding: 50px",
                     reactable(site_info, 
                               columns = list(
                                 OrganizationFormalName = colDef(show = FALSE),
                                 MonitoringLocationIdentifier = colDef(name = "Site ID", minWidth = 110),
                                 MonitoringLocationName = colDef(name = "Site", minWidth = 140),
                                 MonitoringLocationTypeName = colDef(name = "Type", width = 110, align = "center"),
                                 Latitude = colDef(width = 85, align = "center"),
                                 Longitude = colDef(width = 85, align = "center"),
                                 SiteStartYr = colDef(name = "Start", width = 85, align = "center"),
                                 SiteEndYr = colDef(name = "End", width = 85, align = "center"),
                                 TotalSurveyYrs = colDef(
                                   header = with_tooltip("# of Years Site Surveyed", "Full (gray) bar length is maximum # of years among all (imported) sites surveyed by the organization, red bar length is # of years this site surveyed (a site may not be surveyed every year)"),
                                   width = 150,
                                   cell = function(value) {
                                     width <- paste0(value * 100 / max(site_info$TotalSurveyYrs), "%")
                                     bar_chart(value, width = width, fill = "#fc5185", background = "#e1e1e1")
                                     }),
                                 TopCharacteristics = colDef(
                                   header = with_tooltip("Top Characteristics Surveyed", "These characteristics were surveyed in at least 80% of site's survey years. If site has been surveyed less than 3 years, then characteristics are not listed"),
                                   minWidth = 250)
                               ),
                               columnGroups = list(
                                 colGroup(name = "Calendar Years Surveyed", columns = c("SiteStartYr", "SiteEndYr"))),
                               defaultSorted = list(TotalSurveyYrs = "desc"),
                               resizable = TRUE,
                               filterable = TRUE,
                               striped = FALSE,
                               highlight = TRUE,
                               showSortIcon = TRUE, 
                               compact = TRUE,
                               pagination = FALSE,
                               outlined = FALSE,
                               bordered = FALSE,
                               theme = reactableTheme(backgroundColor = "hsl(186, 56%, 94%)")
                               )
      )
    },
    resizable = TRUE, 
    filterable = FALSE,
    striped = FALSE,
    highlight = TRUE,
    showSortIcon = TRUE,
    compact = FALSE,
    bordered = TRUE,
    showPageSizeOptions = TRUE, 
    onClick = "select")
})

reactableOutput("table_selected_orgs")
# tags$style("#table_selected_orgs{height:100vh;overflow-x:scroll;overflow-y:scroll}")
```

Filter WQP Data
======================================

Inputs {.sidebar data-width=320}
-------------------------------------

```{r define_filter_sidebar}
FuncAboutButton(nam = "button_aboutFilterData")
observeEvent(eventExpr = input$button_aboutFilterData, {
  browseURL(here::here("About_files", "aboutFilterData.html"))})

br()

br()

strong("Data Filter Options")

br()

  wellPanel(
    id = "wp_filter_yr_season",
        
    renderUI({
      shiny::req(!is.null(rv$dat$MeteoYr))
      sliderInput("sel_YrRange",
                  label = h6("Select range of years to summarize:"),
                  min = min(rv$dat$MeteoYr, na.rm = TRUE),
                  max = max(rv$dat$MeteoYr, na.rm = TRUE), 
                  step = 1, 
                  sep="", 
                  value = c(min(rv$dat$MeteoYr, na.rm = TRUE), max(rv$dat$MeteoYr, na.rm = TRUE)),
                  dragRange = TRUE, 
                  width = "85%")
      }),
    
    renderUI({
      numericInput("sel_MinYrs",
                 h6("Only show site-characteristic combinations with number of survey years exceeding: "), 
                 min = 0, 
                 step = 1, 
                 value = 3)
    }),
        
    renderUI({
      shiny::req(!is.null(rv$dat))
      numericInput("sel_MinStations",
                    h6("Only show characteristics meeting filter requirements for this minimum number of sites:"),
                   min = 1,
                   step = 1,
                   value = 1)
                   
    }),
    
        renderUI({
      radioButtons("sel_DefineSeasons",
                 label = h6("Define seasons as: "),
                 choiceNames = c("Meteorological seasons (calendar year)", "USGS water year seasons (starts Oct. 1)", "Custom seasons (up to 4)"),
                 choiceValues = c("MeteoSeasons", "WaterSeasons", "CustomSeasons"),
                 selected = switch(is.null(input$sel_DefineSeasons)+1, input$sel_DefineSeasons, "MeteoSeasons"))
      }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons")
      
      sliderInput("sel_SeasonsStart", 
                  label = "Starting day for season level 1:", 
                  min = as.Date("2018-01-01"), # avoid leap year
                  max = as.Date("2018-12-31"), 
                  value = switch(is.null(input$sel_SeasonsStart)+1, input$sel_SeasonsStart, as.Date("2018-01-01")), 
                  timeFormat = "%b-%d")
      }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", !is.null(input$sel_SeasonsStart))
      textInput("sel_Season1Name",
                label = "LEVEL 1 name and start/end (inclusive):",
                value = "CustomSeason1",
                placeholder = "E.g., Wet Season")
    }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", !is.null(input$sel_SeasonsStart))
      sliderInput("sel_Season1Range",
                  label = NULL,
                  min = input$sel_SeasonsStart, 
                  max = input$sel_SeasonsStart + 364,
                  step = 1,
                  value = c(input$sel_SeasonsStart, input$sel_SeasonsStart + 364), 
                  timeFormat = "%b-%d")
    }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons), !is.null(input$sel_SeasonsStart), !is.null(input$sel_Season1Range[2]))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", input$sel_Season1Range[2] < (input$sel_SeasonsStart + 364))
      br()
      textInput("sel_Season2Name",
                label = "LEVEL 2 name and start/end (inclusive):",
                placeholder = "E.g., Wet Season")
    }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons), !is.null(input$sel_SeasonsStart), !is.null(input$sel_Season1Range[2]))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", input$sel_Season1Range[2] < (input$sel_SeasonsStart + 364))
      sliderInput("sel_Season2Range",
                  label = NULL,
                  min = input$sel_SeasonsStart, 
                  max = input$sel_SeasonsStart + 364,
                  step = 1,
                  value = c(input$sel_Season1Range[2] + 1, input$sel_SeasonsStart + 364), 
                  timeFormat = "%b-%d")
    }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons), !is.null(input$sel_SeasonsStart), !is.null(input$sel_Season2Range[2]))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", input$sel_Season2Range[2] < (input$sel_SeasonsStart + 364))
      br()
      textInput("sel_Season3Name",
                label = "LEVEL 3 name and start/end (inclusive):",
                placeholder = "E.g., Wet Season")
    }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons), !is.null(input$sel_SeasonsStart), !is.null(input$sel_Season2Range[2]))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", input$sel_Season2Range[2] < (input$sel_SeasonsStart + 364))
      sliderInput("sel_Season3Range",
                  label = NULL,
                  min = input$sel_SeasonsStart, 
                  max = input$sel_SeasonsStart + 364,
                  step = 1,
                  value = c(input$sel_Season2Range[2] + 1, input$sel_SeasonsStart + 364), 
                  timeFormat = "%b-%d")
    }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons), !is.null(input$sel_SeasonsStart), !is.null(input$sel_Season3Range[2]))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", input$sel_Season3Range[2] < (input$sel_SeasonsStart + 364))
      br()
      textInput("sel_Season4Name",
                label = "LEVEL 4 name and start/end (inclusive):",
                placeholder = "E.g., Wet Season")
    }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons), !is.null(input$sel_SeasonsStart), !is.null(input$sel_Season3Range[2]))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", input$sel_Season3Range[2] < (input$sel_SeasonsStart + 364))
      sliderInput("sel_Season4Range",
                  label = NULL,
                  min = input$sel_SeasonsStart, 
                  max = input$sel_SeasonsStart + 364, 
                  step = 1,
                  value = c(input$sel_Season3Range[2] + 1, input$sel_SeasonsStart + 364), 
                  timeFormat = "%b-%d")
    })
)  # end of 'wp_filter_yr_season'

  wellPanel(
    id = "wp_filter_org",
    
    renderUI({
      checkboxGroupInput("sel_SummaryOrg",
                         label = h6("Organizations to summarize: "),
                         choices = sort(unique(rv$dat$OrganizationFormalName)),
                         selected = switch(is.null(input$sel_SummaryOrg)+1, input$sel_SummaryOrg, sort(unique(rv$dat$OrganizationFormalName))))
    })
    )
  
# shinyjs::hidden( # initially hide this well panel
  wellPanel(
    id = "wp_filter_wqchar",

    renderUI({
      shiny::req(!is.null(rv$dat))
      checkboxInput("sel_NPSparam",
                    "Only show characteristics reported by NPS for the imported monitoring sites",
                    value = "National Park Service Water Resources Division" %in% rv$dat$OrganizationFormalName)
    }),
    
    renderUI({
            shiny::req(!is.null(rv$dat), !is.null(input$sel_NPSparam), !is.null(input$sel_YrRange), !is.null(input$sel_SummaryOrg), !is.null(input$sel_ActivityType), !is.null(input$sel_ResultStatus), !is.null(input$sel_MinYrs), !is.null(input$sel_MinStations))

rv_param_temp$selectParam <- rv$dat %>% 
        {if (input$sel_NPSparam == TRUE & "National Park Service Water Resources Division" %in% rv$dat$OrganizationFormalName) dplyr::filter(., OrganizationFormalName == "National Park Service Water Resources Division") else .} %>%
        dplyr::filter(ResultDetectionConditionText != "Not Reported") %>%
        dplyr::mutate(Yr = MeteoYr) %>%
        dplyr::filter(Yr >= as.integer(input$sel_YrRange[1]) & Yr <= as.integer(input$sel_YrRange[2]) & OrganizationFormalName %in% input$sel_SummaryOrg & ActivityTypeCode %in% input$sel_ActivityType & ResultStatusIdentifier %in% input$sel_ResultStatus) %>%
        dplyr::select(CharacteristicName, MonitoringLocationIdentifier, Yr) %>%
        dplyr::distinct() %>%
        group_by(CharacteristicName, MonitoringLocationIdentifier) %>%
        dplyr::mutate(TotalSurveyYrs = dplyr::n_distinct(Yr)) %>%
        dplyr::filter(TotalSurveyYrs >= input$sel_MinYrs) %>%
        dplyr::select(-Yr) %>%
        dplyr::distinct() %>%
        dplyr::ungroup() %>%
        dplyr::count(CharacteristicName) %>%
        dplyr::filter(n >= input$sel_MinStations) %>%
        .$CharacteristicName

      shiny::req(!is.null(rv_param_temp$selectParam))

      checkboxGroupInput("sel_SummaryParam",
                         label = h6("Water quality characteristics to summarize: "),
                         choices = sort(rv_param_temp$selectParam),
                         selected = switch(is.null(input$sel_SummaryParam)+1, input$sel_SummaryParam, rv_param_temp$selectParam[rv_param_temp$selectParam %in% c("Dissolved oxygen (DO)", "Escherichia coli", "Flow, severity (choice list)", "Flow, stream stage (choice list)", "Nitrate", "pH", "Specific conductance", "Temperature, water", "Turbidity")])
      )
    }),

renderUI({
  shiny::req(!is.null(rv_param_temp$selectParam))

      FuncAllNoneButtons(cond = "input.sel_SummaryParam", name_all = "button_allSummaryParam", name_none = "button_noSummaryParam")
})
)
# ) # end of 'wp_filter_wqchar'

# Filter data by sampling characteristics
  wellPanel(
    id = "wp_filter_sampling_chars",
    
    renderUI({
      checkboxGroupInput("sel_ActivityType",
                         label = h6("Include these activity types: "),
                         choices = sort(unique(rv$dat$ActivityTypeCode)),
                         selected = sort(intersect(unique(rv$dat$ActivityTypeCode), c("Field Msr/Obs", "Field Msr/Obs-Portable Data Logger",  "Sample", "Sample-Routine"))))
      }),
    
    renderUI({
      checkboxGroupInput("sel_ResultStatus",
                         label = h6("Include these result statuses: "),
                         choices = sort(unique(rv$dat$ResultStatusIdentifier)),
                         selected = sort(intersect(unique(rv$dat$ResultStatusIdentifier), c("Accepted", "Final", "Historical"))))
      })
  )


br()

# strong("Define threshold limits")
# 
# radioButtons("sel_GetThreshFile",
#              label = h6("Method for generating file:"),
#              choices = c("Attach threshold limits file from computer" = "existing_data", "Follow steps to create a threshold limits file" = "new_data"))
# actionButton("button_getThreshFile", "Add a Threshold Limits File", width = "100%") 
# 
# br()
  

```


Define & Filter Data {.tabset .tabset-fade}
-------------------------------------
### Filtered Data Summary

#### <font size="1.25">**Sites and survey years by parameter, for filtered data**</font>

* <font size="0.75"> The full list of characteristics for the filtered data are shown under 'Water quality characteristics to summarize', in the left sidebar. Only 'checked' characteristics are shown in this table.</font> 

* <font size="0.75"> The filtered data shown here will be used on the Explore Filtered Data page.</font>

* <font size="0.75"> Years and seasons are defined by the user as meteorological seasons (calendar year), USGS water year seasons (starts Oct. 1), or custom-defined seasons (see 'Define seasons as:' in left sidebar). These year and season definitions will be used on all subsequent pages of the dashboard.</font>

```{r filter_summary}
output$table_filtered_chars <- renderReactable({
  shiny::validate(
     need(!is.null(rv$dat), message = "No data available. Please use the 'Get WQP Data' tab to first import or load water quality data."))
  # shiny::validate(
    # need(!is.null(rv_param_temp$subDat) & !is.null(rv_param_temp$subDatTypes), message = "From the left sidebar, select new filter criteria (or use default settings) and then click the green 'REFRESH FILTER' button"))
          
  FuncFilterDat()
  
  if(!is.null(rv_param_temp$subDat)) {
    rv_param_temp$subDatTypes <- as.data.frame(FuncDataTypes(dat = rv_param_temp$subDat))}
    shiny::req(!is.null(rv_param_temp$subDatTypes), !is.null(rv_param_temp$subDatYears))
    
    df_char <- rv_param_temp$subDatTypes %>%
      left_join(rv_param_temp$subDatYears %>% ungroup() %>% dplyr::select(CharacteristicName, TotalSurveyYrs), by = "CharacteristicName") %>%
  dplyr::add_count(CharacteristicName) %>%
  dplyr::rename(NumSites = n) %>%
  dplyr::group_by(across(c(-TotalSurveyYrs))) %>%
  dplyr::mutate(MinYrsSiteSurveyed = min(TotalSurveyYrs, na.rm = TRUE),
                MedianYrsSiteSurveyed = median(TotalSurveyYrs, na.rm = TRUE),
                MaxYrsSiteSurveyed = max(TotalSurveyYrs, na.rm = TRUE)) %>%
  dplyr::select(-TotalSurveyYrs) %>%
  dplyr::distinct() %>%
  arrange(CharacteristicName)
                
  reactable(
    df_char,
    columns = list(
      CharacteristicName = colDef(name = "Characteristic"),
      DataType = colDef(header = with_tooltip("Data Type", "The characteristic is classified as 'categorical' if any entry is non-numeric (excluding missing data)"), width = 100, align = "center"),
      NonNumericEntries = colDef(header = with_tooltip("Non-Numeric Entries", "Lists all non-numeric entries for a characteristic classified as 'categorical'. Includes entries with mathematical symbols, e.g., '< 2.5', because these cannot be interpreted as a number (if these values are detection thresholds, the Water Quality Portal defines an appropriate way for such data to be entered, so they can be used in analyses)"), minWidth = 110),
      NumSites = colDef(header = with_tooltip("# of Sites", "# of sites with data imported (based on user-defined import filters)"), width = 100, align = "center"),
    MinYrsSiteSurveyed = colDef(header = with_tooltip("Min", "Minimum # of years surveyed at a site"), width = 70, align = "center"),
    MedianYrsSiteSurveyed = colDef(header = with_tooltip("Median", "Median # of years surveyed at a site (50% of sites have been surveyed for longer)"), width = 75, align = "center"),
    MaxYrsSiteSurveyed = colDef(header = with_tooltip("Max", "Maximum # of years surveyed at a site"), width = 70, align = "center"),
      NumRecords = colDef(header = with_tooltip("# of Records", "Total number of data records for this characteristic"), width = 80, align = "center")
    ),
    columnGroups = list(
    colGroup(name = paste0("# of ", rv_param_temp$seasonType, " Surveyed"), columns = c("MinYrsSiteSurveyed", "MedianYrsSiteSurveyed", "MaxYrsSiteSurveyed"))
  ),
    details = function(index) {
      site_info <- rv_param_temp$subDatYears[rv_param_temp$subDatYears$CharacteristicName == df_char$CharacteristicName[index], ]
      htmltools::div(style = "padding: 20px",
                     reactable(site_info,
                               columns = list(
                                 CharacteristicName = colDef(show = FALSE),
                                 MonitoringLocationIdentifier = colDef(name = "Site ID"),
                                 StartYr = colDef(name = "Start", width = 90, align = "center"),
                               EndYr = colDef(name = "End", width = 90, align = "center"),
                               TotalSurveyYrs = colDef(
                                 header = with_tooltip("# of Years Site Surveyed", "Full (gray) bar length is maximum # of years among all (filtered) sites that data have been collected on this characteristic, red bar length is # of years this site  has collected data on this characteristic"),
                                 width = 150,
                                 cell = function(value) {
                                   width <- paste0(value * 100 / max(site_info$TotalSurveyYrs), "%")
                                   bar_chart(value, width = width, fill = "#fc5185", background = "#e1e1e1")
                                 }),
                               NumRecords = colDef(name = "# of Records", width = 80, align = "center")),
                               columnGroups = list(
                               colGroup(name = paste0(rv_param_temp$seasonType, " Surveyed"), columns = c("StartYr", "EndYr"))),
                               defaultSorted = list(TotalSurveyYrs = "desc"),
                     resizable = TRUE,
                     filterable = TRUE,
                     striped = FALSE,
                     highlight = TRUE,
                     showSortIcon = TRUE,
                     compact = TRUE,
                     pagination = FALSE,
                     outlined = FALSE,
                     bordered = FALSE,
                     theme = reactableTheme(backgroundColor = "hsl(186, 56%, 94%)")
      )
  )
      },
  defaultSorted = list(CharacteristicName = "asc"),
    resizable = TRUE, 
    filterable = FALSE,
    striped = FALSE,
    highlight = TRUE,
    showSortIcon = TRUE,
    compact = FALSE,
    bordered = TRUE,
    showPageSizeOptions = TRUE)

  })
reactableOutput("table_filtered_chars")
# tags$style("#table_filtered_chars{height:100vh;overflow-x:scroll;overflow-y:scroll}")

```

### Sample Size Matrix

####
```{r sample_size_input}

renderUI({
      shiny::req(!is.null(rv_param_temp$subDat))
      awesomeRadio("sel_TimeSubunit",
               label = strong("Time unit for 'Sample Size Matrix'"),
               choices = c("Month" = "Mnth", "Season" = "Season"),
               selected = switch(is.null(input$sel_TimeSubunit)+1, input$sel_TimeSubunit, "Season"))
    })

renderUI({
  shiny::req(!is.null(rv_param_temp$subDat))
  
  char_choices <- sort(unique(rv_param_temp$subDat$CharacteristicName))

  shinyWidgets::radioGroupButtons("sel_SampleSizeChar",
              label = strong("Select a water characteristic to display:"),
              choices = char_choices,
              selected = char_choices[1],
              individual = TRUE,
              status = "primary",
              size = "xs"
              )
})
```

####
```{r sample_sizes}
output$out_SamplePlots <- renderPlot({ 
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_TimeSubunit), !is.null(input$sel_SampleSizeChar))
  
  withProgress(message = "Generating plots", detail = "...calculating sample sizes", value = 0, {
  # Create sample size matrix for the selected char, but use a consistent color legend across all chars
  
          N_dat <- rv_param_temp$subDat %>%
            dplyr::rename(TimeUnit = input$sel_TimeSubunit) %>%

            dplyr::group_by(CharacteristicName, MonitoringLocationIdentifier, TimeUnit, Yr) %>%
            dplyr::summarise(FillCol = n()) %>%
            dplyr::ungroup()
          
          legend_range <- range(N_dat$FillCol, na.rm = FALSE) # make sure all plots use same legend range
          
          N_dat %<>% 
            dplyr::filter(CharacteristicName == input$sel_SampleSizeChar)
          
          # Fill missing values
          heatmap_dat <- merge(
            N_dat %>%
              dplyr::select(CharacteristicName, MonitoringLocationIdentifier) %>%
    dplyr::distinct(), expand_grid(TimeUnit = levels(N_dat$TimeUnit), Yr = min(N_dat$Yr, na.rm = TRUE):max(N_dat$Yr, na.rm = TRUE))) %>%
            left_join(N_dat, by = c("CharacteristicName", "MonitoringLocationIdentifier", "TimeUnit", "Yr")) %>%
            dplyr::mutate(TimeUnit = factor(TimeUnit, levels = levels(rv_param_temp$subDat[[input$sel_TimeSubunit]]))) %>%
            dplyr::arrange(CharacteristicName, MonitoringLocationIdentifier, TimeUnit, Yr)
          shiny::req(!is.null(heatmap_dat)) 
          
          rv_param_temp$filterNPlot <- FuncPlotHeatMap(dat = heatmap_dat, y_name = input$sel_TimeSubunit,  legend_range = legend_range, legend_name = "# of Survey Events")
          
  })
          rv_param_temp$filterNPlot
  },
  height = reactive({switch(is.null(rv_param_temp$filterNPlot)+1, 250+30*nrow(rv_param_temp$subDat %>% dplyr::filter(CharacteristicName == input$sel_SampleSizeChar) %>% dplyr::select(CharacteristicName, MonitoringLocationIdentifier) %>% dplyr::distinct())*(1+length(levels(rv_param_temp$subDat[[input$sel_TimeSubunit]]))), 400)}),
                    width = reactive({switch(is.null(rv_param_temp$filterNPlot)+1, max(800, 25*(max(subset(rv_param_temp$subDat, CharacteristicName == input$sel_SampleSizeChar)$Yr, na.rm = TRUE)-min(subset(rv_param_temp$subDat, CharacteristicName == input$sel_SampleSizeChar)$Yr, na.rm = TRUE)+1)+100), 800)})
)
tags$style("#out_SamplePlots{height:100vh;overflow-x:scroll;overflow-y:scroll}")
plotOutput("out_SamplePlots", height="100%", width = "90%")
```

Explore Data
====================================== 

Inputs {.sidebar data-width=300}
-------------------------------------
```{r summary_sidebar}  
FuncAboutButton(nam = "button_aboutExploreData")
observeEvent(eventExpr = input$button_aboutExploreData, {
  browseURL(here::here("About_files", "aboutExploreData.html"))})

br()

br()

# output$out_alert <- renderText({
#     shiny::req(!is.null(rv_param_temp$plotDat))
#     "NOTE: Summaries by Reporting Site are limited to survey events for which data are available for all included Sites"
#   })
# conditionalPanel(
#   condition = "(typeof output.out_alert !== 'undefined' && output.out_alert > 0)",
#   tags$div(
#   id = "test_alert",
#   class = "alert alert-warning",
#   textOutput("out_alert")
#   )
# )

wellPanel(
  id = "summarize_char_stations",
  p(strong("Select data to plot")),
  
  actionButton("button_refreshPlotData", "REFRESH PLOT DATA", style="border-color:black; background-color: lightgreen; width:100%; border:0px; margin:0px"), # updates plots

renderUI({
  radioButtons("sel_SummarizeBy",
               label = h6(" Summarize by:"),
               choiceNames = list("ONE CHARACTERISTIC for many sites", "many characteristics for ONE SITE"),
               choiceValues = list("by_char", "by_station"),
               selected = "by_char")
  }),

# Generate bold, red warning if characteristic sets with different measurement units are compared for a single characteristic
tags$div(renderText({
  shiny::req(!is.null(rv_param_temp$finalPlot$plotly_page), !is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$showCharSets))

  char_incomp <- rv_param_temp$plotDat %>% dplyr::group_by(CharacteristicName) %>% dplyr::summarize(num_units = length(unique(na.omit(ResultMeasure.MeasureUnitCode)))) %>% dplyr::ungroup() %>% dplyr::filter(num_units > 1) %>% .$CharacteristicName

  if(length(char_incomp) > 0) {
    paste0("WARNING!! It looks like you're summarizing data with different measurement units for these characteristics: ", paste(char_incomp, collapse = ", "), ". Results are NOT VALID if the selected units are not comparable.")  # Post a warning if it looks like different measurement units are being compared
  }
}), style = "font-size:14px; color:red;"), # could also bold it... font-weight:bold;

hr(),

# If summarizing by characteristic (ONE CHARACTERISTIC for many stations)...
renderUI({
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(rv_param_temp$subDatTypes))
  shiny::req(input$sel_SummarizeBy == "by_char")

  char_choices <- sort(intersect(unique(rv_param_temp$subDat$CharacteristicName), rv_param_temp$subDatTypes$CharacteristicName[rv_param_temp$subDatTypes$DataType == "numeric"]))

  selectInput("sel_ShowChar",
                  label = h6("Select a characteristic to plot:"),
                  choices = char_choices,
                  selected = switch(is.null(input$sel_ShowChar)+1, input$sel_ShowChar, char_choices[1]))
}),

renderUI({
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowChar))
  shiny::req(input$sel_SummarizeBy == "by_char")

  checkboxGroupInput("sel_ShowStations",
                          label = h6("Select monitoring site(s):"),
                          choices =  sort(unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowChar])),
                          selected = input$sel_ShowStations
  )# don't do switch here because will cause problems with select all/none

  }),

renderUI({
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowChar))
  shiny::req(input$sel_SummarizeBy == "by_char")

      FuncAllNoneButtons(cond = "input.sel_ShowStations", name_all = "button_allStations", name_none = "button_noStations")
}),

renderUI({
    shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowChar), !is.null(input$sel_ShowStations))
  shiny::req(input$sel_SummarizeBy == "by_char")

        checkboxGroupInput("sel_ShowCharSets",
                         label = h6("Select characteristic set(s):"),
                         choices = sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName==input$sel_ShowChar & rv_param_temp$subDat$MonitoringLocationIdentifier %in% input$sel_ShowStations])),
                         selected = sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName==input$sel_ShowChar & rv_param_temp$subDat$MonitoringLocationIdentifier %in% input$sel_ShowStations])))
        }),

renderUI({
   shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowChar), !is.null(input$sel_ShowStations))
  shiny::req(input$sel_SummarizeBy == "by_char")

    FuncAllNoneButtons(cond = "input.sel_ShowCharSets", name_all = "button_allCharSets", name_none = "button_noCharSets")
    }),

# If summarizing by station (many characteristics for ONE STATION)...
renderUI({
    shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat))
  shiny::req(input$sel_SummarizeBy == "by_station")

    selectInput("sel_ShowOneStation",
                label = h6("Select a monitoring site:"),
                choices = sort(unique(rv_param_temp$subDat$MonitoringLocationIdentifier)),
                selected = input$sel_ShowOneStation)
}),

renderUI({
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(rv_param_temp$subDatTypes), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")

    checkboxGroupInput("sel_ShowStationChars",
              label = h6("Select characteristic(s):"),
              choices = sort(intersect(unique(rv_param_temp$subDat$CharacteristicName[rv_param_temp$subDat$MonitoringLocationIdentifier == input$sel_ShowOneStation]), rv_param_temp$subDatTypes$CharacteristicName[rv_param_temp$subDatTypes$DataType == "numeric"])),
              selected = input$sel_ShowStationChars
              ) # don't do switch here because will cause problems with select all/none
}),

renderUI({
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(rv_param_temp$subDatTypes), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")

    FuncAllNoneButtons(cond = "input.sel_ShowStationChars", name_all = "button_allStationChars", name_none = "button_noStationChars")
}),

renderUI({
   shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowStationChars), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")

    checkboxGroupInput("sel_ShowStationCharSets",
                         label = h6("Select characteristic set(s):"),
                         choices = sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowStationChars & rv_param_temp$subDat$MonitoringLocationIdentifier == input$sel_ShowOneStation])),
                         selected = sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowStationChars & rv_param_temp$subDat$MonitoringLocationIdentifier == input$sel_ShowOneStation])))

}),

renderUI({
   shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowStationChars), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")

    FuncAllNoneButtons(cond = "input.sel_ShowStationCharSets", name_all = "button_allStationCharSets", name_none = "button_noStationCharSets")
    }) 
) # end of wellPanel

## Panel to define high/low values ----
wellPanel(
  id = "define_limits",
  p(strong("Define thresholds and percentile bounds")),

  renderUI({
    shiny::req(!is.null(rv_param_temp$subDat))
    radioButtons("sel_ShowThresholds",
                 label = h6("Show threshold limits on plot"),
                 choiceNames = c("Do not show", "Use limits entered below for the selected characteristic", "Use threshold limits from attached file"),
                 choiceValues = c("showthresh_none", "showthresh_custom", "showthresh_file"),
                 selected = switch(is.null(input$sel_Thresholds)+1, switch((input$sel_SummarizeBy=="site")+1, input$sel_Thresholds, "showthresh_none"), switch(is.null(rv_param_temp$threshList)+1, "showthresh_file", "showthresh_custom"))
    )
    }),

  renderUI({ # Set threshold limits
    shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_ShowThresholds), !is.null(input$sel_SummarizeBy))
    shiny::req(input$sel_ShowThresholds == "showthresh_custom")
    conditionalPanel(
      condition = "input.sel_ShowThresholds == 'showthresh_custom'",
      shiny::validate(need(input$sel_SummarizeBy == "by_char", message = "This option is available only when summarizing by characteristic (not by station)")),
        selectInput("sel_ThreshUnit",
                    label = "Threshold measure unit",
                    choices = sort(unique(na.omit(rv_param_temp$subDat$ResultMeasure.MeasureUnitCode[ rv_param_temp$subDat$CharacteristicName == input$sel_ShowChar]))),
                    selected = switch(is.null(input$sel_ThreshUnit)+1, input$sel_ThreshUnit, sort(unique(na.omit(rv_param_temp$subDat$ResultMeasure.MeasureUnitCode[ rv_param_temp$subDat$CharacteristicName == input$sel_ShowChar])))[1])
        ),
        numericInput("sel_ThreshLower",
                     label = "Enter a LOWER threshold limit (use -9999 for no lower limit)",
                     value = -9999,
                     min = NA,
                     max = NA,
                     step = NA),
        numericInput("sel_ThreshUpper",
                     label = "Enter an UPPER threshold limit (use 9999 for no upper limit)",
                     value = 9999,
                     min = NA,
                     max = NA,
                     step = NA)
    )
    }),

  br(),

  renderUI({
  checkboxInput("sel_AddQuantile",
              label = h6("Add percentile lines to plot"),
              value = switch(is.null(input$sel_AddQuantile)+1, input$sel_AddQuantile, TRUE))
    }),

  renderUI({
    shiny::req(!is.null(input$sel_AddQuantile),
               !is.null(input$sel_SummarizeBy))
    shiny::req(input$sel_AddQuantile == TRUE)
    conditionalPanel(
      condition = "input.sel_AddQuantile == true",
      numericInput("sel_QuantileProbLower",
                 label = "Enter lower percentile limit (or 0 for no lower limit)",
                 value = 0.05,
                 min = 0.0,
                 max = 1.0,
                 step = 0.05),
      numericInput("sel_QuantileProbUpper",
                 label = "Enter upper percentile limit (or 1 for no upper limit)",
                 value = 0.95,
                 min = 0.0,
                 max = 1.0,
                 step = 0.05),
      # if(input$sel_SummarizeBy == "by_char") {
        selectInput("sel_QuantileGroupBy",
                 label = "Calculate percentile limits:",
                 choices = c("per site" = "quant_each",
                             "across sites" = "quant_all"),
              selected = "quant_all")
        # }
      )
    })
) # end of wellPanel

## Panel to add streamflow/precip data ----
wellPanel(
  id = "plot_display_options",
  p(strong("Add streamflow/precip")),

  # Additional plot
  renderUI({
    radioButtons("sel_AddGagePrecip",
                 label = h6("Add external data plot: "),
                 choices = c("none", "streamflow", "precipitation"),
                 selected = switch(is.null(input$sel_AddGagePrecip)+1, input$sel_AddGagePrecip, "none")
                 )
  }),

  # Add streamflow plot
  renderUI({
    shiny::req(!is.null(input$sel_AddGagePrecip))
    shiny::req(input$sel_AddGagePrecip == "streamflow")
    shiny::validate(
      need(!is.null(rv$selectedGages) & !is.null(rv$gagesDat), message = "No streamflow data imported"))
    conditionalPanel(
      condition = "input.sel_AddGagePrecip == 'streamflow'",
      selectInput("sel_GageStation", # choose a gage station
                  label = "Select a gage station for streamflow data",
                  choices = sort(unique(rv$selectedGages$GageName)),
                  selected = switch(is.null(input$sel_GageStation)+1, input$sel_GageStation, sort(unique(rv$selectedGages$GageName))[1])),
      )
    }),

  # Add precipitation plot
  renderUI({
    shiny::req(!is.null(input$sel_AddGagePrecip))
    shiny::req(input$sel_AddGagePrecip == "precipitation")
    shiny::validate(
      need(!is.null(rv$selectedMeteo) & !is.null(rv$meteoDat), message = "No precipitation data imported"))
    conditionalPanel(
      condition = "input.sel_AddGagePrecip == 'precipitation'",
      selectInput("sel_PrecipStation", # choose a weather station
                  label = "Select a weather station",
                  choices = sort(unique(rv$selectedMeteo$MeteoName)),
                  selected = switch(is.null(input$sel_PrecipStation)+1, input$sel_PrecipStation, sort(unique(rv$selectedMeteo$MeteoName))[1])),
      )
    })
) # end of wellPanel
```

Column
-------------------------------------
```{r map_input}

div(style="display:flex; flex-direction:row; max-width:100%; justify-content:space-evenly; flex-wrap: wrap; align-items: center;",
    
    # Left side inputs
    div(style ="flex: 0 1 auto; padding:2px;", # using default flex grow-shrink-size
        renderUI({
          shiny::req(!is.null(rv$sitesPointsSub))
    sliderInput("sel_MapPointSize", label = "Resize map pie charts:", min = -3, max = 3, value = 0, step = 1, ticks = FALSE, dragRange = FALSE, width = "100%")
    }),
  
        renderUI({ 
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$plotDat))
        # shiny::req(identical(unique(rv_param_temp$plotDat$MonitoringLocationIdentifier), rv_param_temp$param_map_highlight)) # make sure the plots have been updated  
        shiny::req(identical(input$sel_SummarizeBy, rv_param_temp$sel_summarize_by))
  shinyWidgets::radioGroupButtons("sel_ParamMapShow",
              label = h6("Show on map: "),
              choices = switch((input$sel_SummarizeBy == "by_char")+1, c("Sites" = "show"), c("Sites" = "show", "Median" = "median", "Thresholds" = "thresh", "Percentiles" = "perc")),
              status = "primary",
              size = "xs",
              selected = "show") # <<<<<<<<< NEED TO CALC OVERALLS STILL
  })
  ),

div(style ="flex: 0 1 50; padding:2px;", # using default flex grow-shrink-size
    renderUI({
  shiny::req(!is.null(rv$sitesPointsSub))
  param_map_zoom <- min(RgoogleMaps::MaxZoom(lonrange = c(st_bbox(rv$sitesPointsSub)$xmin, st_bbox(rv$sitesPointsSub)$xmax), latrange = c(st_bbox(rv$sitesPointsSub)$ymin, st_bbox(rv$sitesPointsSub)$ymax)))
  sliderInput("sel_ParamMapZoom", label = h6("Set map zoom:"), min = max(1, param_map_zoom - 3), max = param_map_zoom + 5, value = param_map_zoom - 1, step = 0.25, ticks = FALSE, dragRange = FALSE, width = "100%")
  }),
  
  renderUI({
  shiny::req(!is.null(rv$unitPoly), !is.null(rv_param_temp$sel_summarize_by), !is.null(rv_param_temp$plotDat), !is.null(input$sel_ParamMapShow))
    shiny::req(input$sel_ParamMapShow != "show")
  sliderTextInput("sel_SurvYr", force_edges = TRUE, label = h6("Choose a survey year"), choices = sort(unique(rv_param_temp$plotDat$Yr)), selected = max(rv_param_temp$plotDat$Yr, na.rm = TRUE), dragRange = FALSE, animate = TRUE, width = "100%")
  })
  )
)

  br()
```

```{r map}  
bslib::card(
  full_screen = TRUE,
  card_body(
leafletOutput('param_map', width = "100%")
))
```

Column {.tabset .tabset-fade}
-------------------------------------
```{r}

output$table_plot_summary <- DT::renderDT({
  
  shiny::req(!is.null(rv_param_temp$sel_summarize_by), !is.null(rv_param_temp$plotDat))
  
  cat("sTARTING FUNCSUMMARYSTATS")
  plotSummary <- FuncSummaryStats(dat = rv_param_temp$plotDat, plot_summarize_by = rv_param_temp$sel_summarize_by)
  
  shiny::req(!is.null(plotSummary))
  
cat("CREATING DT")
  DT::datatable(
    plotSummary,
    rownames = FALSE,
    filter = "top",
    selection = "none",
    class="compact stripe",
    extensions=c('Buttons','ColReorder'),
    options = list(
          dom = 'Blrtp',
          buttons = list('csv', 'excel'),
          lengthMenu = list(c(20,30,40,-1),
                          c(20,30,40,"All")),
          colReorder=TRUE,
          pageLength = 20,
        columnDefs = list(list(className = 'dt_center', targets = "_all")),
          autoWidth = FALSE
        )
  )
  })
  
observeEvent(input$button_plotTable, {
    div(style="max-width:100%;",
  showModal(
    modalDialog(
    title = "Summary statistics for plot data",
    easyClose = FALSE,
    size = "l",
    div(DTOutput("table_plot_summary"),style = "font-size:80%"),
  tags$head(tags$style("#plot_tab .modal-footer{display:none} .modal-lg{min-width:90%;margin:0;height:auto;)")),
  idcss = "plot_tab"
  ))
    )
  })

```

```{r plots_inputs}
## Start of plot inputs
div(style="display:flex; flex-direction:row; max-width:100%; justify-content:space-evenly; flex-wrap: wrap; align-items: center;",
 
    div(style ="flex: 0 1 auto; padding:2px;", # using default flex grow-shrink-size
        
    shinyWidgets::radioGroupButtons("sel_PlotType",
             label = h6("Plot type:"),
             choiceNames = list("Points", "Points + Smooth", "Box Plots"),
             choiceValues = list("points", "points_smooth", "box"),
             status = "primary",
             size = "xs",
             selected = "points"),
  
  shinyWidgets::dropdownButton(
    inputId = "dropdown_options",
    label = "Additional Plot Options",
    circle = FALSE,
    status = "button_menu",
    size = "xs",
    icon = icon("sliders"),
    tooltip = "Options for user to modify plot",
    
    ## Log-transform y-axes
    renderUI({
  shiny::req(!is.null(rv_param_temp$plotDat), !is.null(rv_param_temp$sel_add_gage_precip)) # the option to log-transform y-axes only appears after plots have been generated
  
  param_choices <- rv_param_temp$plotDat %>% dplyr::select(CharacteristicName) %>% dplyr::distinct() %>% pull(CharacteristicName)
  if(rv_param_temp$sel_add_gage_precip == "streamflow" & !is.null(rv_param_temp$sel_gage_station)) { # if there is a selected gage station
    param_choices <- c(param_choices, "streamflow")
  }
  if(rv_param_temp$sel_add_gage_precip == "precipitation" & !is.null(rv_param_temp$sel_precip_station)) { # if there is a selected precip station
    param_choices <- c(param_choices, "precipitation")
  }
  
  checkboxGroupInput("sel_log_y",
                     label = h6("Log-transform y-axis for:"),
                     choices = param_choices,
                     selected = NULL)
                      # a vector of the parameters for which y-axis should be log-transformed
}),
     
 ## Color by categorical character      
  renderUI({
    shiny::req(any(is.null(input$sel_CombineSites), input$sel_CombineSites == FALSE)) # If sites are combined, then colors already represent different sites
    radioButtons("sel_Categ",
                 label = h6("Color point plots by a categorical characteristic:"),
                 choices = switch((!is.null(rv_param_temp$categLevelsPlot) & !is.null(input$sel_SummaryParam))+1, "none", c("none", sort(intersect(input$sel_SummaryParam, unique(rv_param_temp$categLevelsPlot$CharacteristicName))))),
                 selected = "none")
    }),

    renderUI({
      sliderInput("sel_PlotHt",
                   label = h6("Change plot height:"),
                  min = -3,
                  max = 7,
                  step = 1,
                  animate = FALSE,
                   value = 0)
    })
  ) # End Additional Plot Options
),

    div(style ="flex: 0 1 auto; padding:2px;", # using default flex grow-shrink-size
    
    renderUI({
      shiny::req(all(!is.null(input$sel_SummarizeBy), input$sel_SummarizeBy == "by_char"), !is.null(input$sel_CombineSites), input$sel_CombineSites == FALSE)
      span(class="horiz_input",
      checkboxInput("sel_FreeY",
                        label = h6("Allow y-axis to differ by plot"),
                        value = switch(is.null(input$sel_FreeY)+1, input$sel_FreeY, FALSE))
      )
  }),
  
    renderUI({
      shiny::req(all(!is.null(input$sel_SummarizeBy), input$sel_SummarizeBy == "by_char"))
      checkboxInput("sel_CombineSites",
                        label = h6("Combine sites in one plot"),
                        value = switch(is.null(input$sel_CombineSites)+1, input$sel_CombineSites, FALSE))
      }),
  
  actionButton(inputId = "button_plotTable", label = "View Table", icon = icon("table-cells", lib = "font-awesome"), style="color:black; background-color: lightblue; display:inline-block; border:1px; margin:5px")
  )
)
```

### Time Series

####
```{r TS_plots_legend}
renderPlot({ # separate validation statements so they are checked in sequence
  shiny::req(!is.null(rv$userSelect), !is.null(rv$sitesPointsSub), !is.null(rv_param_temp))
  if(any(!rv$userSelect$sel_Organization %in% rv$sitesPointsSub$OrganizationFormalName, is.null(rv_param_temp$finalPlot), is.null(rv_param_temp$showStations), is.null(rv_param_temp$showCharSets), is.null(rv_param_temp$finalPlot$shared_legend))) { # this if-statement forces the plot to be reset to blank when these conditions apply
    ts_plotly_legend <- ggplot(dat = data.frame()) + theme_minimal()
  } else {
    ts_plotly_legend <- grid.arrange(rv_param_temp$finalPlot$shared_legend)
  }
  ts_plotly_legend
}, height = 50) # setting the width here or at the 'Legend' subheading seems to rescale the height too. Size of ggplot legends is absolute. Set height through the 'Legend' subheading in combination with here. Legend width will not adjust with browser window. Fixed the width issue by putting the plot notes on a white background.
```

```{r ts_plots}
bslib::card(
  full_screen = TRUE,
  card_body(
    plotlyOutput("out_ts_plots")
    )
)
```

### Seasonal Patterns
####
```{r seasonal_plots_input}
shinyWidgets::radioGroupButtons("sel_SeasonalTimeUnit",
              label = h6("SEASONAL patterns time unit:"),
              choices = c("Day of Year" = "DayOfYr", "Week of Year" = "Wk", "Month of Year" = "Mnth", "Season of Year" = "Season"),
              selected = "Mnth",
              status = "primary",
              size = "xs")
```

#### 
```{r seasonal_plots_legend}
renderPlot({ # separate validation statements so they are checked in sequence
    shiny::req(!is.null(rv$userSelect), !is.null(rv$sitesPointsSub), !is.null(rv_param_temp))
    if(any(!rv$userSelect$sel_Organization %in% rv$sitesPointsSub$OrganizationFormalName, is.null(rv_param_temp$finalPlot), is.null(rv_param_temp$showStations), is.null(rv_param_temp$showCharSets), is.null(rv_param_temp$finalPlot$shared_legend))) { # this if-statement forces the plot to be reset to blank when these conditions apply
    ts_plotly_legend <- ggplot(dat = data.frame()) + theme_minimal()
  } else {
    ts_plotly_legend <- grid.arrange(rv_param_temp$finalPlot$shared_legend)
  }
  ts_plotly_legend
}, height = 50) # setting the width here or at the 'Legend' subheading seems to rescale the height too. Size of ggplot legends is absolute. Set height through the 'Legend' subheading in combination with here. Legend width will not adjust with browser window. Fixed the width issue by putting the plot notes on a white background.
```

```{r seasonal_plots}
bslib::card(
  full_screen = TRUE,
  card_body(
    plotlyOutput("out_season_plots")
  )
)
```

### Annual Threshold Levels
```{r pie_thresh}
bslib::card(
  full_screen = TRUE,
  card_body(
    plotlyOutput("out_thresh_plots")
  )
)
```

### Annual Percentile Levels
```{r pie_perc}
bslib::card(
  full_screen = TRUE,
  card_body(
    plotlyOutput("out_perc_plots")
  )
)
```

Raw Data
======================================

Inputs {.sidebar data-width=340}
-------------------------------------
```{r raw_data_input}
FuncAboutButton(nam = "button_aboutRawData")
observeEvent(eventExpr = input$button_aboutRawData, {
  browseURL(here::here("About_files", "aboutRawData.html"))})

br()

br()

strong("Raw Data Fields for Filtered Data")

# Raw data columns to display
em(tags$a(href="https://www.waterqualitydata.us/portal_userguide/#WQPUserGuide-Table5", target="_blank", "Click for Variable Definitions"))
    renderUI({
      checkboxGroupInput("sel_RawFilteredDataCols",
                       label = h6("Raw data fields (columns) to display: "),
                       choices = sort(names(rv$dat)),
                       selected = c("OrganizationFormalName", "MonitoringLocationIdentifier", "CharacteristicName", "ActivityTypeCode", "ActivityStartDate", "ResultDetectionConditionText", "ResultMeasureValue", "ResultStatusIdentifier", "ResultCommentText")
                     )
      })
```

Raw Data
-------------------------------------

### Raw Data

<center>*For the filtered data, this table shows data records from the Water Quality Portal. Use the left sidebar to select data columns to display.*</center>

```{r raw_data}
output$table_raw_filtered <- DT::renderDT({

  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$subDat), !is.null(rv_param_temp$subDatTypes))

  output$table_raw_filtered <- DT::renderDT({

  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$subDat), !is.null(rv_param_temp$subDatTypes))

  DT::datatable(
    rv_param_temp$subDat %>%
      {if(!is.null(input$sel_RawFilteredDataCols)) dplyr::select(., input$sel_RawFilteredDataCols) else dplyr::select(., OrganizationFormalName, MonitoringLocationIdentifier, CharacteristicName, ActivityTypeCode, ActivityStartDate, ResultDetectionConditionText, ResultMeasureValue, ResultStatusIdentifier, ResultCommentText)},
    rownames = FALSE,
    filter = "top",
    selection = "none",
    class="compact stripe",
    extensions=c('Buttons','ColReorder'),
    options = list(
          dom = 'Blrtp',
          buttons = list('csv', 'excel'),
          lengthMenu = list(c(10, 20,30,40,-1),
                          c(10, 20,30,40,"All")),
          colReorder=TRUE,
          pageLength = 10,
        columnDefs = list(list(className = 'dt_center', targets = "_all")),
          autoWidth = FALSE
        )
  )
})
})

DTOutput("table_raw_filtered")
```

Troubleshooting & FAQ's
====================================== 

Plot Data Tables {.tabset .tabset-fade}
-------------------------------------
### About the Data (placeholder to fill)
* Where do the data come from?
- [park unit boundaries - downloaded 1/9/2024] https://irma.nps.gov/DataStore/Reference/Profile/2224545?lnv=True [citation is: National Park Service (NPS), Chief Cartographer, Land Resources Division, WASO Fort Collins Land Resources Program Center. 2024. Administrative Boundaries of National Park System Units - National Geospatial Data Asset (NGDA) NPS National Parks Dataset. NPS - Land Resources Division]
- [Water Quality Portal] [citation is: Water Quality Portal. Washington (DC): National Water Quality Monitoring Council, United States Geological Survey (USGS), Environmental Protection Agency (EPA); 2021. https://doi.org/10.5066/P9QRKUVJ.]

### Troubleshooting (placeholder to fill)
* I could not import data from web services (import aborted)
* Some of the data from WQP were not in the imported data file
- APPA, etc., by HUC so needed HUC10 associated
- Default is at least 2 sampling activities within the past 6 years and a subset of site types and WQ parameters. Try custom import instead.
* I found a bug in the dashboard! How do I report it?
* I found a mistake in the data--how do I report it?

### FAQ's (placeholder to fill)
* Difference btwn fast import and custom import
* Can I import my own water quality data to display with the visualizer?
* What is a water quality "characteristic set"?
* What is "sampling activities"?
* How can I set custom seasons if I don't want to use calendar seasons?
* How can I export figures and tables from the dashboard?
* How were default threshold limits determined?
https://www.epa.gov/wqs-tech/state-specific-water-quality-standards-effective-under-clean-water-act-cwa#tb4
* How to reorder/display categorical parameters with colors?
* How to upload my own threshold limits?
* Can I set threshold limits calculated over multiple days, etc.?
* Can I download the dashboard to my own computer?
* GitHub link and contact email for questions, suggestions, reporting bugs
* What R and package versions does this dashboard use?