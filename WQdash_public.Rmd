---
title: "Water in Our Parks"
output:
  flexdashboard::flex_dashboard:
    theme: yeti   # theme options: default, cosmo, bootstrap, cerulean, journal, flatly, readable, spacelab, united, lumen, paper, sandstone, simplex, yeti
orientation: columns
vertical_layout: scroll
runtime: shiny
---

```{r global, include=FALSE}

# Install and load packages
rm(list=ls())

pkgs <- c("flexdashboard", "shiny", "knitr",  "here", "tidyverse", "janitor", "mgcv", "plyr", "scales", "rtf", "rmarkdown", "shinyWidgets", "leaflet", "RgoogleMaps", "plotrix", "GGally", "plotly", "httr", "jsonlite", "tidyverse", "readr", "sp", "rgdal", "sf", "rgeos", "magrittr", "leaflet.extras", "lubridate", "fontawesome", "viridisLite", "purrr",
          "stringr",
          "ggpubr", # for drawing separate legends
              "heatmaply", # for interactive heat plots
              "reactable", # for easy nested tables
              "htmltools", # for arranging plots in tab (browsable)
              "shinyFiles", # for user to save files in specified location
              "RColorBrewer", # to display brewer palettes
              "shinyjs", # for easy functions that use JavaScript
              "stringr", # to detect text snippets
              "sortable", # drag-and-drop rank input <<<<<<<<<<
              "tmaptools", # for flexible color mapping
              "DT", # for interactive tables
              "zoo", # for year-month
              "cowplot", # to get legends from plots
              "gridExtra", # for arranging plots and adding plot annotations (ggplotly can't do captions or subtitles)
              "RgoogleMaps", # for MaxZoom & MinZoom
              "geojsonio", # to test for presence of features
              "rnoaa", # to get NOAA climate data
              "leaflet.minicharts") 
       
           

installed_pkgs <- pkgs %in% installed.packages()
if (length(pkgs[!installed_pkgs]) > 0) install.packages(pkgs[!installed_pkgs], repos = "https://cloud.r-project.org", dep=TRUE) 
invisible(lapply(pkgs, library, character.only = TRUE))

options(shiny.maxRequestSize = 20*1024^2, 
        timeout = 300,
        stringsAsFactors = FALSE,
        DT.options = list(
          hover = TRUE,
          scrollX = TRUE,
          scrollY = TRUE,
          autoWidth = FALSE),
        # Header width doesn't match body width when this is set to TRUE. To fix, would need to include code to recalculate widths only after a tab is visible. If setting column widths, need to set autoWidth to TRUE
        dplyr.summarise.inform = FALSE
)
  
```

```{r css}
# This sizes and positions the custom gif loading images
tags$style("#gif_modal .modal-body {padding:0px}
            #gif_modal .modal-dialog {width:auto; display:inline-block; position:absolute; top:35%;left:50%; transform:translate(-50%, -50%) !important;}
")

# This expands initial map to fill screen
tags$style("initial_map {
           height: calc(100vh - 80px) !important;
           }")

# Call this to force an input value to reset to NULL
tags$script("
    Shiny.addCustomMessageHandler('setNull', function(variableName) {
      Shiny.setInputValue(id = variableName, value = null);
    });
  ")

# Call this to force an input value to reset to a specified value
tags$script("
    Shiny.addCustomMessageHandler('resetValue', function(message) {
      Shiny.setInputValue(message);
    });
  ")

# # This allows renderTables to scroll when overflow
# tags$style(".chart-wrapper {
#   overflow-x:scroll;
#   overflow-y:scroll;
# }")

# When an action button is disabled, text should be gray and button color light gray
tags$style(".btn.disabled {
  color:gray;
  background-color:light-gray;
}")

tags$style(".rank-list-title {
  font-size:14px;
  padding:4px;
}")

tags$style(".rank-list-item {
  font-size:14px;
  padding:4px;
}")

tags$style("table.dataTable tbody th, table.dataTable tbody td input.form-control {
    padding: 2px 5px; 
}") # reduce padding in data tables

tags$style(HTML(".shiny-output-error-validation {
  font-size:14px;
  color: #FF0000;
}")
) # validation text is in red. Could also add 'font-weight: bold;'

tags$style(".reactable {
font-size: 13px; 
}") # font size for reactable tables

tag.map.title <- tags$style(HTML("
  .leaflet-control.map-title { 
    transform: translate(-50%,20%);
    position: fixed !important;
    left: 50%;
    text-align: center;
    padding-left: 10px; 
    padding-right: 10px; 
    background: rgba(255,255,255,0.75);
    font-weight: bold;
    font-size: 28px;
  }
")) # add title to leaflet map

tags$style(".chart-stage-flex {
  overflow: scroll !important;
}") # Helps ensure data table bottoms don't get cut off


```

```{r generic_action_buttons}
# Action to cancel modal
observeEvent(eventExpr = input$button_cancelModal, {
  removeModal()
  })
```

```{r functions}
### FUNCTIONS ----
FuncAboutButton <- function(nam) {
  actionButton(nam, "   PAGE INSTRUCTIONS", icon = icon("question-sign", lib = "glyphicon"), width = "100%")
}

FuncShowWellPanel <- function(input_to_test, wp_to_toggle) {
  # Function to show or hide a well panel based on a checkbox selection
  #
  # Args:
  #   input_to_test:  The ID of the checkbox input, e.g., input$sel_ShowPanel
  #   wp_to_toggle:  ID of the well panel to toggle, e.g., wp_example
  #
  shiny::req(!is.null(rv$dat),!is.null(input_to_test))
  if(input_to_test) {
    shinyjs::showElement(wp_to_toggle)
    } else {
      shinyjs::hideElement(wp_to_toggle)
    }
  }

FuncAllNoneButtons <- function(cond, name_all, name_none) {
  # Function to create 'Select All' and 'Select None' action buttons
  #
  # Args:
  #   cond:  The input ID that needs to be defined for buttons to show (enter as input.XXX rather than as input$XXX)
  #   name_all:  ID to assign to 'Select All' button
  #   name_none:  ID to assign to 'Select None' button
  #
  conditionalPanel(
    condition = paste0("typeof ", cond, " !== 'undefined'"),
    actionButton(name_all, "Select All", style="color:black; display:inline-block; border:1px; padding:4px 12px;"),
    actionButton(name_none, "Select None", style="color:black; display:inline-block; border:1px; padding:4px 12px;")
  )
}

FuncCalcWaterSeasons <- function(dateVec){
  # Function to calculate water year from calendar date (modified from calcWaterSeasons function in package 'dataRetrieval')
  # POSIXlt years start at 100, POSIXlt months start at 0
  dateTimeVec <- as.POSIXlt(dateVec)
  calYear <- dateTimeVec$year + 1900
  calMon <- dateTimeVec$mon + 1
  
  # when the date is NA, it should not try to add 1
  whichPastOct <- calMon >= 10
  whichPastOct[is.na(whichPastOct)] <- FALSE
  
  # add one to the year if it is in October or after
  WaterSeasons <- calYear
  WaterSeasons[whichPastOct] <- calYear[whichPastOct] + 1
  
  return(WaterSeasons)
}

FuncBreakDates <- function(dat_df) {
  # Function to break dates into date categories
  #
  # Args:
  #   dat_df:  A data frame with the raw data. One column needs to be ActivityStartDate, which is date class with format yyyy-mm-dd
  #
  dat_df2 <- dat_df %>% 
    dplyr::mutate(
      YrDate = base::as.Date(cut(ActivityStartDate, breaks = "year")), # these maintain date class, so are useful for certain summaries
      MnthDate = base::as.Date(cut(ActivityStartDate, breaks = "month")),
      WkDate = base::as.Date(cut(ActivityStartDate, breaks = "week", start.on.monday = FALSE)), # Sunday start of week
      MeteoYr = as.integer(lubridate::year(ActivityStartDate)), # for other types of summaries
      WaterYr = as.integer(FuncCalcWaterSeasons(ActivityStartDate)),
      Season = factor(cut(lubridate::yday(ActivityStartDate),
                   breaks=c(-Inf, 59, 151, 243, 334, Inf),
                   labels=c("Winter","Spring","Summer", "Fall", "Winter")), levels = c("Spring","Summer", "Fall", "Winter")), # Meteorological Seasons: Spring=March 1 - May 31; Summer=June 1 - Aug 31; Fall=Sept1 - Nov30; Winter=Dec1 - Feb28
      Mnth = lubridate::month(ActivityStartDate, label = TRUE, abbr = TRUE),
      Wk = factor(lubridate::week(ActivityStartDate), levels = 1:52),
      DayOfYr = lubridate::yday(ActivityStartDate))
  dat_df2$Mnth = factor(dat_df2$Mnth, levels = levels(dat_df2$Mnth), ordered = FALSE)
  
  return(dat_df2)
}

FuncOrderCheck <- function(import = FALSE, filter_internal = FALSE, filter_external = FALSE, plot = FALSE) {

  # Function to check if data have been imported, filtered, and plot data summarized
    if(import) {
      shiny::validate(
     need(!is.null(rv$dat), message = "No data available. Please use the 'Get WQP Data' tab to first import or load water quality data."))}
  if(filter_internal) {
    shiny::validate(
    need(!is.null(rv_param_temp$subDat) & !is.null(rv_param_temp$subDatTypes), message = "From the left sidebar, choose a subset of data to work with"))}
  if(filter_external) {
    shiny::validate(
    need(!is.null(rv_param_temp$subDat) & !is.null(rv_param_temp$subDatTypes), message = "On the 'Define & Filter Data' page, please choose a subset of data to work with"))}
  if(plot) {
    shiny::validate(
    need(!is.null(rv_param_temp$plotDat), message = "On the 'Explore Data - Time Series' page, select characteristic set(s) and monitoring site(s) to plot and then click the green 'REFRESH PLOT DATA' button."))

  }
}

FuncCustomSeasons <- function(dat_df, seas) {
  # Function to assign USGS water year or custom seasons to ActivityStartDate
  #
  # Args:
  #   dat_df:  A data frame to modify. One column needs to be ActivityStartDate, which is date class with format yyyy-mm-dd
  #   seas: character string, "WaterSeasons" or "CustomSeasons"
  #
  dat_df$Season <- NA
  # assign the custom season names based on dates. Can't just use cut, in case the seasons aren't consecutive
  if(seas == "WaterSeasons") {
    df_CustomSeason <- data.frame(
      Name = c("Fall(WY)", "Winter(WY)", "Spring(WY)", "Summer(WY)"),
      RangeStart = as.Date("2018-01-01")-1 + c(274, 1, 91, 182),
      RangeEnd = as.Date("2018-01-01")-1 + c(265, 90, 181, 273))
  }
  if(seas == "CustomSeasons") {
    df_CustomSeason <- data.frame(
      Name = c(input$sel_Season1Name, input$sel_Season2Name, input$sel_Season3Name, input$sel_Season4Name),
      RangeStart = c(input$sel_Season1Range[1], input$sel_Season2Range[1], input$sel_Season3Range[1], input$sel_Season4Range[1]),
      RangeEnd = c(input$sel_Season1Range[2], input$sel_Season2Range[2], input$sel_Season3Range[2], input$sel_Season4Range[2]))
  }
  
  df_CustomSeason <- df_CustomSeason[df_CustomSeason$Name != "",] # if no name assigned, then it's not a season level
  for(i in 1:nrow(df_CustomSeason)) {
    Name <- df_CustomSeason$Name[i]
    StartDate <- lubridate::yday(df_CustomSeason$RangeStart[i])
    StartDate_LY <- lubridate::yday(gsub("^.{1,4}", "2000", df_CustomSeason$RangeStart[i])) # yday count is different for leap years
    EndDate <- lubridate::yday(df_CustomSeason$RangeEnd[i])
    EndDate_LY <- lubridate::yday(gsub("^.{1,4}", "2000", df_CustomSeason$RangeEnd[i])) # yday count is different for leap years
    
    
    if(StartDate < EndDate) {
      # for leap year
      dat_df$Season[lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) >= StartDate_LY & lubridate::yday(dat_df$ActivityStartDate) <= EndDate_LY] <- Name
      # for not leap year
      dat_df$Season[!lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) >= StartDate & lubridate::yday(dat_df$ActivityStartDate) <= EndDate] <- Name
    } else { # start yday is larger than end yday, it means it spans Dec 31-Jan 1
      # for leap year
      dat_df$Season[lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) >= StartDate_LY] <- Name
      dat_df$Season[lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) <= EndDate_LY] <- Name
      # for not leap year
      dat_df$Season[!lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) >= StartDate] <- Name
      dat_df$Season[!lubridate::leap_year(dat_df$ActivityStartDate) & lubridate::yday(dat_df$ActivityStartDate) <= EndDate] <- Name
    }
  }
  
  dat_df$Season <- factor(dat_df$Season, levels = df_CustomSeason$Name)
  return(dat_df)
}

FuncBaseMap <- function(maptype) {
    cbp1 <- c("#E69F00", "#56B4E9", "#009E73", "#CC79A7", "#0072B2", "#D55E00", "#999999", "#F0E442", "#000000", "chocolate4", "purple4", "chartreuse", "lightpink", "honeydew2") # Colorblind-friendly palette
  
  cbp1_org <- switch((length(unique(rv$sitesPointsSub$OrganizationFormalName)) <= length(cbp1)) + 1,  colorRampPalette(cbp1)(length(unique(rv$sitesPointsSub$OrganizationFormalName))), cbp1[1:length(unique(rv$sitesPointsSub$OrganizationFormalName))])
  
  rv_param_temp$palOrg <- colorFactor(palette = cbp1_org, domain = unique(rv$sitesPointsSub$OrganizationFormalName), levels = unique(rv$sitesPointsSub$OrganizationFormalName))
  
  iconGages = makeAwesomeIcon(
    text = fa("water"),
    iconColor = "black",
    markerColor = "blue")
  
  iconMeteo = makeAwesomeIcon(
    icon= "fa-cloud", 
    library = "fa", 
    squareMarker = TRUE, 
    markerColor = "white")
  
  iconCWA = makeAwesomeIcon(
    icon= "fa-building", 
    library = "fa", 
    markerColor = "lightgray")
  
  iconGagesSelected = makeAwesomeIcon(
      text = fa("water"),
      iconColor = "black",
      markerColor = "orange")
  
  iconMeteoSelected = makeAwesomeIcon(
      icon= "fa-cloud", 
      library = "fa", 
      squareMarker = TRUE, 
      markerColor = "orange")
  
  # Order map layers -- higher zIndex is on "top"
  map <- leaflet(options = leafletOptions(zoomControl = FALSE, zoomSnap = 0.25)) %>%
    addMapPane("pane_unitPoly", zIndex = 210) %>%
    addMapPane("pane_HUC", zIndex = 220) %>%
    addMapPane("pane_facilitiesPoints", zIndex = 225) %>%
    addMapPane("pane_meteoStations", zIndex = 230) %>%
    addMapPane("pane_gageStations", zIndex = 235) %>%
    addMapPane("pane_meteoStations_selected", zIndex = 240) %>%
    addMapPane("pane_gageStations_selected", zIndex = 245) %>%
    addMapPane("pane_availableStations", zIndex = 255) %>%
    addMapPane("pane_selectedStreamlines", zIndex = 257) %>%
    addMapPane("pane_selectedStations", zIndex = 260) %>% # always keep selected monitoring station points on "top" of map layers (highest zIndex)
    addMapPane("pane_selectedOrigin", zIndex = 265) %>%
    addTiles(options = tileOptions(noWrap = TRUE), group = "Street") %>%
    addProviderTiles("Esri.WorldImagery", options = providerTileOptions(noWrap = TRUE), group="Satellite") %>%
    addPolygons(data = rv$unitPoly, group = "NPS unit", color = "black", fillColor = "yellow", fillOpacity = 1, weight = 1, options = pathOptions(pane = "pane_unitPoly")) %>% # park unit outline
    addPolygons(data = rv[[rv$userSelect$sel_HUClevel]], group = rv$userSelect$sel_HUClevel, color = "blue", fillColor = "lightblue", fillOpacity = 0.3, weight = 0.5, layerId = ~HUC, options = pathOptions(pane = "pane_HUC")) %>% # HUC polygons
    addScaleBar() %>%
    addControl(rv$parkID, position = "topleft") # add 4-letter UNIT code on map)
  
  # Conditional mapping (when data are available)
  
  if(maptype == "initial") { # These are specific to the initial map
    if(length(rv$sitesPointsSub[rv$sitesPointsSub@data$OrganizationFormalName %in% rv$userSelect$sel_Organization,]) > 0) { # Available water quality stations
  map %<>% addCircleMarkers(data = rv$sitesPointsSub[rv$sitesPointsSub@data$OrganizationFormalName %in% rv$userSelect$sel_Organization,], group = "Available monitoring sites", lat = ~LatitudeMeasure, lng = ~LongitudeMeasure, label = ~SITELAB, popup = ~SITEPOP, radius = 4, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 0.8, stroke = TRUE, weight = 1, color = ~rv_param_temp$palOrg(OrganizationFormalName), opacity = 0.7, options = pathOptions(pane = "pane_availableStations"))} # WQ stations
    
      if(!is.null(rv$selectedStations) & !is.null(rv$userSelect$sel_Organization)) {
    if(nrow(rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier %in% rv$selectedStations$MonitoringLocationIdentifier[rv$selectedStations$OrganizationFormalName %in% rv$userSelect$sel_Organization],]) > 0) { # Selected stations are outlined in white (data to be imported)
    map %<>%
      addCircleMarkers(data = rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier %in% rv$selectedStations$MonitoringLocationIdentifier[rv$selectedStations$OrganizationFormalName %in% rv$userSelect$sel_Organization],], group = "Selected monitoring sites", lat = ~LatitudeMeasure, lng = ~LongitudeMeasure, label = ~SITELAB, popup = ~SITEPOP, radius = 8, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 0.8, stroke = TRUE, weight = 4, color = "white", opacity = 1, options = pathOptions(pane = "pane_selectedStations"))
    }
      }
    
    if(!is.null(rv$selectedOriginStation) & !is.null(rv$userSelect$sel_SelectMethod)){ # the origin station for up-down selection is outlined in red
    if(rv$userSelect$sel_SelectMethod=="methodDist") {
      if(nrow(rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier == rv$selectedOriginStation@data$identifier,]) > 0) {
      map %<>% 
        addCircleMarkers(data = rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier == rv$selectedOriginStation@data$identifier,], group = "Selected monitoring sites", lat = ~LatitudeMeasure, lng = ~LongitudeMeasure, label = ~SITELAB, popup = ~SITEPOP, radius = 8, fillOpacity = 0, stroke = TRUE, weight = 4, color = "red", opacity = 1, options = pathOptions(pane = "pane_selectedOrigin"))}
    }
    }
    
  }
  
  # These are for any map type
   if(rv$userSelect$sel_SelectMethod=="methodHuc" & !is.null(rv$selectedHucs)) { # layer the selected polygons on map, if selection method is by HUC 
    map %<>%
      addPolygons(data = rv[[rv$userSelect$sel_HUClevel]][rv[[rv$userSelect$sel_HUClevel]]$HUC %in% rv$selectedHucs,], group = rv$userSelect$sel_HUClevel, color = "blue", fillColor = "lightblue", fillOpacity = 0.7, weight = 1.5, layerId = ~HUC, options = pathOptions(pane = "pane_HUC"))
   }
  
  if(!is.null(rv$selectedOriginStation) & !is.null(rv$userSelect$sel_SelectMethod)){
    if(rv$userSelect$sel_SelectMethod=="methodDist") {
    
    if(!is.null(rv$selectedDownstreamLines)) {
      map %<>%
        addPolylines(data = rv$selectedDownstreamLines, color = "#660000", weight = 2, opacity = 1, group = "Selected monitoring sites", options = pathOptions(pane = "pane_selectedStreamlines")) # downstream lines in brown
      }
    
    if(!is.null(rv$selectedUpstreamLines)) {
    map %<>%
        addPolylines(data = rv$selectedUpstreamLines, color = "#FFFFFF", weight = 2, opacity = 1, group = "Selected monitoring sites", options = pathOptions(pane = "pane_selectedStreamlines")) # upstream lines in blue
  }
    }
}
          
  if(!is.null(rv$gageStations)) { # Add USGS gage (streamflow) stations only if found
    map %<>%
      addAwesomeMarkers(icon = iconGages, data = rv$gageStations, lng = ~Longitude, lat = ~Latitude, group = "Gage stations", label = ~GAGELAB, popup = ~GAGEPOP, options = pathOptions(pane = "pane_gageStations")) # selected stream gage stations
  }

  if(!is.null(rv$meteoStations)) { # Add weather stations only if found
    map %<>%
      addAwesomeMarkers(icon = iconMeteo, data = rv$meteoStations, lng = ~longitude, lat = ~latitude, group = "Weather stations", label = ~METEOLAB, popup = ~METEOPOP, options = pathOptions(pane = "pane_meteoStations")) # weather stations
  }
  
  if(!is.null(rv$facilitiesPointsSub)) { # Add EPA-monitored discharge facilities only if found
    map %<>%
      addAwesomeMarkers(icon = iconCWA, data = rv$facilitiesPointsSub, group = "Discharge facilities", label = ~FACLAB, popup = ~FACPOP)
    }
  
  if(!is.null(rv$gageStations) & !is.null(rv$selectedGages)) { # Add selected USGS gage stations only if found
  if(all(rv$selectedGages$GageID %in% rv$gageStations$GageID)) { 
    
    map %<>%
      addAwesomeMarkers(icon = iconGagesSelected, data = rv$selectedGages, lng = ~Longitude, lat = ~Latitude, group = "Gage stations", label = ~GAGELAB, popup = ~GAGEPOP, options = pathOptions(pane = "pane_gageStations_selected"))
  }}
  
  if(!is.null(rv$meteoStations) & !is.null(rv$selectedMeteo)) {
    if(all(rv$selectedMeteo$MeteoID %in% rv$meteoStations$MeteoID)) {
      map %<>%
        addAwesomeMarkers(icon = iconMeteoSelected, data = rv$selectedMeteo, lng = ~longitude, lat = ~latitude, group = "Weather stations", label = ~METEOLAB, popup = ~METEOPOP, options = pathOptions(pane = "pane_meteoStations_selected"))
    }}
  return(map)
}

FuncRefreshFilterShowOptions <- function(set_value) {
  
  updateCheckboxInput(session,
                      "sel_FilterSamplingChars",
                      # label = "Show options to filter by sampling characteristics",
                      value = set_value)
  
  updateCheckboxInput(session,
                      "sel_FilterOrg",
                      # label = "Show options to filter by organization",
                      value = set_value)
  
  # updateCheckboxInput(session,
  #                     "sel_FilterWQChar",
  #                     # label = "Show options to filter by water quality characteristic",
  #                     value = set_value)
}

FuncUpdateHome <- function() {
  updateTextInput(session,
                  "sel_UnitCode",
                  placeholder = "----",
                  value = "")
  
  updateDateInput(session,
                  "sel_ImportStartDate", 
                  value = "1980-01-01")
  
  updateDateInput(session,
                  "sel_ImportEndDate", 
                  value = Sys.Date())
  
  updateNumericInput(session,
                     "sel_MinActivities",
                     value = 5)
  
  updateCheckboxGroupInput(session,
                           "sel_SiteType",
                           selected = c("Stream", "Estuary", "Spring"))
  
  updateSliderInput(session,
                    "sel_MapZoom", 
                    value = NULL)
  
  updateRadioButtons(session,
                     "sel_HUClevel",
                     selected = "HUC10")
  
  updateRadioButtons(session,
                     "sel_SelectMethod",
                     selected = "methodHuc")
  
  updateTextInput(session,
                  "sel_OriginStationID",
                  value = "")
  
  updateCheckboxGroupInput(session,
                           "sel_Organization",
                           choices = NULL,
                           selected = NULL)
  
  updateCheckboxGroupInput(session,
                           "sel_Gages",
                           choices = NULL,
                           selected = NULL)
  
  updateCheckboxGroupInput(session,
                           "sel_Meteo",
                           choices = NULL,
                           selected = NULL)
  
  # Reset map center and map bounds to NULL
  session$sendCustomMessage(type = "setNull", message = "map_center") 
  session$sendCustomMessage(type = "setNull", message = "map_bounds")
}

FuncUpdateFilter <- function() {
  updateRadioButtons(session,
                     "sel_DefineSeasons",
                     selected = "MeteoSeasons")
  
  updateSliderInput(session,
                    "sel_SeasonsStart",
                    value = as.Date("2018-01-01"))
  
  updateTextInput(session,
                  "sel_Season1Name",
                  value = "")
  
  updateTextInput(session,
                  "sel_Season2Name",
                  value = "")
  
  updateTextInput(session,
                  "sel_Season3Name",
                  value = "")
  
  updateTextInput(session,
                  "sel_Season4Name",
                  value = "")
  
  updateSliderInput(session,
                    "sel_YrRange",
                    min = NULL, 
                    max = NULL, 
                    step = NULL, 
                    value = NULL)
  
  updateNumericInput(session,
                     "sel_MinYrs",
                     value = 5)
  
  updateNumericInput(session,
                     "sel_MinStations",
                     value = 3)
  
  updateCheckboxGroupInput(session,
                           "sel_ActivityType",
                           selected = NULL)
  
  updateCheckboxGroupInput(session,
                           "sel_ResultStatus",
                           selected = NULL)
  
  updateCheckboxInput(session,
                      "sel_LimitDepths",
                      value = FALSE)
  
  updateRadioButtons(session,
                     "sel_DepthUnit",
                     choices = sort(unique(rv$dat$ActivityDepthHeightMeasure.MeasureUnitCode)),
                     selected = sort(unique(rv$dat$ActivityDepthHeightMeasure.MeasureUnitCode))[1])
  
  updateCheckboxGroupInput(session,
                           "sel_SummaryOrg",
                           selected = sort(unique(rv$dat$OrganizationFormalName)))
  
  updateNumericInput(session,
                     "sel_MinStations",
                     value = 3)
}

FuncUpdateTSMap <- function() {
  if(!is.null(rv_param_temp$plotDat)) {
     updateSliderTextInput(session,
                        "sel_SurvYr",
                        selected = max(rv_param_temp$plotDat$Yr, na.rm = TRUE))
  }
   
  if(!is.null(rv$unitPoly)) {
    updateSliderInput(session,
                        "sel_ParamMapZoom",
                        selected = min(RgoogleMaps::MaxZoom(lonrange = rv$unitPoly@bbox["x",], latrange = rv$unitPoly@bbox["y",])) - 1)
  }
}

FuncUpdateTSPlots <- function() {
  updateSelectInput(session,
                    "sel_ShowThresholds",
                    selected = "showthresh_none")
  
  updateSelectInput(session,
                    "sel_AddGagePrecip",
                    selected = "none")
  
  updateSelectInput(session,
                    "sel_YScale",
                    selected = "identity")
  
  updateSelectInput(session,
                    "sel_Categ",
                    selected = "none")
  
  updateSelectInput(session,
                    "sel_ParamMapShow",
                    selected = "show")
  
  updateCheckboxInput(session,
                      "sel_FreeY",
                      selected = FALSE)
  
  updateCheckboxInput(session,
                      "sel_AddQuantile",
                      selected = TRUE)
  
  updateCheckboxInput(session,
                      "sel__PlotByStation",
                      selected = TRUE)
  
  updateSliderInput(session,
                    "sel_MapPointSize",
                    selected = 10)
}


FuncUpdateInputsOther <- function() {
    FuncUpdateFilter()
    FuncRefreshFilterShowOptions(set_value = TRUE)
    
    updateSelectInput(session,
                    "sel_ShowChar",
                    choices = NULL,
                    selected = NULL)
    
    updateCheckboxGroupInput(session,
                           "sel_ShowStations",
                           choices = NULL,
                           selected = NULL)
    
    updateRadioButtons(session,
                       "sel_Categ",
                       choices = "none",
                       selected = "none")
}

FuncUpdateUserSelect <- function(inputs_to_update) {
  shiny::req(!is.null(rv$dat))
  input_list <- isolate(reactiveValuesToList(input)) # difficulties indexing reactive list, so convert to unreactive list first
  replacement_list <- input_list[inputs_to_update]
  names(replacement_list) <- inputs_to_update # adds list element name, even for NULL elements
  rv$userSelect <- modifyList(rv$userSelect, replacement_list, keep.null = TRUE) # update only the list elements in replacement_list
}
  
FuncDataTypes <- function(dat) {
  # Function to identify which characteristic names have non-numeric entries, and what those entries are
  #
  # Args:
  #   dat: The imported data frame. Requires columns CharacteristicName and ResultMeasureValue
  # 
  # Returns:
  #   Data frame with each characteristic name, best guess of data type (categorical or numeric), and the non-numeric entries
  temp_datatype <- dat %>%
    dplyr::select(CharacteristicName, ResultMeasureValue) %>%
    dplyr::group_by(CharacteristicName)
  
  temp_datatype_count <- temp_datatype %>%
    dplyr::summarise(NumRecords = n()) %>%
    dplyr::select(CharacteristicName, NumRecords)
  
  temp_datatype_categ <- temp_datatype %>%
    group_map(~sort(unique(na.omit(.x$ResultMeasureValue[which(is.na(suppressWarnings(as.numeric(gsub(",", "", .x$ResultMeasureValue)))))])))) # identify all non-numeric, non-NA entries for each characteristic. If it's a number with comma, removes the comma and still counts it as a number
  
  df_datatype <- as.data.frame.AsIs(temp_datatype_categ, stringsAsFactors=FALSE) %>% # unfortunately, I can't get the data table edit function to work with factor class variables
    dplyr::mutate(CharacteristicName = unique(dat$CharacteristicName),
                  DataType = ifelse(temp_datatype_categ %in% c("character(0)", "numeric(0)", "logical(0)"), "numeric", "categorical")) %>%
    rowwise() %>%
  mutate(NonNumericEntries = paste(temp_datatype_categ, collapse = " // ")) %>% # make sure using unique separator that wouldn't be part of any entry
    dplyr::select(-temp_datatype_categ) %>%
    dplyr::left_join(temp_datatype_count, by = "CharacteristicName") %>%
    arrange(DataType, CharacteristicName)
  df_datatype$DataType <- factor(df_datatype$DataType, levels = c("categorical", "numeric")) # only allows these entries
  return(df_datatype)
}

FuncFilterDat <- function() {
  # Function to filter data based on user input on filter page of dashboard. Add custom seasons, if applicable.
  #
  # Returns:
  #   Assigns to rv_param_temp$subDat, rv_param_temp$subDatYears
  #

  shiny::req(!is.null(rv$dat), !is.null(rv$userSelect$sel_Organization))
  if(all(unique(rv$dat$OrganizationFormalName) %in% rv$userSelect$sel_Organization)==FALSE) {
    rv_param_temp$subDatYears <- NULL
    rv_param_temp$subDat <- NULL
    } else {
      
      shiny::req(!is.null(input$sel_MinYrs), !is.null(input$sel_SummaryParam), !is.null(input$sel_SummaryOrg), !is.null(input$sel_YrRange), !is.null(input$sel_ActivityType), !is.null(input$sel_ResultStatus), !is.null(input$sel_DefineSeasons))
      
      rv_param_temp$seasonType <- switch(input$sel_DefineSeasons, MeteoSeasons = "Calendar Year (starts Jan. 1)", WaterSeasons = "Water Year (starts Oct. 1)", CustomSeasons = paste0("Custom Year (starts ", as.character(input$sel_Seasons, format="%b %d"), ")"))
                                
      filterDat <- rv$dat 
      if(input$sel_DefineSeasons=="MeteoSeasons") {
        filterDat$Yr <- as.integer(filterDat$MeteoYr)
        filterDat$Mnth <- factor(filterDat$Mnth,levels(rv$dat$Mnth))
      } else {
        filterDat$Yr <- as.integer(filterDat$WaterYr)
        filterDat$Mnth <- factor(filterDat$Mnth,levels(rv$dat$Mnth)[c(10,11,12,1:9)])
      }
      
      filterDat %<>%
        dplyr::filter(Yr >= as.integer(input$sel_YrRange[1]) & Yr <= as.integer(input$sel_YrRange[2]) & OrganizationFormalName %in% input$sel_SummaryOrg & CharacteristicName %in% input$sel_SummaryParam & ActivityTypeCode %in% input$sel_ActivityType & ResultStatusIdentifier %in% input$sel_ResultStatus)
      
      # # If filtering by depth
      # if(nrow(filterDat) > 0 & !is.null(input$sel_LimitDepths)) {
      # if(input$sel_LimitDepths==TRUE & !is.null(input$sel_DepthUnit) & !is.null(input$sel_MinDepth) & !is.null(input$sel_MaxDepth)) {
      #   filterDat$ActivityDepthHeightMeasure.MeasureValue <- as.numeric(filterDat$ActivityDepthHeightMeasure.MeasureValue) # make sure variable hasn't been classified as non-numeric due to text entries
      #   filterDat %<>%
      #     dplyr::filter(ActivityDepthHeightMeasure.MeasureUnitCode == input$sel_DepthUnit & ActivityDepthHeightMeasure.MeasureValue <= input$sel_MinDepth & ActivityDepthHeightMeasure.MeasureValue >= input$sel_MaxDepth)
      # }
      # }
      
      # Create ResultMeasureValue_replaced column that replaces values not detected
      
  filterDat$ResultMeasureValue_replaced <- as.numeric(filterDat$ResultMeasureValue)
  filterDat$ResultMeasureValue_replaced[filterDat$ResultDetectionConditionText != "Detected and Quantified" & is.na(filterDat$ResultMeasureValue) & !is.na(filterDat$DetectionQuantitationLimitMeasure.MeasureValue)] <-
      as.numeric(filterDat$DetectionQuantitationLimitMeasure.MeasureValue[filterDat$ResultDetectionConditionText != "Detected and Quantified" & is.na(filterDat$ResultMeasureValue) & !is.na(filterDat$DetectionQuantitationLimitMeasure.MeasureValue)]) # create a column in which the detection limit replaces NA, for records where result was above or below detection limit--this column will be used to calculate probability quantiles <<<<<<<<<<<<<<< INCLUDE THIS EXPLANATION IN DOCUMENTATION
      
  # filterDat %<>% dplyr::filter(!is.na(ResultMeasureValue_replaced)) 
  
      # Add threshold columns
      filterDat$ThreshCateg <- NA
    if(!is.null(rv_param_temp$threshList)) {
      
      for (t in names(rv_param_temp$threshList)) {
        which_rows <- which(filterDat$CharacteristicName == rv_param_temp$threshList[[t]]$CharacteristicName & filterDat$ResultMeasure.MeasureUnitCode == rv_param_temp$threshList[[t]]$ResultMeasure.MeasureUnitCode)
        if(length(which_rows) > 0) {
        filterDat$ThreshCateg[which_rows] <- as.character(cut(as.numeric(filterDat$ResultMeasureValue_replaced[which_rows]), breaks = rv_param_temp$threshList[[t]]$cut_breaks, labels = rv_param_temp$threshList[[t]]$cut_categ))
        }
      }
    } 
      
      # Assign custom seasons
      if(nrow(filterDat) > 0 & input$sel_DefineSeasons %in% c("WaterSeasons", "CustomSeasons"))
        {
        filterDat <- FuncCustomSeasons(dat_df = filterDat, seas = input$sel_DefineSeasons)
        }
      rv$userSelect$sel_DefineSeasons <- input$sel_DefineSeasons
      
      if(nrow(filterDat) > 0) {
        filterYears <- filterDat %>%
          dplyr::select(CharacteristicName, MonitoringLocationIdentifier, Yr) %>%
          dplyr::group_by(CharacteristicName, MonitoringLocationIdentifier) %>%
          dplyr::summarize(StartYr = as.integer(min(Yr, na.rm = TRUE)),
                           EndYr = as.integer(max(Yr, na.rm = TRUE)),
                           TotalSurveyYrs = dplyr::n_distinct(Yr),
                           NumRecords = n()) %>%
          dplyr::filter(TotalSurveyYrs >= input$sel_MinYrs)
      
        if(nrow(filterYears) > 0) { # if none of the data meet the minimum years criterion, these entries will be NULL
          rv_param_temp$subDat <- filterDat %>%
            right_join(filterYears[, c("CharacteristicName", "MonitoringLocationIdentifier")], by = c("CharacteristicName", "MonitoringLocationIdentifier")) # just keep the ones that met the data filter criteria for total survey years, so these are the raw data that are summarized in rv_param_temp$subDatYears
          rv_param_temp$subDatYears <- filterYears
  
        } else {
          rv_param_temp$subDat <- NULL
          rv_param_temp$subDatYears <- NULL
        }
      } else {
        rv_param_temp$subDat <- NULL
        rv_param_temp$subDatYears <- NULL
      }
      }
}

FuncPlotlyHeatMap <- function(dat, y_name, facet_by_name, legend_name, is_discrete = FALSE, indiv_scale = FALSE) {
  # Function to create plotly heatmaps. X-axis is always year. Using plot_ly because ggplotly can be slow for interactive heat plots b/c it doesn't recognize the input as a heatmap and creates a scatterplot where each rectangle is drawn separately with all the necessary attributes.
  #
  # Args:
  #   dat: Data frame with these columns: Yr (for x-axis), Y, FillCol, FacetBy, HoverLabel. Both 'X' and 'FacetBy' should be factor class with levels specified.
  #   y_name, facet_by_name, legend_name: Axis labels and facet and legend titles
  #   is_discrete: TRUE if legend should be discrete (for counts), not continuous
  #   indiv_scale: TRUE if each plot gets its own scale because the plots represent different water quality characteristics
  #
  # Returns:
  #   Legend and heat map
  #

  # Fill missing values
  template <-
    expand_grid(FacetBy = factor(levels(dat$FacetBy), levels = levels(dat$FacetBy)), Y = factor(levels(dat$Y), levels = levels(dat$Y)), Yr = min(dat$Yr, na.rm = TRUE):max(dat$Yr, na.rm = TRUE)) %>%
    left_join(dat[c("FacetBy", "Y", "Yr", "FillCol", "HoverLabel")], by = c("FacetBy", "Y", "Yr")) %>%
    dplyr::arrange(FacetBy, Y, Yr)

  # Calculate total and relative heights
  total_page_ht <- max(2000, 60 + (30 * length(levels(dat$FacetBy)) * length(levels(dat$Y)))+15 + 30 * length(levels(dat$FacetBy)))
  # total_page_ht <- 5000

  # Create color scale
  min_colorval <- min(template$FillCol, na.rm = TRUE)
  max_colorval <- max(template$FillCol, na.rm = TRUE) # make sure the range of color values is the same across all subplots
  template_cols <- viridis(n = max_colorval - min_colorval + 1, alpha = 1, begin = 0, end = 1, direction = -1)

  # Create separate legend - hacky legend because plotly heatmaps can't generate horizontal colorbars
  shared_legend <- grid.arrange(ggpubr::as_ggplot(
    get_legend(
      ggplot(template, aes(x = Yr, y = Y, fill = FillCol)) +
        geom_tile() +
        scale_fill_viridis_c(name = legend_name, direction=-1, begin = 0, end = 1) +
        theme(legend.position = "top",
              legend.key.width = unit(1, "cm"),
              legend.text = element_text(size = 16, margin = margin(r = 2, unit = "cm")),
              legend.title = element_text(size = 16)
        )
      )
    )
  )

  heatplot_list <- lapply(levels(template$FacetBy), function(i) {
    # Data for this plot
    subdat <- subset(template, FacetBy == i)
    mat_values <- matrix(dplyr::pull(subdat, FillCol),
                         nrow=length(unique(subdat$Y)),
                         byrow = TRUE,
                         dimnames = list(
                           levels(template$Y),
                           min(template$Yr, na.rm = TRUE):max(template$Yr, na.rm = TRUE)
                           )
    )
    mat_hover <- matrix(dplyr::pull(subdat, HoverLabel), nrow=length(unique(subdat$Y)), byrow = TRUE)
 shiny::req(!is.null(subdat), !is.null(mat_hover))
  # Create heatmap
    # none of the margin arguments are helpful
    if(sum(!is.na(subdat$FillCol)) > 0) {
      heat_subplot <- heatmaply(
        mat_values,
        column_text_angle = 0,
        grid_gap = 1,
        colors = template_cols,
        limits = c(min_colorval, max_colorval),
        dendrogram = "none",
        # main = paste0("# of Survey Events, by Year and ", y_name, " for each ", facet_by_name),
        subplot_margin = 15,
        margins = c(15, 15, 15, 15),
        ylab = y_name,
        xlab = rv_param_temp$seasonType,
        xaxis_font_size = "22pt",
        yaxis_font_size = "22pt",
        height = total_page_ht,
        hide_colorbar = TRUE,
        custom_hovertext = mat_hover,
        key.title = "# of Survey Events",
        plot_method = "plotly") %>%
        add_annotations( # add plot subtitle
          text = paste0(facet_by_name, ":  ", i),
          xref = "paper",
          yref = "paper",
          x = -0.02,
          y = 1,
          xanchor = "left",
          yanchor = "bottom", # y anchor uses 'middle', x anchor uses 'center'
          showarrow = FALSE,
          font=list(size=16, family = "Arial")
        )
      }
    }) %>% purrr::discard(is.null) # remove null list elements

  shiny::req(!is.null(heatplot_list))

  # Format heatmap page
  plotly_heatmap <-
     plotly::subplot(
      heatplot_list,
      nrows = length(heatplot_list),
      shareX = TRUE, # if set to FALSE, x-axis labels will overlap subplot title
      shareY = FALSE,
      titleX = TRUE,
      titleY = FALSE,
      heights = rep(1/length(heatplot_list), length(heatplot_list)),
      which_layout = 1
    ) %>%
      layout(
          margin = list(
          t=45,
          b=15,
          l= 80,
          r=40)
          )
  return_list <- list(shared_legend = shared_legend, plotly_page = plotly_heatmap)
  return(return_list)
}

FuncPlotHeatMap <- function(dat, y_name, legend_name) {
  # Function to create static heatmaps. X-axis is always year.
  #
  # Args:
  #   dat: Data frame with these columns: Yr (for x-axis), Y, FillCol, MonitoringLocationIdentifier.
  #   y_name, legend_name: Axis labels and legend titles
  #   
  # Returns:
  #   Static heat maps
  #

  # Create color scale
    min_colorval <- min(dat$FillCol, na.rm = TRUE)
    max_colorval <- max(dat$FillCol, na.rm = TRUE) # make sure the range of color values is the same across all plots
    template_cols <- viridisLite::viridis(n = max_colorval - min_colorval + 1, alpha = 1, begin = 0, end = 1, direction = -1)
  
    # Calculate relative heights
    sites_per_char <- dat %>% dplyr::distinct(CharacteristicName, MonitoringLocationIdentifier) %>% dplyr::count(CharacteristicName) %>% dplyr::pull(.)
    
    temp_distinct <- dat %>%
      dplyr::select(CharacteristicName, MonitoringLocationIdentifier, TimeUnit) %>% dplyr::distinct()
    rel_char_hts <- prop.table(250 + (length(unique(dat$TimeUnit)) + 1) * 30 * sites_per_char) # 250 for characteristic title and plot legend

  # A ggplot object with NO data.  Omit the characteristic from the facet_grid call
  p <- ggplot() +
    aes(x = Yr, y = TimeUnit, fill = FillCol) +
    geom_tile(color = "gray") +
    geom_text(aes(label = FillCol, colour = ifelse(FillCol > 5, "white", "black"))) +
    scale_colour_manual(values=c("white"="white", "black"="black"), guide = "none") +
    xlab(rv_param_temp$seasonType) +
    scale_x_continuous(breaks = (min(dat$Yr, na.rm = TRUE)+1):(max(dat$Yr, na.rm = TRUE)-1), limits = c(min(dat$Yr, na.rm = TRUE), max(dat$Yr, na.rm = TRUE))) +
    scale_y_discrete(limits = rev) +
    scale_fill_viridis_c(direction = -1, na.value = "white", limits=c(1, 12), oob=scales::squish, breaks = seq(1, 12, by = 2), name = legend_name) +
    theme_bw(base_size = 14) +
    facet_wrap(~MonitoringLocationIdentifier, ncol =1) +
    theme(legend.position="top",
          plot.title = element_text(size = 22),
          axis.text.x = element_text(angle = 90, hjust = 1)) +
    theme(plot.margin=unit(c(3,3,1,2),"lines"))
cat("779")
  # Build a separate graphic for each Characteristic
  char_list <- lapply(sort(unique(dat$CharacteristicName)), function(i) {
    p %+% 
      dplyr::filter_(dat, ~ CharacteristicName == i) + ggtitle(paste0(i, " (# of surveys per ", input$sel_TimeSubunit, ")"))
    })
  cat("785")
  # Build as Grobs and plot via gridExtra::grid.arrange
  final_heat_plots <- char_list %>%
    lapply(ggplotGrob) %>%
    arrangeGrob(grobs = ., heights = rel_char_hts) %>%
    grid.arrange(., ncol = 1)
cat("791")
  return(final_heat_plots)
}

FuncParamAvailSites <- function(sel) {
  shiny::req(!is.null(rv$sitesPointsSub), !is.null(rv_param_temp$subDat))
  if(sel == "by_station") {
    avail_sites <- rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier %in% unique(rv_param_temp$subDat$MonitoringLocationIdentifier),]
  } 
  if(sel == "by_char") {
    shiny::req(!is.null(input$sel_ShowChar))
    avail_sites <- rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier %in% unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowChar]),]
    
  }
    return(avail_sites)
}

FuncPlotlyPieMatrix <- function(dat, discrete_cols, discrete_levels, plot_title) {
  # Function to create plotly pie chart matrix of Threshold or Percentile categories, grouped by monitoring site (row) and year (col)
  #
  # Args:
  #   dat:  Plot data with percentile/threshold classifications
  #   discrete_cols: For discrete fill, the vector of colors
  #   discrete_levels: For discrete fill, the levels corresponding with colors
  #   plot_title: Title for plot page
  #
  # Returns:
  #   Page of plotly pie charts
  #
  fig <- plot_ly(textfont = list(size = 25))
  colors_list <- split(discrete_cols, discrete_levels)
  m <- list(
    l = 300,
    r = 90,
    b = 100,
    t = 100,
    pad = 0
  )
  
  dat$Color <- dplyr::recode(dat$CategVar, !!!colors_list)
  yr_vec <- seq(from = min(dat$Yr, na.rm = TRUE), to = max(dat$Yr, na.rm = TRUE), by = 1)
  
  
  for(row_num in 1:length(unique(dat$RowLev))) {
    row_filter <- sort(unique(dat$RowLev))[row_num]
    for(yr_num in 1:length(yr_vec)) {
      this_yr <- yr_vec[yr_num]
      pie_dat = subset(dat, RowLev == row_filter & Yr == this_yr)
      if(nrow(pie_dat)>0) {  
      fig <- fig %>% 
        add_pie(data = pie_dat,
                name = paste0(row_filter, "_", this_yr),
                labels = ~CategVar, 
                values = ~n,
                textposition = 'inside',
                textinfo = 'label+percent',
                insidetextfont = list(color = switch(("yellow" %in% discrete_cols)+1, "white", "black")),
                hoverinfo = 'text',
                text = ~HoverLabel,
                marker = list(colors = ~Color, line = list(color = '#FFFFFF', width = 1)),
                domain = list(row = row_num-1, column = yr_num-1))
    }
  }
  }
  
  width_px <- 390 + (110 * length(yr_vec)) # this is the plot width (paper)
  height_px <- 200 + (110 * length(unique(dat$RowLev))) # this is the plot height (paper)

  yr_seq_px <- seq(55, width_px-390, by = 110)/(110 * length(yr_vec)) # this is where year labels should align on x-axis, when reference is "paper"
  y_seq_px <- seq(55, height_px-55, length.out = length(unique(dat$RowLev)))/height_px
  title_loc <- 1 + (90/height_px) #it's into the top margin space, when reference is "container"
  legend_loc <- 1 + (50/height_px)
  yrs_loc_bottom <- -1 * (50/height_px)
  
  yr_labels_bottom <- list(
  text = as.list(as.character(yr_vec)),
  xref = "paper",
  yref = "container",
  yanchor = "center",
  xanchor = "center",
  font =list(size = 14),
  align = "right",
  x = yr_seq_px,
  y = yrs_loc_bottom,
  showarrow = FALSE)
  
  y_labels_left <- list(
    text = as.list(sort(unique(dat$RowLev), decreasing = TRUE)),
    xref = "paper",
    yref = "paper",
    xanchor = "right",
    yanchor = "center",
    font =list(size = 14),
    align = "center",
    x = -0.02,
    y = y_seq_px,
    showarrow = FALSE)
  
  fig_final <- fig %>% layout(
    margin = m,
    title = list(
      text = plot_title,
      x = 0.5,
      y = title_loc,
      xref = "container", # gets cut off if referenced to the plot only ("paper")
      yref = "paper",
      xanchor = "center",
      yanchor = "center"),
    showlegend = TRUE,
    legend = list(
      orientation = "h",
      x = 0.5,
      xref = "container",
      yref = "paper",
      xanchor = "center",
      y = legend_loc,
      yanchor = "center"),
    grid=list(
      rows=length(unique(dat$RowLev)),
      columns=length(yr_vec)),
    width = width_px,
    height = height_px,
    autosize = FALSE,
    annotations = y_labels_left) 
  
  fig_final <- fig_final %>% layout(annotations = yr_labels_bottom)

  fig_final
  return(fig_final)
}

FuncPlotDat <- function() {
  # Function to format plot data based on user selections on plot page
  #
  # Returns:
  #   Formatted plot data

  # Filter plotting data by user inputs
  plotDat <- rv_param_temp$subDat %>%
    dplyr::select(ActivityStartDate, CharacteristicName, CharacteristicSet, DetectionQuantitationLimitMeasure.MeasureValue, MonitoringLocationIdentifier, OrganizationFormalName, ResultDetectionConditionText, DetectionQuantitationLimitTypeName, ResultMeasureValue, ResultMeasureValue_replaced, ResultMeasure.MeasureUnitCode, ResultSampleFractionText, ThreshCateg, YrDate, MnthDate, WkDate, Yr, Season, Mnth, Wk, DayOfYr) %>% # just keep these columns
    dplyr::filter(MonitoringLocationIdentifier %in% rv_param_temp$showStations & CharacteristicSet %in% rv_param_temp$showCharSets)
  plotDat$ResultMeasureValue <- as.numeric(plotDat$ResultMeasureValue)
  plotDat$DetectionQuantitationLimitMeasure.MeasureValue <- as.numeric(plotDat$DetectionQuantitationLimitMeasure.MeasureValue)
  
    # If coloring by categorical characteristics
    if(!is.null(input$sel_Categ)) {
      if(input$sel_Categ != "none") {
        if(rv_param_temp$plotSummarizeBy == "by_char") {
          shiny::validate(
            need(input$sel_PlotByStation == TRUE, message = "Cannot color points by a categorical characteristic when multiple monitoring sites are combined in a single plot. Please mark the checkbox for 'Show one monitoring site per plot'"))
        }
        shiny::req(!is.null(rv_param_temp$categLevelsPlot))
        shiny::validate(
          need(input$sel_Categ %in% unique(rv_param_temp$categLevelsPlot$CharacteristicName), message = "The selected categorical characteristic is not recognized as a categorical characteristic in the dataset. Please first add it to the categorical definitions file."))
        plotCategDat <- rv$dat %>% # pulling from the original data
          dplyr::filter(CharacteristicName == input$sel_Categ) %>%
          dplyr::select(OrganizationFormalName, ActivityStartDate, MonitoringLocationIdentifier, CategName = CharacteristicName, CategResultMeasureValue = ResultMeasureValue) %>%
          dplyr::distinct(.)

        plotDat %<>% dplyr::left_join(plotCategDat, by = c("OrganizationFormalName", "MonitoringLocationIdentifier", "ActivityStartDate"))
        plotDat$CategResultMeasureValue <- as.factor(plotDat$CategResultMeasureValue)
        cat("line1034")
      }
    }
    
    # Assign custom threshold limits
    if(!is.null(rv_param_temp$threshType) & !is.null(input$sel_ThreshUnit) & !is.null(input$sel_ThreshLower) & !is.null(input$sel_ThreshUpper) & !is.null(plotDat)) {
    if(rv_param_temp$threshType == "showthresh_custom" & rv_param_temp$plotSummarizeBy == "by_char") {

      plotDat$ThreshCateg <- NA
      rv_param_temp$threshCustom <- list()
      
    if(input$sel_ThreshLower != -999 | input$sel_ThreshUpper != 999) { # if a lower or upper threshold has been entered
      thresh_ID <- paste0(unique(na.omit(rv_param_temp$plotDat$CharacteristicName)), " (", input$sel_ThreshUnit, ")")
      if(input$sel_ThreshLower == -999) { # no lower limit
        temp_cut <- c(-Inf, input$sel_ThreshUpper, Inf)
        temp_categ <- c("good", "above")
        temp_colors <- c("#56B4E9", "#E69F00")
      }
      
      if(input$sel_ThreshUpper == 999) { # no upper limit
        temp_cut <- c(-Inf, input$sel_ThreshLower, Inf)
        temp_categ <- c("below", "good")
        temp_colors <- c("lightgray", "#56B4E9")
      }
      
      if(input$sel_ThreshLower != -999 & input$sel_ThreshUpper != 999) { # has lower and upper limit
        temp_cut <- c(-Inf, input$sel_ThreshLower, input$sel_ThreshUpper, Inf)
        temp_categ <- c("below", "good", "above")
        temp_colors <- c("lightgray", "#56B4E9", "#E69F00")
      }
      
    temp_thresh_custom <- list(
      "CharacteristicName" = unique(na.omit(plotDat$CharacteristicName)),
      "ResultMeasure.MeasureUnitCode" = input$sel_ThreshUnit,
      "cut_breaks" = temp_cut,
      "cut_categ" = temp_categ,
      "cut_colors" = temp_colors
    )
    rv_param_temp$threshCustom[[thresh_ID]] <- temp_thresh_custom
    
    # Fill ThreshCateg column in plotDat
    shiny::req(!is.null(rv_param_temp$threshCustom))
    which_rows <- which(plotDat$CharacteristicName == rv_param_temp$threshCustom[[1]]$CharacteristicName & plotDat$ResultMeasure.MeasureUnitCode == rv_param_temp$threshCustom[[1]]$ResultMeasure.MeasureUnitCode)
    if(length(which_rows) > 0) {
      plotDat$ThreshCateg[which_rows] <- as.character(cut(as.numeric(plotDat$ResultMeasureValue_replaced[which_rows]), breaks = rv_param_temp$threshCustom[[1]]$cut_breaks, labels = rv_param_temp$threshCustom[[1]]$cut_categ))
        }
      }
    }
      }# end assign custom threshold limits

    # Determine quantiles for plots
    if(any(input$sel_AddQuantile == FALSE, is.null(input$sel_QuantileProbLower), is.null(input$sel_QuantileProbUpper), is.null(input$sel_QuantileGroupBy))) { # if user specified quantile lines - I FEEL LIKE THERE MIGHT BE REDUNDANCY HERE I CAN WORK ON
      rv_param_temp$quantDat <- NULL
    } else {

      if(rv_param_temp$plotSummarizeBy == "by_station" | (rv_param_temp$plotSummarizeBy == "by_char" & input$sel_QuantileGroupBy == "quant_each"))  { # if 'by_station' or if 'by_char' and calculating separate quantile for each station, then group data by station-characteristicname
        rv_param_temp$quantDat <- plotDat %>%
          dplyr::select(MonitoringLocationIdentifier, CharacteristicName, ResultMeasureValue_replaced) %>%
          dplyr::group_by(MonitoringLocationIdentifier, CharacteristicName) %>%
          dplyr::summarise(QuantLineLower = quantile(ResultMeasureValue_replaced, probs = input$sel_QuantileProbLower, na.rm = TRUE),
                    QuantLineUpper = quantile(ResultMeasureValue_replaced, probs = input$sel_QuantileProbUpper, na.rm = TRUE)) # data frame where each row has a monitoring station ID and the value for the user-defined quantile probability
      }
      
      if(rv_param_temp$plotSummarizeBy == "by_char" & input$sel_QuantileGroupBy == "quant_all") { # if 'by_char' and calculating one quantile across all stations
        rv_param_temp$quantDat <- data.frame(
          MonitoringLocationIdentifier = sort(unique(plotDat$MonitoringLocationIdentifier)),
          CharacteristicName = sort(unique(plotDat$CharacteristicName)),
          QuantLineLower = as.numeric(quantile(plotDat$ResultMeasureValue_replaced, probs = input$sel_QuantileProbLower, na.rm = TRUE)),
          QuantLineUpper = as.numeric(quantile(plotDat$ResultMeasureValue_replaced, probs = input$sel_QuantileProbUpper, na.rm = TRUE)),
          stringsAsFactors = FALSE)
      }
    }

    # Finalize the plotDat
    # Add quantDat columns
    if(!is.null(rv_param_temp$quantDat)) {
        plotDat2 <- plotDat %>%
          left_join(data.frame(rv_param_temp$quantDat), by = setdiff(names(rv_param_temp$quantDat), c("QuantLineLower", "QuantLineUpper"))) %>%
          dplyr::mutate(PercCateg = ifelse(ResultMeasureValue_replaced > QuantLineUpper, "above", ifelse(ResultMeasureValue_replaced < QuantLineLower, "below", ifelse(ResultMeasureValue_replaced >= QuantLineLower & ResultMeasureValue_replaced <= QuantLineUpper, "between", NA))))
        plotDat2$PercCateg <- factor(plotDat2$PercCateg, levels = c("below", "between", "above"))
    } else {
      plotDat2 <- plotDat %>%
        dplyr::mutate(PercCateg = NA)
    }
    
    return(plotDat2)
  }
 
FuncGageDat <- function(gage_station) {
  # Function to summarize gage data for plotting
  #
  # Args:
  #   gage_station: Name of the gage station to summarize data of
  #
  # Returns:
  #   Streamflow data for the selected gage station, and limited to the range of dates for which data will be plot

  shiny::req(!is.null(rv_param_temp$plotDat), !is.null(rv$gagesDat), !is.null(rv$userSelect$sel_DefineSeasons))
  shiny::validate(need(gage_station %in% unique(rv$gagesDat$GageName), message = "Streamflow data not available for the selected gage station"))
  gageDat <- subset(rv$gagesDat, GageName == gage_station & ActivityStartDate >= min(rv_param_temp$plotDat$ActivityStartDate, na.rm = TRUE) & ActivityStartDate <= max(rv_param_temp$plotDat$ActivityStartDate, na.rm = TRUE)) %>%
    dplyr::ungroup()
  
  # Assign custom seasons if applicable
  if(nrow(gageDat) > 0 & rv$userSelect$sel_DefineSeasons %in% c("WaterSeasons", "CustomSeasons"))
    {
    gageDat <- FuncCustomSeasons(dat_df = gageDat, seas = rv$userSelect$sel_DefineSeasons)
  }
  
  # Assign water year if applicable
  if(rv$userSelect$sel_DefineSeasons=="WaterSeasons") {
    gageDat$Yr <- gageDat$WaterYr
    gageDat$Mnth <- factor(gageDat$Mnth, levels(gageDat$Mnth)[c(10,11,12,1:9)])
    } else {
      gageDat$Yr <- gageDat$MeteoYr
      gageDat$Mnth <- factor(gageDat$Mnth, levels(rv$dat$Mnth))
    }
  
  if(!is.null(gageDat) & sum(!is.na(gageDat$MeanDailyDischarge)) == 0) {
        showModal(modalDialog(
          title = "No Data",
          "Streamflow data for the selected gage station do not overlap the timespan of water quality data."
          # , footer = modalButton("OK")
          ))
    gageDat <- NULL
        }
    
  return(gageDat)
} 

FuncPrecipDat <- function(precip_station) {
  # Function to summarize precipitation data for plotting. Use mean rather than total for each month, in case missing data
  #
  # Args:
  #   precip_station: Name of the precipitation station to summarize data of
  #
  # Returns:
  #   Precipitation data for the selected weather station, and limited to the range of dates for which data will be plot

  shiny::req(!is.null(rv_param_temp$plotDat), !is.null(rv$meteoDat), !is.null(rv$selectedMeteo))
  shiny::validate(need(precip_station %in% unique(rv$meteoDat$MeteoName), message = "Precipitation data not available for the selected weather station"))
  precipDat <- subset(rv$meteoDat, MeteoShortID == rv$selectedMeteo$MeteoShortID[rv$selectedMeteo$MeteoName == precip_station] & ActivityStartDate >= min(rv_param_temp$plotDat$ActivityStartDate, na.rm = TRUE) & ActivityStartDate <= max(rv_param_temp$plotDat$ActivityStartDate, na.rm = TRUE)) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(MeteoName = precip_station)
  
    # Assign custom seasons if applicable
  if(nrow(precipDat) > 0 & rv$userSelect$sel_DefineSeasons %in% c("WaterSeasons", "CustomSeasons"))
    {
    precipDat <- FuncCustomSeasons(dat_df = precipDat, seas = rv$userSelect$sel_DefineSeasons)
  }
  
  # Assign water year if applicable
  if(rv$userSelect$sel_DefineSeasons=="WaterSeasons") {
    precipDat$Yr <- precipDat$WaterYr
    precipDat$Mnth <- factor(precipDat$Mnth, levels(precipDat$Mnth)[c(10,11,12,1:9)])
    } else {
      precipDat$Yr <- precipDat$MeteoYr
      precipDat$Mnth <- factor(precipDat$Mnth, levels(rv$dat$Mnth))
    }

  return(precipDat)
} 

FuncPlotlyFormat <- function(plotly_list, plotly_title, subplot_titles_vec = NULL, xlab, shared_ylab = NULL, shared_ylab_position = NULL, ylab_vec = NULL, total_height, top_margin = 60, bottom_margin = 5, left_margin = 80, right_margin = 60, hover_tip = "text", is_grouped_boxplots = FALSE) {
  # Function to arrange interactive plots from a list. Necessary because plotly does not format well just with grid.arrange or ggplot faceting
  #
  # Args:
  #   plotly_list: Lists of ggplots that will be generated as a set.
  #   plotly_title: Title for plot set.
  #   subplot_titles_vec: Vector of subplot titles
  #   xlab: X-axis label.
  #   shared_ylab: A single y-axis label to be shared across all subplots.
  #   shared_ylab_position: A number (usually negative) indicating location of a shared y-axis label
  #   ylab_vec: Vector of y-axis labels
  #   total_height: Total height for the plot set.
  #   top_margin...right_margin: Margin sizes that will be used for the final page
  #   hover_tip: Argument for ggplotly--what will show on hover
  #   is_grouped_boxplots: Logical--need additional code if grouped boxplots
  #
  # Returns:
  #   Formatted plotly for a set of plots
  # 
  out_list <- list()
  for(p in 1:length(plotly_list)) {
    temp_plot <- ggplotly(
      plotly_list[[p]],
      tooltip = hover_tip,
      height = total_height) %>% # specify the total plot height here because this layout will be applied to the entire page
      layout(
        title = list( # this is the title for the page
          font = list(size = 20),
          text = plotly_title), # title
        margin = list(
          t=top_margin,
          b=bottom_margin,
          l= left_margin,
          r=right_margin),
        xaxis = list(
          title = xlab,
          font = list(size = 16, family = "Arial"),
          showspikes = TRUE,
          spikemode  = "across", # draw line across plots and to x-axis
          spikedash = "solid",
          spikecolor = "gray",
          spikesnap = "data",
          spikethickness = 2))
    
    # If adding a shared y-axis title...
    if(!is.null(shared_ylab)) {
      temp_plot %<>%
        layout(
          annotations = list(
            x = shared_ylab_position,
            y = 0.55,
            text = shared_ylab,
            showarrow = F, 
            xref="paper",
            yref="paper",
            xanchor="left",
            yanchor="middle",
            textangle=-90,
            font=list(size=16, family = "Arial", color="black")
          ))
      }
    
    # If adding subplot titles...
    if(!is.null(subplot_titles_vec)) {
      temp_plot %<>%
        layout(
          annotations = list(
            text = subplot_titles_vec[[p]],
            xref = "paper",
            yref = "paper",
            yanchor = "top",
            xanchor = "middle",
            x = 0.5,
            y = 1.2,
            showarrow = FALSE,
            font=list(size=16, family = "Arial", color="black")
          ))
    }
    
    # If adding individual y-axis titles...
    if(!is.null(ylab_vec)) {
      temp_plot %<>% 
        layout(
          yaxis = list(
            title = ylab_vec[p], 
            font = list(size = 16, family = "Arial")) # font size and family for y-axis
        )
    }
    
    if(is_grouped_boxplots) { # if boxplots for multiple stations, all combined
      temp_plot %<>% layout(boxmode = "group") # Will generate a false warning -- this is a known, unresolved issue with plotly (issue was closed due to low priority)
    }
    out_list[[p]] <- plotly::hide_legend(temp_plot) # this doesn't work for heatmap continuous colors
  }
  return(out_list)
}

FuncQuantLines <- function(quant_df, combine_stations, dat_df, p) {
  if(!is.null(quant_df)) {
    if(nrow(quant_df)>0) {
      # ...if stations will all be in a single plot and quantLine is by station...
      if(rv_param_temp$plotSummarizeBy == "by_char" & combine_stations==TRUE & length(unique(dat_df$MonitoringLocationIdentifier)) > 1) {
        if(length(unique(quant_df$QuantLineLower)) > 1 | length(unique(quant_df$QuantLineUpper)) > 1) {
          showModal(modalDialog(
            title = "Percentile by Monitoring Site",
            "When combining monitoring sites in a plot, the percentile limits must be calculated across all sites rather than by individual sites"
            ))
          shiny::req(length(unique(quant_df$QuantLineLower)) == 1, length(unique(quant_df$QuantLineUpper)) == 1)
        }
        }
      p <- p +
        geom_hline(data = quant_df %>% dplyr::filter(CharacteristicName==sort(unique(dat_df$CharacteristicName)) & MonitoringLocationIdentifier==sort(unique(dat_df$MonitoringLocationIdentifier))), aes(yintercept = QuantLineLower), linetype = "dashed", color = "red") +
        geom_hline(data = quant_df %>% dplyr::filter(CharacteristicName==sort(unique(dat_df$CharacteristicName)) & MonitoringLocationIdentifier==sort(unique(dat_df$MonitoringLocationIdentifier))), aes(yintercept = QuantLineUpper), linetype = "solid", color = "red")
    }
  }
  return(p)
  }

FuncAddThresh <- function(v_char, thresh, p, xlow_temp = NULL, xhigh_temp = NULL, ylow_temp, yhigh_temp) {
  # Function to add threshold background color
  #
  # Args:
  #   v_char:  Characteristic Name
  #   thresh: NULL or the list for threshold background colors for this site-char
  #   p: Base plot
  #   xlow_temp, xhigh_temp, ylow_temp, yhigh_temp: lower/upper x/y limits for threshold box
  #
  # Returns:
  #   Plot with threshold background
  #
    for (i in 1:length(thresh$cut_categ)) {
      ylow = max(thresh$cut_breaks[i], ylow_temp)
      yhigh = min(thresh$cut_breaks[i+1], yhigh_temp)
      if(ylow <= yhigh) {
        fill_col = thresh$cut_colors[i]
        p <- p +
          geom_rect(data = data.frame(ylow, yhigh), aes(xmin = xlow_temp, xmax = xhigh_temp, ymin = ylow, ymax = yhigh), fill = fill_col, alpha = 0.15, show.legend = FALSE, inherit.aes = FALSE)
      }
    } # threshold background boxes
  return(p)
}

FuncPlotScatter <- function(plot_dat, quant_df = NULL, categ_df = NULL, x_nam = "ActivityStartDate", combine_stations = FALSE, fixed_free_y = "fixed", trans_y = "identity", trans_gage_y = "identity", trans_precip_y = "identity", add_loess = TRUE, incl_cens = FALSE, thresh_list = NULL, rotate_x = FALSE, gage_dat = NULL, precip_dat = NULL, month_summary = FALSE) {
  # Function to generate scatterplot of data, with censored values shown as dotted intervals
  #
  # Args:
  #   plot_dat:  A data frame with the raw data
  #   quant_df:  A data frame with quantile probability limits for each station
  #   categ_df: NULL or the imported categorical levels dataframe
  #   x_nam: Column name for x-axis variable
  #   combine_stations:  TRUE to combine multiple stations in a single plot of a characteristic
  #   fixed_free_y:  Are scales fixed or free across all plots?
  #   trans_y, trans_gage_y, trans_precip_y: Transformation to apply to y axis
  #   add_loess:  Add loess smooth? (will be biased by censored data)
  #   incl_cens: Should censored data be plot as intervals?
  #   thresh_list: NULL or the list for threshold background colors
  #   rotate_x: should x-axis labels be rotated?
  #   gage_dat: USGS gage station data, if streamflow plot should be included: otherwise, NULL
  #   precip_dat: weather station data, if precipitation plot should be included; otherwise, NULL
  #
  # Returns:
  #   List of scatterplot
  # 

  shiny::req(sum(!is.na(plot_dat$y)) > 0) # make sure there are data
  
  # All plots share a single x-axis. Don't need to do this for other x_nam because those are factors with specified levels.
if(x_nam == "ActivityStartDate") {
  xaxes_min = min(plot_dat$x, na.rm = TRUE)
  xaxes_max = max(plot_dat$x, na.rm = TRUE)
}

  # Create column for point shape
  plot_dat %<>% dplyr::mutate(
    pointShape = factor(ifelse(ResultDetectionConditionText == "Detected and Quantified", "quant", "censored"))) # filled circle (shape = 16) if the datum was detected and quantified, otherwise open circle (shape 1)

  # Create the water quality plot(s)
  p1_points_list <- list()
  cat("line1434")
  unique_df <- plot_dat %>% expand(CharacteristicName, MonitoringLocationIdentifier) %>% arrange(CharacteristicName, MonitoringLocationIdentifier) # data frame of unique characteristic-sites
  cat("line586")
  char_vec <- unique_df$CharacteristicName
  cat("line588")
  for (v in 1:nrow(unique_df)) { # for each characteristic-site
    dat_df <- plot_dat %>%
      dplyr::filter(CharacteristicName == unique_df$CharacteristicName[v] & MonitoringLocationIdentifier == unique_df$MonitoringLocationIdentifier[v]) 
    cat("line592")
    # Shared y-axes range
    yaxes_min_temp = switch(all(fixed_free_y=="fixed", length(unique(unique_df$CharacteristicName)) < 2)+1, min(dat_df$y, dat_df$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE), min(plot_dat$y, plot_dat$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE)) # y axis limits. If only one characteristic name and free_fixed_y=="fixed", calculate y-axis limits from the full plot_dat
    shiny::req(!is.null(yaxes_min_temp))
    yaxes_min = switch((yaxes_min_temp <= 0)+1, 0.9*yaxes_min_temp, yaxes_min_temp - 0.1)
    yaxes_max = switch(all(fixed_free_y=="fixed", length(unique(unique_df$CharacteristicName)) < 2)+1, 1.1*max(dat_df$y, dat_df$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE), 1.1*max(plot_dat$y, plot_dat$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE))
    cat("line1448")
    # Set up the plot...
    if(x_nam=="ActivityStartDate") {
      p_points <- ggplot(data = dat_df, aes(x = x, y = y)) + 
        scale_x_date(date_breaks = "1 year", date_labels = "%Y", limits = c(xaxes_min, xaxes_max))
    } else { # if seasonal plot, the time unit will be factor class
      dat_df$x <- as.numeric(dat_df$x)
      p_points <- ggplot(data = dat_df, aes(x = x, y = y)) 
      
      if(x_nam=="DayOfYr") {
        p_points <- p_points +
        scale_x_continuous(breaks = seq(from = 0, to = 366, by = 20))
      } else {
        p_points <- p_points +
          scale_x_continuous(breaks = 1:length(levels(plot_dat$x)), labels = levels(plot_dat$x))
      }
      }
   cat("line1465") 
    # If adding threshold background...
  if(!is.null(thresh_list)) {

    thresh_ID <- paste0(unique_df$CharacteristicName[v], " (", unique(na.omit(dat_df$ResultMeasure.MeasureUnitCode)), ")")
    if(!is.null(thresh_list[[thresh_ID]])) {
    p_points <- FuncAddThresh(v_char = unique_df$CharacteristicName[v], thresh = thresh_list[[thresh_ID]], p = p_points, xlow_temp = switch((x_nam=="ActivityStartDate")+1, 0.5, xaxes_min), xhigh_temp = switch((x_nam=="ActivityStartDate")+1, length(levels(plot_dat$x)) + 0.5, xaxes_max), ylow_temp = yaxes_min, yhigh_temp = yaxes_max)}
  }
    cat("line623")
    # ...if coloring by a categorical characteristic, set up the data...
  if(input$sel_Categ != "none" & !is.null(categ_df)) {
    levs <- unlist(base::strsplit(str_replace_all(categ_df$CategOrder[categ_df$CharacteristicName == input$sel_Categ], "[()]", ""), split="//")) # these are the categorical levels from the category import file--pull from there rather than from data to ensure no levels are omitted just because they were not in the data
    levels_ok <- all(na.exclude(unique(plot_dat$CategResultMeasureValue[plot_dat$CategName == input$sel_Categ])) %in% levs)
    shiny::req(!is.null(levels_ok))
     if(!levels_ok) { # Discontinue if category levels in data don't match levels in imported category file
        showModal(modalDialog(
          title = "Categorical levels mismatch",
          paste0("At least one categorical level found in the data (", paste(sort(na.exclude(unique(plot_dat$CategResultMeasureValue[plot_dat$CategName == input$sel_Categ]))), collapse = ", "), ") is not included in the levels imported from the  category file (", paste(sort(levs), collapse = ", "), "). Please amend the category file to match the data."))
        )}
    dat_df$CategResultMeasureValue <- factor(dat_df$CategResultMeasureValue, levels = levs)
    cols <- unlist(base::strsplit(str_replace_all(categ_df$CategColor[categ_df$CharacteristicName == input$sel_Categ], "[()]", ""), split="//"))
    names(cols) <- levs # create a named color vector to use as palette
 cat("line1488")
    p_points <- p_points +
      suppressWarnings(geom_point(aes(shape = pointShape, color = CategResultMeasureValue, fill = CategResultMeasureValue, text = paste0("Characteristic Set: ", CharacteristicSet, "<br>Monitoring Site: ", MonitoringLocationIdentifier, "<br>Survey Date: ", ActivityStartDate, "<br><br>X-value: ", x, "<br>Parameter Value: ", y, "<br>Detection Level: ", ResultDetectionConditionText, "<br>Categorical Level: ", CategResultMeasureValue)), size = 2, show.legend = c(fill = FALSE, color = TRUE, shape = FALSE))) + # aesthetic text is for ggplotly tooltip. Gives warning that it's not recognized but it still works and it's the only way to also allow geom_smooth (weird)
      scale_fill_manual(values = cols, na.value = "black", drop = FALSE) +
      scale_color_manual(name = paste0(input$sel_Categ, "     "), limits = levs, values = cols, na.value = "black", drop = FALSE) # specifying all possible values in limits is required to make sure they are not dropped from legend when not in data
  } else {

      # ..if combining sites for a single characteristic, so coloring by monitoring site...
      if(rv_param_temp$plotSummarizeBy == "by_char" & combine_stations==TRUE) { # if coloring by monitoring site, use viridis color scale
        p_points <- p_points +
          suppressWarnings(geom_point(aes(shape = pointShape, color = MonitoringLocationIdentifier, fill = MonitoringLocationIdentifier, text = paste0("Characteristic Set: ", CharacteristicSet, "<br>Monitoring Site: ", MonitoringLocationIdentifier, "<br>Survey Date: ", ActivityStartDate, "<br><br>X-value: ", x, "<br>Parameter Value: ", y, "<br>Detection Level: ", ResultDetectionConditionText)), size = 2, show.legend = c(fill = FALSE, color = TRUE, shape = FALSE))) + # this will give a false unknown aesthetics warning for 'text'
          scale_fill_viridis_d() +
          scale_color_viridis_d(name = "Site")
      } else { # ...if not coloring the points...
      p_points <- p_points +
        suppressWarnings(geom_point(aes(shape = pointShape, text = paste0("Characteristic Set: ", CharacteristicSet, "<br>Monitoring Site: ", MonitoringLocationIdentifier, "<br>Survey Date: ", ActivityStartDate, "<br><br>X-value: ", x, "<br>Parameter Value: ", y, "<br>Detection Level: ", ResultDetectionConditionText)), size = 2, color = "black", show.legend = FALSE))
      }
  }
  cat("line1506")
  # Shape the points for quantified vs. censored data
    p1_points <- p_points +
      scale_shape_manual(values = c("quant" = 16, "censored" = 1))
  
  # If including censored data...
  if(incl_cens) {
    dat_cens <- subset(dat_df, ResultDetectionConditionText %in% c("Present Below Quantification Limit", "Not Detected", "Present Above Quantification Limit"))
    if(nrow(dat_cens) > 0) {
      dat_cens$segment_start <- dat_cens$segment_end <- NA
      dat_cens$segment_start[dat_cens$ResultDetectionConditionText %in% c("Not Detected", "Present Below Quantification Limit")] <- yaxes_min # left-censored data
      dat_cens$segment_end[dat_cens$ResultDetectionConditionText %in% c("Not Detected", "Present Below Quantification Limit")] <- dat_cens[dat_cens$ResultDetectionConditionText %in% c("Not Detected", "Present Below Quantification Limit"), "DetectionQuantitationLimitMeasure.MeasureValue", drop = TRUE]
      dat_cens$segment_start[dat_cens$ResultDetectionConditionText == "Present Above Quantification Limit"] <- dat_cens[dat_cens$ResultDetectionConditionText == "Present Above Quantification Limit", "DetectionQuantitationLimitMeasure.MeasureValue", drop = TRUE]
      dat_cens$segment_end[dat_cens$ResultDetectionConditionText == "Present Above Quantification Limit"] <- yaxes_max
      p1_points <- p1_points +
        geom_segment(data = dat_cens, aes(x = x, xend = x, y = segment_start, yend = segment_end), linewidth = 0.25, linetype = "dotted")
    }
  }

  cat("line1533")  
    # If adding loess smooth...
  if(add_loess) {
    # If plotting all stations on one plot, color by station
    if(rv_param_temp$plotSummarizeBy == "by_char" & combine_stations==TRUE) {
      p1_points <- p1_points + 
        geom_smooth(aes(color = MonitoringLocationIdentifier, fill = MonitoringLocationIdentifier), method = "loess", se = FALSE, size = 0.5, alpha = 0.3, show.legend = FALSE, na.rm = TRUE, fullrange = FALSE) +
        coord_cartesian(ylim = c(c(yaxes_min, yaxes_max)))

      } else {
        p1_points <- p1_points + 
          geom_smooth(method = "loess", se = FALSE, size = 0.5, alpha = 0.3, show.legend = FALSE, na.rm = TRUE, fullrange = FALSE) +
          coord_cartesian(ylim = c(c(yaxes_min, yaxes_max)))
      }
    }
    
    # If plotting percentile lines...
    p1_points <- FuncQuantLines(quant_df = quant_df, combine_stations = combine_stations, dat_df = dat_df, p = p1_points)
cat("line1551")  
  # Final formatting of plots
  p1_points <- p1_points +
    scale_y_continuous(trans = trans_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks(), limits = c(yaxes_min, yaxes_max)) + # alternatively, can use 'coord_cartesian(ylim = c(yaxes_min, yaxes_max))' to zoom in to the limits rather than "cutting off" the limits, as setting limits within scale_y_continuous() would do 
    theme_bw(base_size = 11) +
    {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
    {if(rotate_x) {theme(axis.title.x = element_text(margin = margin(t = 10, r = 0, b = 0, l = 0)))}} +
    theme(axis.title.y = element_blank(),
          legend.position = "top",
          legend.text = element_text(size = 16),
          legend.title = element_text(size = 16))
  
  # Add monitoring site as facet label if separate plot per site
  if(combine_stations==FALSE) { 
    p1_points <- p1_points +
      facet_wrap(. ~ MonitoringLocationIdentifier, drop = TRUE, ncol = 1)
  }
  
  p1_points_list[[v]] <- p1_points
  }
  
  # If adding streamflow plot...
  if(input$sel_AddGagePrecip == "streamflow" & !is.null(gage_dat)) {
    if(x_nam=="ActivityStartDate") {
      if(month_summary == TRUE) {
        gage_dat <- gage_dat %>%
        dplyr::mutate(x = MnthDate + 14) %>% # plot at mid-point of month (on x-axis) for streamflow time series
        dplyr::group_by(GageName, x) %>%
        dplyr::summarise(MnthMean_MeanDailyDischarge = round(mean(MeanDailyDischarge, na.rm = TRUE), 2), # summarize mean daily discharge for each month
                MnthMax_MeanDailyDischarge = round(max(MeanDailyDischarge, na.rm = TRUE), 2)) %>%
        dplyr::ungroup()
        
        gage_plot <- ggplot(gage_dat, aes(x = x)) +
        suppressWarnings(geom_line(aes(y = MnthMean_MeanDailyDischarge, group = 1, text = paste0("Gage Name: ", GageName, "<br>Mid-month date: ", x, "<br>Mean daily discharge (cfs), MEAN for month: ", MnthMean_MeanDailyDischarge)), linetype = "solid", colour = "blue")) +
        suppressWarnings(geom_line(aes(y = MnthMax_MeanDailyDischarge, group = 1, text = paste0("Gage Name: ", GageName, "<br>Mid-month date: ", x, "<br>Mean daily discharge (cfs), MAX for month: ", MnthMax_MeanDailyDischarge)), linetype = "dashed", colour = "blue")) + # for time series point plots, present data summarized by month
          scale_x_date(date_breaks = "1 year", date_labels = "%Y", limits = c(xaxes_min, xaxes_max))
      } else { # just plot the points
        gage_plot <- ggplot(gage_dat, aes(x = ActivityStartDate, y = MeanDailyDischarge)) +
        suppressWarnings(geom_point(aes(text = paste0("Gage Name: ", GageName, "<br>Survey date: ", ActivityStartDate, "<br><br>Mean daily discharge (cfs): ", MeanDailyDischarge)))) + 
        scale_x_date(date_breaks = "1 year", date_labels = "%Y", limits = c(xaxes_min, xaxes_max))
        
        # If loess smooth and NOT monthly summary...
        if(add_loess) {
          gage_plot <- gage_plot + 
            geom_smooth(method = "loess", se = FALSE, size = 0.5, alpha = 0.3, show.legend = FALSE) +
            coord_cartesian(ylim = c(c(yaxes_min, yaxes_max)))
        } 
        }
    } else { # if seasonal plot...
        gage_dat$x <- as.numeric(gage_dat$x)
        gage_plot <- ggplot(gage_dat, aes(x = x, y = MeanDailyDischarge)) +
          suppressWarnings(geom_point(aes(text = paste0("Gage Name: ", GageName, "<br>Survey date: ", ActivityStartDate, "<br><br>X-value: ", x, "<br>Mean daily discharge (cfs): ", MeanDailyDischarge)), alpha = 0.5))
        
        if(x_nam=="DayOfYr") {
          gage_plot <- gage_plot +
            scale_x_continuous(breaks = seq(from = 0, to = 366, by = 20))
          } else {
            gage_plot <- gage_plot +
          scale_x_continuous(breaks = 1:length(levels(plot_dat$x)), labels = levels(plot_dat$x))
          }
        
        # If loess smooth...
        if(add_loess) {
          gage_plot <- gage_plot + 
            stat_smooth(se = TRUE, level = 0.95, size = 0.5, alpha = 0.3, show.legend = FALSE)
        }
        }
    
    # Final formatting of streamflow plot...
    gage_plot <- gage_plot +
      scale_y_continuous(trans = trans_gage_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks()) +
        theme_bw(base_size = 11) +
        {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
        theme(axis.title.x = element_blank(),
              axis.title.y = element_blank(),
              legend.position = "none") +
        facet_wrap(. ~ GageName, ncol = 1) + # add the name as facet label
       theme(strip.background = element_rect(fill="lightblue")) # use different color facet strip background to distinguish from water characteristic plots
    } else {
    gage_plot <- NA # blank data frame
    }
  cat("line1642")
   # If adding precipitation plot...
  if(input$sel_AddGagePrecip == "precipitation" & !is.null(precip_dat)) {
    if(x_nam=="ActivityStartDate") {
      if(month_summary == TRUE) {
      precip_dat <- precip_dat %>%
        dplyr::mutate(x = MnthDate + 14) %>% # plot at mid-point of month (on x-axis) for precipitation time series
        dplyr::group_by(MeteoName, x) %>%
        dplyr::summarise(AvgPrecip_cm = round(mean(PRCP_cm, na.rm = TRUE), 2), # summarize precipitation for each month
                MaxPrecip_cm = round(max(PRCP_cm, na.rm = TRUE), 2)) %>%
        dplyr::ungroup()

      precip_plot <- ggplot(precip_dat, aes(x = x)) +
        suppressWarnings(geom_line(aes(y = AvgPrecip_cm, group = 1, text = paste0("Weather Station Name: ", MeteoName, "<br>Mid-month date: ", x, "<br>Daily precipitation (cm), MEAN for month: ", AvgPrecip_cm)), linetype = "solid", colour = "blue")) +
        suppressWarnings(geom_line(aes(y = MaxPrecip_cm, group = 1, text = paste0("Weather Station Name: ", MeteoName, "<br>Mid-month date: ", x, "<br>Daily precipitation (cm), MAX for month: ", MaxPrecip_cm)), linetype = "dashed", colour = "blue")) + # for time series point plots, present data summarized by month
        scale_x_date(date_breaks = "1 year", date_labels = "%Y", limits = c(xaxes_min, xaxes_max))
      } else { # just plot the points
      precip_plot <- ggplot(precip_dat, aes(x = ActivityStartDate, y = PRCP_cm)) +
        suppressWarnings(geom_point(aes(text = paste0("Weather Station Name: ", MeteoName, "<br>Survey date: ", ActivityStartDate, "<br><br>Daily precipitation (cm): ", PRCP_cm)))) + 
        scale_x_date(date_breaks = "1 year", date_labels = "%Y", limits = c(xaxes_min, xaxes_max))
      
      # If loess smooth and NOT monthly summary...
      if(add_loess) {
        precip_plot <- precip_plot + 
          geom_smooth(method = "loess", se = FALSE, size = 0.5, alpha = 0.3, show.legend = FALSE)
      } 
      }
      } else { # if seasonal plot...
        precip_dat$x <- as.numeric(precip_dat$x)
        precip_plot <- ggplot(precip_dat, aes(x = x, y = PRCP_cm)) +
          suppressWarnings(geom_point(aes(text = paste0("Weather Station Name: ", MeteoName, "<br>Survey date: ", ActivityStartDate, "<br><br>X-value: ", x, "<br>Daily precipitation (cm)): ", PRCP_cm)), alpha = 0.5))
        
        if(x_nam=="DayOfYr") {
          precip_plot <- precip_plot +
            scale_x_continuous(breaks = seq(from = 0, to = 366, by = 20))
          } else {
            precip_plot <- precip_plot +
              scale_x_continuous(breaks = 1:length(levels(plot_dat$x)), labels = levels(plot_dat$x))
          }
    
    # If loess smooth...
    if(add_loess) {
      precip_plot <- precip_plot +
        geom_smooth(method = "loess", se = FALSE, size = 0.5, alpha = 0.3, show.legend = FALSE)
    }
  }
    
    # Final formatting of precipitation plot...
    precip_plot <- precip_plot +
      scale_y_continuous(trans = trans_precip_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks()) +
        theme_bw(base_size = 11) +
        {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
        theme(axis.title.x = element_blank(),
              axis.title.y = element_blank(),
              legend.position = "none") +
        facet_wrap(. ~ MeteoName, ncol = 1) + # add the name as facet label
       theme(strip.background = element_rect(fill="lightblue")) # use different color facet strip background to distinguish from water characteristic plots
    } else {
    precip_plot <- NA # blank data frame
  }
  cat("line1712")
  return_list <- list(p1_points_list, char_vec, gage_plot, precip_plot)
  return(return_list)
}

FuncPlotBox <- function(plot_dat, quant_df = NULL, x_nam = "Yr", combine_stations = FALSE, fixed_free_y = "fixed", trans_y = "identity", trans_gage_y = "identity", trans_precip_y = "identity", add_loess = TRUE, incl_cens = FALSE, thresh_list = NULL, rotate_x = FALSE, gage_dat = NULL, precip_dat = NULL) {
  # Function to generate boxplots of data, with reporting limits marked as dotted horizontal lines
  #
  # Args:
  #   plot_dat:  A data frame with the raw data
  #   quant_df:  A data frame with quantile probability limits for each station
  #   x_nam: Column name for x-axis variable. For time series, this is "Yr"
  #   combine_stations:  TRUE to combine multiple stations in a single plot of a characteristic
  #   fixed_free_y:  Are scales fixed or free across all facets?
  #   trans_y, trans_gage_y, trans_precip_y: Transformation to apply to y axis
  #   incl_cens: Should reporting limits be marked as dotted horizontal lines?
  #   thresh_list: NULL or the list for threshold background colors
  #   rotate_x: should x-axis labels be rotated?
  #   gage_dat: USGS gage station data, if streamflow plot should be included: otherwise, NULL
  #   precip_dat: weather station data, if precipitation plot should be included; otherwise, NULL
  #   
  # Returns:
  #   List of boxplots
  # 
  
  shiny::req(sum(!is.na(plot_dat$y)) > 0) # make sure there are data
  
  # Create the water quality plot(s)
  p1_box_list <- list()
  
  unique_df <- plot_dat %>% expand(CharacteristicName, MonitoringLocationIdentifier) %>% arrange(CharacteristicName, MonitoringLocationIdentifier) # data frame of unique characteristic-sites
  
  char_vec <- unique_df$CharacteristicName
  
  for (v in 1:nrow(unique_df)) { # for each characteristic-site
  dat_df <- plot_dat %>%
      dplyr::filter(CharacteristicName == unique_df$CharacteristicName[v] & MonitoringLocationIdentifier == unique_df$MonitoringLocationIdentifier[v])
  
  # Thresholds for detection limits--draw these lines on plot, if within the range of y axes
  y_upperQL <- ifelse(any(!is.na(dat_df$DetectionQuantitationLimitMeasure.MeasureValue[dat_df$ResultDetectionConditionText == "Present Above Quantification Limit"])),  min(dat_df$DetectionQuantitationLimitMeasure.MeasureValue[dat_df$ResultDetectionConditionText == "Present Above Quantification Limit"], na.rm = TRUE), NA) # lowest upper quantification limit -- These may change through time, and we are only going to show the most conservative value 
  
  y_lowerQL <- ifelse(any(!is.na(dat_df$DetectionQuantitationLimitMeasure.MeasureValue[dat_df$ResultDetectionConditionText %in% c("Not Detected", "Present Below Quantification Limit")])), max(dat_df$DetectionQuantitationLimitMeasure.MeasureValue[dat_df$ResultDetectionConditionText %in% c("Not Detected", "Present Below Quantification Limit")], na.rm = TRUE), NA) # highest lower quantification limit

  # Shared y-axes range
  yaxes_min_temp = switch((fixed_free_y=="fixed" & length(unique(unique_df$CharacteristicName)) < 2)+1, min(dat_df$y, dat_df$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE), min(plot_dat$y, plot_dat$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE)) # y axis limits. If only one characteristic name and free_fixed_y=="fixed", calculate y-axis limits from the full plot_dat
  yaxes_min = ifelse(yaxes_min_temp <= 0, yaxes_min_temp - 0.1, 0.9*yaxes_min_temp)
  yaxes_max = switch((fixed_free_y=="fixed" & length(unique(unique_df$CharacteristicName)) < 2)+1, 1.1*max(dat_df$y, dat_df$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE), 1.1*max(plot_dat$y, plot_dat$DetectionQuantitationLimitMeasure.MeasureValue, na.rm=TRUE))
  
  # Set up the plot..
  p_box <- ggplot(data = dat_df, aes(x = x, y = y)) 
  
  if(x_nam=="DayOfYr") {
    p_box <- p_box +
      scale_x_discrete(breaks = seq(from = 0, to = 366, by = 20))
  } else {
    p_box <- p_box +
      scale_x_discrete(drop = FALSE)
  }
  
  # If adding threshold background...
  if(!is.null(thresh_list)) {
    
    thresh_ID <- paste0(unique_df$CharacteristicName[v], " (", unique(na.omit(dat_df$ResultMeasure.MeasureUnitCode)), ")")
    if(!is.null(thresh_list[[thresh_ID]])) {
      
    p_box <- FuncAddThresh(v_char = unique_df$CharacteristicName[v], thresh = thresh_list[[thresh_ID]], p = p_box, xlow_temp = 0.5, xhigh_temp = length(levels(plot_dat$x)) + 0.5, ylow_temp = yaxes_min, yhigh_temp = yaxes_max)
    }
    }
    
  # If combining sites for a single characteristic, so coloring by monitoring site...
  if(rv_param_temp$plotSummarizeBy == "by_char" & combine_stations==TRUE) { # if coloring by monitoring site, use viridis color scale
    p1_box <- p_box +
      geom_boxplot(aes(fill = MonitoringLocationIdentifier), alpha = 0.4, show.legend = c(fill = TRUE)) +
      scale_fill_viridis_d(name = "Site") + 
      guides(fill = guide_legend(direction = "horizontal")) # can't seem to turn legend horizontal with theme(legend...)
    } else {
      p1_box <- p_box + geom_boxplot()
    }
  
  # If including censored data...
  if(incl_cens) {
    if(!is.na(y_lowerQL) & y_lowerQL >= yaxes_min) { # add LQL line
      p1_box <- p1_box +
        geom_hline(yintercept = y_lowerQL, linetype = "dotted", color = "gray")
      }
    if(!is.na(y_upperQL) & y_upperQL <= yaxes_max) { # add UQL line
      p1_box <- p1_box +
        geom_hline(yintercept = y_upperQL, linetype = "dotted", color = "black")
    }
    }
  
  # If plotting percentile lines...
  p1_box <- FuncQuantLines(quant_df = quant_df, combine_stations = combine_stations, dat_df = dat_df, p = p1_box)
  
  # Final formatting of plots
  p1_box <- p1_box +
    scale_y_continuous(trans = trans_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks(), limits = c(yaxes_min, yaxes_max))  +
    theme_bw(base_size = 11) +
    {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
    {if(rotate_x) {theme(axis.title.x = element_text(margin = margin(t = 10, r = 0, b = 0, l = 0)))}} +
    theme(axis.title.y = element_blank())
  
  # Add monitoring site as facet label if separate plot per site
  if(combine_stations==FALSE) {
    p1_box <- p1_box +
      facet_wrap(. ~ MonitoringLocationIdentifier, drop = TRUE, ncol = 1)
    }
  
  p1_box_list[[v]] <- p1_box
  }
  
  # If adding streamflow plot...
  if(input$sel_AddGagePrecip == "streamflow" & !is.null(gage_dat)) {
    gage_box <- ggplot(gage_dat, aes(x = x, y = MeanDailyDischarge)) + 
      geom_boxplot() +
      {if(x_nam == "DayOfYr") {scale_x_discrete(breaks = seq(from = 0, to = 366, by = 20))} else {scale_x_discrete(drop = FALSE)}} +
      scale_y_continuous(trans = trans_gage_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks()) +
      theme_bw(base_size = 11) +
      {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
      theme(axis.title.x = element_blank(),
            axis.title.y = element_blank(),
            legend.position = "none") +
      facet_wrap(. ~ GageName, ncol = 1) + # add the name as facet label
      theme(strip.background = element_rect(fill="lightblue"))
    } else {
      gage_box <- NA # blank data frame
    }
  
  # If adding precipitation plot...
  if(input$sel_AddGagePrecip == "precipitation" & !is.null(precip_dat)) {
    precip_box <- ggplot(precip_dat, aes(x = x, y = PRCP_cm)) + 
      geom_boxplot() +
      {if(x_nam == "DayOfYr") {scale_x_discrete(breaks = seq(from = 0, to = 366, by = 20))} else {scale_x_discrete(drop = FALSE)}} +
      scale_y_continuous(trans = trans_precip_y, labels = function(x) as.character(round(x,2)), breaks = pretty_breaks()) +
      theme_bw(base_size = 11) +
      {if(rotate_x) {theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))}} +
      theme(axis.title.x = element_blank(),
            axis.title.y = element_blank(),
            legend.position = "none") +
      facet_wrap(. ~ MeteoName, ncol = 1) + # add the name as facet label
      theme(strip.background = element_rect(fill="lightblue"))
    } else {
      precip_box <- NA # blank data frame
    }
  
  return_list <- list(p1_box_list, char_vec, gage_box, precip_box)
  return(return_list)
}
  
FuncPlotPage <- function(plot_type, plot_dat, quant_dat, time_unit, free_y, y_scale, categLevelsPlot = rv_param_temp$categLevelsPlot) {
  shiny::req(!is.null(input$sel_Categ))
 
  plot_dat <- isolate(plot_dat)
# Includes censored data
    incl_cens <- any(c("Present Below Quantification Limit", "Not Detected", "Present Above Quantification Limit") %in% unique(plot_dat$ResultDetectionConditionText)) # TRUE if there are any reporting limits
  
    if(time_unit == "ActivityStartDate" & plot_type == "box") {time_unit <- "Yr"} # Box plots for time series are grouped by year
    
    thresh_list <- switch(rv_param_temp$threshType,
                          showthresh_file = rv_param_temp$threshList,
                          showthresh_custom = rv_param_temp$threshCustom,
                          showthresh_none = NULL)
    
      plot_dat$x <- plot_dat[[time_unit]]
      plot_dat$y <- round(plot_dat[["ResultMeasureValue_replaced"]], 2)
      shiny::req(sum(!is.na(plot_dat$y)) > 0) # make sure there are data!
      
      # If adding streamflow data...
        if(any(input$sel_AddGagePrecip!="streamflow", is.null(input$sel_GageStation), is.null(rv$gagesDat), is.null(rv$selectedGages))) {
          gageDat <- NULL
          gage_YScale <- NULL
        } else {
          gageDat <- FuncGageDat(gage_station = input$sel_GageStation)
          if(!is.null(gageDat)) {
            gage_YScale <- input$sel_gage_YScale
            } else {
              gage_YScale <- NULL
            }
        }
      # If adding precipitation data...
        if(any(input$sel_AddGagePrecip!="precipitation", is.null(input$sel_PrecipStation), is.null(rv$meteoDat), is.null(rv$selectedMeteo))) {
          precipDat <- NULL
          precip_YScale <- NULL
        } else {
          precipDat <- FuncPrecipDat(precip_station = input$sel_PrecipStation)
          precip_YScale <- input$sel_precip_YScale
        }
      
      cat("line1898")
      # For seasonal patterns...
      if(time_unit != "ActivityStartDate") {
        xseq = switch(time_unit,
                      Yr = seq(min(as.numeric(as.character(plot_dat$x)), na.rm = TRUE), max(as.numeric(as.character(plot_dat$x)), na.rm = TRUE), by = 1), # this is only for time series boxplots
                      Season = levels(plot_dat$Season), # c("Spring", "Summer", "Fall", "Winter"),
                      Mnth = levels(plot_dat$Mnth),
                      Wk = 1:53,
                      DayOfYr = 1:366 # account for leap year
                      )

        plot_dat$x <- factor(plot_dat$x, levels = xseq, labels = xseq)
        if(!is.null(gageDat)) {
          gageDat$x <- factor(gageDat[[time_unit]], levels = xseq, labels = xseq)
        }
        
        if(!is.null(precipDat)) {
          precipDat$x <- factor(precipDat[[time_unit]], levels = xseq, labels = xseq)
        }
      }
      if(!is.null(input$sel_AddGagePrecip) & !is.null(input$sel_PlotType)) {
        month_summary <- all(input$sel_AddGagePrecip != "none", input$sel_PlotType %in% c("points", "points_smooth"))
      } else {
        month_summary <- FALSE
      }
  cat("line1921")
    if(plot_type %in% c("points", "points_smooth")) {

      ts_plot <- FuncPlotScatter(plot_dat = plot_dat, quant_df = quant_dat, categ_df = categLevelsPlot, x_nam = time_unit, combine_stations = ifelse(length(unique(plot_dat$CharacteristicName)) == 2, ifelse(input$sel_PlotByStation, FALSE, TRUE), FALSE), fixed_free_y = ifelse(free_y, "free_y", "fixed"), trans_y = y_scale, trans_gage_y = gage_YScale, trans_precip_y = precip_YScale, add_loess = ifelse(plot_type == "points_smooth", TRUE, FALSE), incl_cens = incl_cens, thresh_list = thresh_list, rotate_x = TRUE, gage_dat = gageDat, precip_dat = precipDat, month_summary = month_summary)}

    if(plot_type == "box") {
      ts_plot <- FuncPlotBox(plot_dat = plot_dat, quant_df = quant_dat, x_nam = time_unit, combine_stations = ifelse(length(unique(plot_dat$CharacteristicName)) == 2, ifelse(input$sel_PlotByStation, FALSE, TRUE), FALSE), fixed_free_y = ifelse(free_y, "free_y", "fixed"), trans_y = y_scale, trans_gage_y = gage_YScale, trans_precip_y = precip_YScale, incl_cens = incl_cens, thresh_list = thresh_list, rotate_x = TRUE, gage_dat = gageDat, precip_dat = precipDat)}

    # PUT THE PLOTS TOGETHER
cat("line1930")
    shiny::req(!is.null(ts_plot[[1]]))

    # Get the shared legend if it exists - getting shared legends to format properly with plotly is a PITB. Tried following many stackexchange suggestions, with no success.
      if(!is.null(get_legend(ts_plot[[1]][[1]]))) {
      shared_legend <- ggpubr::as_ggplot(get_legend(ts_plot[[1]][[1]])) # if a legend exists, extract it
    } else {
      shared_legend <- NULL
    }

    plot_ht <- 340
    total_plot_height <- 64 + plot_ht * (length(ts_plot[[1]]) + as.integer(input$sel_AddGagePrecip!="none")) # Final plot will take the layout of the first plot, so the first plot needs to have the height of final plot. Initially tried to account for x_axis height, but seems it was probably already adjusted for

    # First, the parameter plots
    param_plotly <- FuncPlotlyFormat(
      plotly_list = ts_plot[[1]],
      plotly_title = paste0("Data for ",  switch((length(unique(plot_dat$MonitoringLocationIdentifier)) > 1)+1, unique(plot_dat$MonitoringLocationIdentifier), "multiple sites"), ":  ", switch((length(unique(plot_dat$CharacteristicName)) > 1) + 1, unique(plot_dat$CharacteristicName), "multiple water characteristics"), " (", min(plot_dat$Yr, na.rm = TRUE), " to ", max(plot_dat$Yr, na.rm = TRUE), ") <br>"),
      xlab = switch(time_unit, ActivityStartDate = "Survey Date (time series)", DayOfYr = "Day of Year", Wk = "Week of Year", Mnth = "Month of Year", Season = "Season of Year"),
      ylab_vec = ts_plot[[2]],
      total_height = total_plot_height,
      is_grouped_boxplots = (plot_type == "box" & length(unique(plot_dat$CharacteristicName)) == 1 & length(unique(plot_dat$MonitoringLocationIdentifier)) > 1 & input$sel_PlotByStation == FALSE) # boxplots for multiple stations, all combined in a single plot
    ) 
      
    # If there is a streamflow plot, add that in
    if(input$sel_AddGagePrecip == "streamflow" & !is.null(gageDat) & "ggplot" %in% class(ts_plot[[3]])) {

  extra_plotly <- FuncPlotlyFormat(
    plotly_list = list(Streamflow = ts_plot[[3]]),
    plotly_title = "Mean Daily Discharge",
    xlab = switch(time_unit, ActivityStartDate = "Survey Date (time series)", DayOfYr = "Day of Year", Wk = "Week of Year", Mnth = "Month of Year", Season = "Season of Year"),
    ylab_vec = c("Mean Daily Discharge (cfs)"),
    total_height = total_plot_height,
    is_grouped_boxplots = FALSE
  )
}

  # If there is a precipitation plot, add that in
if(input$sel_AddGagePrecip == "precipitation" & !is.null(precipDat) & "ggplot" %in% class(ts_plot[[4]])) {
 
  extra_plotly <- FuncPlotlyFormat(
    plotly_list = list(Precipitation = ts_plot[[4]]),
    plotly_title = "Precipitation",
    xlab = switch(time_unit, ActivityStartDate = "Survey Date (time series)", DayOfYr = "Day of Year", Wk = "Week of Year", Mnth = "Month of Year", Season = "Season of Year"),
    ylab_vec = c("Precip (cm)"),
    total_height = total_plot_height,
    is_grouped_boxplots = FALSE
  )
}
    cat("line1978")
    shiny::req(!is.null(param_plotly))
      
      if(exists("extra_plotly")) {
        subplot_list <- c(param_plotly, extra_plotly)
        n_plots <- length(ts_plot[[1]])+1
        } else {
          subplot_list <- param_plotly
      n_plots <- length(ts_plot[[1]])
        }

      shiny::req(!is.null(subplot_list))
      plotly_page <-
      subplot(subplot_list,
              nrows = n_plots, # add 1 for precip plot
              shareX = TRUE, # if set to FALSE, the X-axis labels will appear but will be cut off unless margin is increased. If margin is increased, plot sizes will be uneven
              shareY = FALSE,
              titleX = TRUE,
              titleY = TRUE,
              margin = c(0, 0.0, 0.02/length(subplot_list), 0.14/length(subplot_list)),
              which_layout = 1)
      return_list <- list(plotly_page = plotly_page, shared_legend = shared_legend)
    # return(plotly_page)
      return(return_list)
}

FuncPieDat <- function(limit_type) {
  shiny::req(sum(!is.na(rv_param_temp$plotDat[limit_type])) > 0)
    
    if(rv_param_temp$plotSummarizeBy=="by_char") {
      temp_pie_dat <- rv_param_temp$plotDat %>%
        dplyr::filter(!is.na(get(limit_type))) %>%
        group_by(MonitoringLocationIdentifier, Yr) %>%
        summarise(N = n()) %>%
        left_join(rv_param_temp$plotDat %>%
                    dplyr::rename("CategVar" = limit_type) %>%
                    group_by(MonitoringLocationIdentifier, Yr) %>%
                    dplyr::count(CategVar), by = c("MonitoringLocationIdentifier", "Yr")) %>%
        dplyr::rename(RowLev = MonitoringLocationIdentifier) 
    } else {
      temp_pie_dat <- rv_param_temp$plotDat %>%
        dplyr::filter(!is.na(get(limit_type))) %>%
        group_by(CharacteristicName, Yr) %>%
        summarise(N = n()) %>%
        left_join(rv_param_temp$plotDat %>%
                    dplyr::rename("CategVar" = limit_type) %>%
                    group_by(CharacteristicName, Yr) %>%
                    dplyr::count(CategVar), by = c("CharacteristicName", "Yr")) %>%
        dplyr::rename(RowLev = CharacteristicName) 
    }
    temp_pie_dat %<>%
      dplyr::mutate(HoverLabel = paste0(RowLev, "<br>", rv_param_temp$seasonType, ": ", Yr, "<br>LEVEL: ", CategVar, "<br>COUNT: ", n, " out of N = ", N))
    return(temp_pie_dat)
}

FuncClearAll <- function() {
  rv <- reactiveValues(wqp_url = NULL, parkID = NULL, unitPoly = NULL, HUC10 = NULL, HUC12 = NULL, sitesPointsSub = NULL, meteoStations = NULL, selectedMeteo = NULL, meteoDat = NULL, facilitiesPointsSub = NULL, selectedHucs = NULL, selectedStations = NULL, selectedOriginStation = NULL, selectedUpstreamStations = NULL, selectedDownstreamStations = NULL, selectedUpstreamLines = NULL, selectedDownstreamLines = NULL, orgs = NULL, gageStations = NULL, selectedGages = NULL, gagesDat = NULL, dat = NULL, userSelect = list())
  
  rv_param_temp <- reactiveValues(loadMap = FALSE, resetFilter = FALSE, newImport = NULL, palOrg = NULL, selectParam = NULL, N_plotly_page = NULL, subDat = NULL, subDatTypes = NULL, subDatYears = NULL, filterNPlot = NULL, showStations = NULL, showCharSets = NULL, plotSummarizeBy = NULL, plotDat = NULL, quantDat = NULL, finalPlot = list(plotly_page = NULL, shared_legend = NULL), seasonalPlot = list(plotly_page = NULL, shared_legend = NULL), plotSummary = NULL, precipDat = NULL, seasonalTimeUnit = NULL, categLevels = NULL, categLevelsPlot = NULL, categLevelsImport = NULL, threshList = NULL, threshCustom = NULL, threshType = NULL, percCateg= NULL, seasonType = NULL, param_map_highlight = NULL, update_from_sidebar = NULL)
  
  # Hide filter wellPanels
  restart_panels_filter <- c("new_data_P1", "new_data_P2", "new_data_P3", "new_data_P4", "create_categfile_P1", "create_categfile_P2", "create_categfile_P3") # "wp_filter_yr_season", "wp_filter_sampling_chars", "wp_filter_org", "wp_filter_wqchar",
  lapply(restart_panels_filter, FUN = function(x) shinyjs::hideElement(x))
  
  # Update inputs
  FuncUpdateHome()
  FuncUpdateInputsOther()
}

# These are reactable functions
bar_chart <- function(label, width = "100%", height = "14px", fill = "#00bfc4", background = NULL) {
  bar <- div(style = list(background = fill, width = width, height = height))
  chart <- div(style = list(flexGrow = 1, marginLeft = "6px", background = background), bar)
  div(style = list(display = "flex", alignItems = "center"), label, chart)
  }

with_tooltip <- function(value, tooltip) {
  tags$abbr(style = "text-decoration: underline; text-decoration-style: dotted; cursor: help", title = tooltip, value)
}

download_button <- function(outputId, label = "Download", class = NULL, ...)  {
     tags$a(id = outputId, class = paste("btn btn-default shiny-download-link", 
        class), href = "", target = "_blank", download = NA, 
        icon("download"), label, ...)
}

```

```{r startup}

rv <- reactiveValues(wqp_url = NULL, parkID = NULL, unitPoly = NULL, HUC10 = NULL, HUC12 = NULL, sitesPointsSub = NULL, meteoStations = NULL, selectedMeteo = NULL, meteoDat = NULL, facilitiesPointsSub = NULL, selectedHucs = NULL, selectedStations = NULL, selectedOriginStation = NULL, selectedUpstreamStations = NULL, selectedDownstreamStations = NULL, selectedUpstreamLines = NULL, selectedDownstreamLines = NULL, orgs = NULL, gageStations = NULL, selectedGages = NULL, gagesDat = NULL, dat = NULL, userSelect = list())
  
rv_param_temp <- reactiveValues(loadMap = FALSE, resetFilter = FALSE, newImport = NULL, palOrg = NULL, selectParam = NULL, N_plotly_page = NULL, subDat = NULL, subDatTypes = NULL, subDatYears = NULL, filterNPlot = NULL, showStations = NULL, showCharSets = NULL, plotSummarizeBy = NULL, plotDat = NULL, quantDat = NULL, finalPlot = list(plotly_page = NULL, shared_legend = NULL), seasonalPlot = list(plotly_page = NULL, shared_legend = NULL), plotSummary = NULL, precipDat = NULL, seasonalTimeUnit = NULL, categLevels = NULL, categLevelsPlot = NULL, categLevelsImport = NULL, threshList = NULL, threshCustom = NULL, threshType = NULL, percCateg= NULL, seasonType = NULL, param_map_highlight = NULL, update_from_sidebar = NULL)

### FOR TESTING PURPOSES ONLY <<<<<<<<<<<<<<<<<<<<<<<<<<< 
out_file <- readRDS("C:/Users/echeng/Desktop/WQdash_public/test_data/WQdash_BITH_20230909.RDS")
for(i in names(out_file)) {
      rv[[i]] <- out_file[[i]] # load the data in the dashboard
    }
  
  rv_param_temp$loadMap <- TRUE
  rv_param_temp$resetFilter <- TRUE
  rm(out_file)
```

```{r action_button_beginSearch}
# Action to begin data search from Main Page----
observeEvent(eventExpr = input$button_beginSearch, {
  
  FuncClearAll()
  
# If user choooses to import new data from WQP...

if(input$sel_GetData == "new_data") { 
  showModal(modalDialog(
    title = "Download data from web services",
    "Follow the numbered prompts in the left sidebar. Begin by entering a 4-character Park unit ID and clicking 'Show Monitoring Sites'"
    ))

  shinyjs::showElement("new_data_P1")
  } else { # if user chooses to load existing data...
    showModal(modalDialog(
    fileInput("saved_data_file", label = "Import a saved WQP data file ('RDS' extension)", placeholder = "Click 'Browse...' button then navigate to file", accept = c('.rds'), width = "100%"),
    footer = tagList(
      modalButton("Cancel")
    )
  ))
  }
})
```

```{r action_saved_data_file}
# Action to load saved .RDS file from Main Page ----
observeEvent(eventExpr = input$saved_data_file, {
  shiny::req(!is.null(input$saved_data_file$datapath))
  if(!toupper(tools::file_ext(input$saved_data_file$datapath)) %in% c("RDS")) {
    showModal(modalDialog(
    title = "Error",
    "File must have .RDS extension. Please select a different file."
    ))
  } else {

    tryCatch(out_file <- readRDS(input$saved_data_file$datapath),
             error = function(e) {out_file <- NULL; print("Cannot import the selected file")})
    
  shiny::req(!is.null(out_file))
  if(class(out_file)!="list") {
    showModal(modalDialog(
    title = "Error",
    "Cannot import the selected file. Please try a different .RDS file."
    ))
    }
  
  shiny::req(!is.null(out_file))
  for(i in names(out_file)) {
      rv[[i]] <- out_file[[i]] # load the data in the dashboard
    }
  
  rv_param_temp$loadMap <- TRUE
  rv_param_temp$resetFilter <- TRUE
  rm(out_file)
  
  # Sys.sleep(2)
  
  showModal(modalDialog(
  title = "Done",
  "You may now navigate to the 'Define & Filter Data' page"
  ))
  }
})
```

```{r action_button_showStations}
# Action to show WQP stations from Main Page ----
observeEvent(eventExpr = input$button_showStations, {
  if(input$sel_UnitCode=="") { # can't print validation message within observeEvent, so use modalDialogs
    showModal(modalDialog(
      title = "No Data",
      "Please enter a 4-character Park unit abbreviation."
    ))
    }
 
  shiny::req(input$sel_UnitCode!="") # make sure user has entered Park unit code

  FuncClearAll()
  
  rv$parkID <- input$sel_UnitCode
 
  withProgress(message = "Getting data", detail = "...NPS unit boundaries from IRMA", value = 0, {

  showModal(tags$div(id = "gif_modal", modalDialog(
      HTML('<img src="https://media.giphy.com/media/BAKUHQxl7y7Zu/giphy.gif"><br><center>I am just your entertainment.<br><center>The progress bar is below.'), # custom loading gif--pdog blowing bubble gum
      easyClose = TRUE,
      footer = NULL
      )))
    
  shinyjs::hideElement("new_data_P2")
  shinyjs::hideElement("new_data_P3")
  shinyjs::hideElement("new_data_P4")
    
    # Get park unit boundary data ----
     unitBoundaryURL <- paste0("https://services1.arcgis.com/fBc8EJBxQRMcHlei/ArcGIS/rest/services/IMD_Units_Generic_areas_of_analysis_(AOAs)_-_IMD_BND_ALL_UNITS_AOA_nad_py_view/FeatureServer/0/query?where=UNITCODE+%3D+%27", rv$parkID, "%27&objectIds=&time=&geometry=&geometryType=esriGeometryEnvelope&inSR=&spatialRel=esriSpatialRelIntersects&distance=&units=esriSRUnit_Meter&relationParam=&outFields=*&returnGeometry=true&maxAllowableOffset=&geometryPrecision=&outSR=4326&gdbVersion=&returnDistinctValues=false&returnIdsOnly=false&returnCountOnly=false&returnExtentOnly=false&orderByFields=&groupByFieldsForStatistics=&outStatistics=&returnZ=false&returnM=false&resultOffset=&resultRecordCount=&f=geojson") # save output as WGS84

     if(http_status(GET(unitBoundaryURL))$category!="Success") { # if not a valid service call or if the web service is down, abort
       showModal(
         urlModal(unitBoundaryURL, title = "Data Retrieval Error", subtitle = paste0("Error retrieving Park unit boundary data from IRMA. The message from the web service is: `", http_status(GET(unitBoundaryURL))$message, "`.\n\nTo confirm this is a problem with the web service (and not the dashboard), enter the above URL in a browser and see if data successfully downloads. If an error results, email IRMA support (irma@nps.gov) for assistance."))
       )
       }

     shiny::req(http_status(GET(unitBoundaryURL))$category=="Success") 

    tempUnitOutput <- "tempUnit.geojson"
    download.file(unitBoundaryURL, tempUnitOutput) # readOGR geoJSON driver needs dsn to be a local file, so download the file first, then read it

    imported_dat <- tryCatch(readOGR(dsn = tempUnitOutput, dropNULLGeometries = FALSE), error=function(e) print("Error retrieving Puark unit boundary data")) # return error message if problems still arise with downloading from web services
    if(class(imported_dat)!="SpatialPolygonsDataFrame") {
       showModal(
         urlModal(unitBoundaryURL, title = "Data Retrieval Error", subtitle = paste0("Could not successfully retrieve Park unit boundary data from IRMA. To see if this is a problem with the web service (and not the dashboard), enter the above URL in a browser and see if data successfully downloads with boundary information in geojson format. If necessary, email IRMA support (irma@nps.gov) for assistance."))
       )
    }

    shiny::req(class(imported_dat)=="SpatialPolygonsDataFrame")
    imported_dat <- spTransform(imported_dat, CRS("+proj=longlat +datum=WGS84")) # convert to WGS84

    # Check for problems with self-intersections, etc. These problems should be fixed in the updated version of LandscapeDynamics
    if(any(sf::st_is_valid(sf::st_as_sf(imported_dat))) == FALSE) {
      temp_sf <- sf::st_make_valid(sf::st_as_sf(imported_dat))
      imported_dat <- sf:::as_Spatial(temp_sf)
      }
    rv$unitPoly <- imported_dat
    rm(unitBoundaryURL, tempUnitOutput , imported_dat)
    unlink("tempUnit.geojson")
   
    # Get HUC10 & HUC12 boundary data ----
    for(hucLevel in 5:6) {
      hucName <- switch((hucLevel==6)+1, "HUC10", "HUC12")
     
      incProgress(1/7, detail = paste0("...", hucName, " boundaries from National Watershed Boundary Dataset"))

      hucURL <- paste0("https://hydro.nationalmap.gov/arcgis/rest/services/wbd/MapServer/", hucLevel, "/query?where=&text=&objectIds=&time=&geometry=", rv$unitPoly@bbox["x", "min"], "%2C", rv$unitPoly@bbox["y", "min"], "%2C", rv$unitPoly@bbox["x", "max"], "%2C", rv$unitPoly@bbox["y", "max"], "&geometryType=esriGeometryEnvelope&inSR=4326&outSR=4326&spatialRel=esriSpatialRelIntersects&relationParam=&outFields=*&returnGeometry=true&returnTrueCurves=false&maxAllowableOffset=&geometryPrecision=&having=&returnIdsOnly=false&returnCountOnly=false&orderByFields=&groupByFieldsForStatistics=&outStatistics=&returnZ=false&returnM=false&gdbVersion=&historicMoment=&returnDistinctValues=false&resultOffset=&resultRecordCount=&queryByDistance=&returnExtentOnly=false&datumTransformation=&parameterValues=&rangeValues=&quantizationParameters=&featureEncoding=esriDefault&f=geojson")

    if(http_status(GET(hucURL))$category!="Success") { # make sure the service call is valid
      showModal(
         urlModal(hucURL, title = "Data Retrieval Error", subtitle = paste0("Error retrieving ", hucName, " boundary data from the National Watershed Boundary Dataset. The message from the web service is: `", http_status(GET(hucURL))$message, "`.\n\nTo confirm this is a problem with the web service (and not the dashboard), enter the above URL in a browser and see if data successfully downloads."))
       )
      }
   
    shiny::req(http_status(GET(hucURL))$category=="Success") # if not a valid service call, abort
    
    tempHucOutput <- "tempHuc.geojson"
    download.file(hucURL, tempHucOutput)    
    hucPoly <- tryCatch(readOGR(dsn = tempHucOutput, dropNULLGeometries = FALSE), error=function(e) cat("Error retrieving ", hucName, " data")) # HUC's come in WGS84

    if(class(hucPoly)!="SpatialPolygonsDataFrame") {
      showModal(
         urlModal(hucURL, title = "Data Retrieval Error", subtitle = paste0("Could not successfully retrieve HUC boundary data from the National Watershed Boundary Dataset. To see if this is a problem with the web service (and not the dashboard), enter the above URL in a browser and see if data successfully downloads with boundary information in geojson format."))
       )
      }
    shiny::req(class(hucPoly)=="SpatialPolygonsDataFrame")
    hucPoly <- spTransform(hucPoly, CRS("+proj=longlat +datum=WGS84")) # convert to WGS84

    if(exists("hucPolySub")) {rm(hucPolySub)}
    tryCatch(hucPolySub <- hucPoly[hucPoly$name %in% unique(raster::intersect(rv$unitPoly, hucPoly)@data %>% dplyr::select(name))$name,], error = function(e) NULL) # the subset of HUC's that intersect the NPS unit #
    
    if(exists("hucPolySub")) {
      hucPolySub@data %<>%
      dplyr::rename(HUC = tolower(hucName))
      
      rv[[hucName]] <- hucPolySub
      rm(hucPolySub)
      }
      
    rm(hucURL,hucPoly, tempHucOutput)
    unlink("tempHuc.geojson")
    }
    
# Get Monitoring station sites for overlapping HUC10 ----
# Limited to specified date range and minimum activities number
    incProgress(1/7, detail = "...Monitoring sites from Water Quality Portal")
    allSites <- paste(input$sel_SiteType, collapse = "%3B")
    allHucs <- paste(rv$HUC10$HUC, collapse = "%3B")
    
    sitesURL <- paste0("https://www.waterqualitydata.us/Station/search?siteType=", allSites, "&huc=", allHucs, "&minactivities=", input$sel_MinActivities, "&startDateLo=", format(input$sel_ImportStartDate,"%m-%d-%Y"), "&startDateHi=", format(input$sel_ImportEndDate,"%m-%d-%Y"), "&sampleMedia=Water&zip=no&mimeType=tsv&sorted=no") # could not find a way to check dataRetrieval http  for success, so taking this route

    if(http_status(GET(sitesURL))$category!="Success") { # make sure the service call is valid
      showModal(
        urlModal(sitesURL, title = "Data Retrieval Error", subtitle = paste0("Error retrieving monitoring sites information from the Water Quality Portal. The message from the web service is: `", http_status(GET(sitesURL))$message, "`.\n\nTo confirm this is a problem with the web service (and not the dashboard), enter the above URL in a browser and see if data successfully downloads."))
      )
    }
    
    shiny::req(http_status(GET(sitesURL))$category=="Success") # if not a valid service call, abort
    
    download.file(sitesURL, "tempSites.csv", mode = "w")
    sites <- read_delim("tempSites.csv", "\t", escape_double = FALSE, trim_ws = TRUE)
    
    if(is.null(sites)|nrow(sites)==0) { # if no monitoring stations, abort
      showModal(modalDialog(
        title = "No Monitoring Sites",
        "No monitoring sites found in Water Quality Portal for specified query. Please try again."
      ))
      }
    shiny::req(!is.null(sites) & nrow(sites)>0)

    sitesPoints <- SpatialPointsDataFrame(coords = sites[c("LongitudeMeasure", "LatitudeMeasure")], data = sites, proj4string = CRS("+init=epsg:4269")) # NAD83 <<<<<<<<<<<<<<< NEED TO CHECK ON THIS, IT SEEMS INDIVIDUAL RECORDS MAY HAVE DIFFERENT DATUMS
    sitesPoints <- spTransform(sitesPoints, CRS("+proj=longlat +datum=WGS84")) # convert to WGS84
    sitesPoints@data %<>%
      dplyr::mutate(
        SITELAB = paste0("Monitoring Site: ", MonitoringLocationName, " [", MonitoringLocationIdentifier, "]"),

        SITEPOP = paste0("Org: ", OrganizationFormalName, '<br>Site ID: <a href="https://www.waterqualitydata.us/provider/', ProviderName, '/', OrganizationIdentifier, '/', MonitoringLocationIdentifier, '/" target="_blank">', MonitoringLocationIdentifier, '</a>', "<br>Water Monitoring Station: ", MonitoringLocationName, "<br>Type: ", MonitoringLocationTypeName))
    
    rv$sitesPointsSub <- sitesPoints
    rm(sitesURL, sites, sitesPoints)
    unlink("tempSites.csv")
    
    # Get organization information for WQP data ----
    # Limited to specified date range and minimum activities number
    orgURL <- paste0("https://www.waterqualitydata.us/data/Organization/search?siteType=", allSites, "&huc=", allHucs, "&minactivities=", input$sel_MinActivities, "&startDateLo=", format(input$sel_ImportStartDate,"%m-%d-%Y"), "&startDateHi=", format(input$sel_ImportEndDate,"%m-%d-%Y"), "&sampleMedia=Water&mimeType=csv&zip=no")

  if(http_status(GET(orgURL))$category!="Success") { # make sure the service call is valid
    showModal(
      urlModal(orgURL, title = "Data Retrieval Error", subtitle = paste0("Error retrieving organization information from the Water Quality Portal. The message from the web service is: `", http_status(GET(orgURL))$message, "`.\n\nTo confirm this is a problem with the web service (and not the dashboard), enter the above URL in a browser and see if data successfully downloads."))
      )
  }
    
  shiny::req(http_status(GET(orgURL))$category=="Success") # if not a valid service call, abort

    download.file(orgURL, "tempOrg.csv", mode = "w")
  
  rv$orgs <- read_csv("tempOrg.csv") %>%
    dplyr::filter(OrganizationFormalName %in% unique(rv$sitesPointsSub@data$OrganizationFormalName)) %>%
    dplyr::select(OrganizationFormalName, Description = OrganizationDescriptionText, `Email/Web` = ElectronicAddress, Phone = Telephonic) %>%
    dplyr::mutate(Selected = TRUE) %>%
    arrange(OrganizationFormalName) %>%
    as.data.frame
  
  rm(orgURL)
  unlink("tempOrg.csv")
  
  # Get USGS stream gauging station information, by bounding box ----
  incProgress(1/7, detail = "...USGS stream gages station information from NWIS")
  
  gageURL <- paste0("https://waterservices.usgs.gov/nwis/site/?format=rdb&bBox=", paste0(round(c(rv$sitesPointsSub@bbox[1:2, "min"]-0.25, rv$sitesPointsSub@bbox[1:2, "max"]+0.25), 6), collapse = ","), "&startDT=", as.character(input$sel_ImportStartDate), "&endDT=", as.character(input$sel_ImportEndDate), "&seriesCatalogOutput=true&outputDataTypeCd=dv&parameterCd=00060&siteType=ES,ST&agencyCd=USGS&siteStatus=all")
  
  if(http_status(GET(gageURL))$category!="Success") { # make sure the service call is valid
    showModal(modalDialog(
      title = "No Stream Gage Data",
      "Error retrieving stream gage locations data from USGS water services. These data are not necessary for visualizing water quality data on the dashboard.",
      easyClose = FALSE,
      footer = tagList(
        div(style="display:inline-block; width:100px;", actionButton("dismiss_gages_modal", "Got it!"))
        )
      )
      ) # Require user to click 'Got it!' button for the modal to close
    } else {
      
      # shiny::req(http_status(GET(gageURL))$category=="Success") # if not a valid service call, abort
    
    download.file(gageURL, "tempGages.txt", mode = "w")
    
    gageStations <- tryCatch(read.delim("tempGages.txt", comment.char = '#'), error=function(e) print("Error retrieving USGS streamgage information"))
     
    shiny::req(!is.null(gageStations))
    rv$gageStations <- gageStations %>%
      dplyr::filter(agency_cd == "USGS" & parm_cd == "00060" & stat_cd == "00003" & begin_date <= as.character(input$sel_ImportStartDate + 365) & end_date >= as.character(input$sel_ImportEndDate - 365)) %>% # statistics code is mean daily, site type is stream or estuary, data type is daily values, parameter is discharge (cubic feet per second), and begin and end dates are within one year of the user-defined begin and end dates
      dplyr::select(GageID = site_no, GageName = station_nm, SiteType = site_tp_cd, Latitude = dec_lat_va, Longitude = dec_long_va, GageDatum = dec_coord_datum_cd, GageHUC = huc_cd, StartDate = begin_date, EndDate = end_date, NumRecords = count_nu) %>%
      dplyr::mutate(
        Latitude = as.numeric(Latitude),
        Longitude = as.numeric(Longitude),
        StartDate = base::as.Date(StartDate),
        EndDate = base::as.Date(EndDate),
        NumRecords = as.integer(NumRecords),
        GAGELAB = paste0("USGS Gage Station: ", GageName, " [", GageID, "]"),
        GAGEPOP = paste0('Gage Name: <a href="https://waterdata.usgs.gov/nwis/inventory?agency_code=USGS&site_no=', GageID, '" target="_blank">', GageName, '</a>', "<br>Gage ID: ", GageID, "<br>Start Date: ", StartDate, "<br>End Date: ", EndDate, "<br>Number of Records: ", NumRecords))
    
    rm(gageURL, gageStations)
    unlink("tempGages.txt")
    }
    cat("line2298")
    # Get locations of weather stations, for the bounding box ----
  incProgress(1/7, detail = "...Weather station locations from NOAA")
   meteoStationsBbox <- NULL # make sure previous search information erased
  tempMeteoStationsBbox<-tryCatch(ncdc_stations(extent = c(rv$sitesPointsSub@bbox[2:1,"min"]-.25, rv$sitesPointsSub@bbox[2:1,"max"]+.25), limit = 500, datacategoryid="PRCP", token = "GxPYgaqBEDAkerwNZiXWQyIpqkAQTYSv"), error=function(e) print("Error retrieving weather stations information")) # added a buffer
  cat("line2303")
  if(class(tempMeteoStationsBbox)!="ncdc_stations") {
      showModal(modalDialog(
        title = "No Weather Stations Data",
        "Error retrieving weather stations data from NOAA. These data are not necessary for visualizing water quality data on the dashboard.",
        easyClose = FALSE,
        footer = tagList(
          div(style="display:inline-block; width:100px;", actionButton("dismiss_weather_modal", "Got it!"))
        )
      ) # Require user to click 'Got it!' button for the modal to close
      )
    } else {
  cat("line2315")
  meteoStationsBbox <- tempMeteoStationsBbox$data %>% 
    dplyr::mutate(element = "PRCP",
         first_year = lubridate::year(mindate),
         last_year = lubridate::year(maxdate)) %>%
    dplyr::select(id, latitude, longitude, elevation, elevationUnit, name, element, first_year, last_year, datacoverage, elevation) %>%
    dplyr::filter(last_year - first_year > 15 & # station must have at least 15 years of data
                    datacoverage > 0.95 & # station must have at least 95% data coverage
                    last_year > lubridate::year(Sys.Date())-5) # at least 15-year data range, 95% data coverage, and most recent data within five years of current date
  
  meteoStationsBbox$MeteoShortID <- gsub("^.*:","", meteoStationsBbox$id)

  rv$meteoStations <- meteoStationsBbox %>%
    dplyr::rename(MeteoID = id, MeteoName = name, Elev = elevation, ElevUnit = elevationUnit, StartYr = first_year, EndYr = last_year, DataCoverage = datacoverage) %>%
    dplyr::mutate(
              METEOLAB = paste0("Weather Station: ", MeteoName, " [", MeteoID, "]"),
              METEOPOP = paste0("Weather Station: ", MeteoName, "<br>Start Year: ", StartYr, "<br>End Year: ", EndYr, "<br>Data Coverage: ", round(DataCoverage*100, 1), "%"))
  
  rm(meteoStationsBbox)
    }
  rm(tempMeteoStationsBbox)
cat("line2336")
  # Get Discharge facilities locations from ECHO, for the bounding box - restrict to "major" facilities ----
  incProgress(1/7, detail = "...Discharge facilities locations from EPA ECHO Map Services")
  facilitiesPoints <- NULL # make sure previous search information erased
  facilitiesURL <- paste0("https://ofmpub.epa.gov/echo/cwa_rest_services.get_facility_info?output=GEOJSON&p_maj=Y&p_wbd=", paste(rv$HUC10@data[["HUC"]], collapse = ",")) # major facilities only, falls within the HUC10 boundaries

  if(http_status(GET(facilitiesURL))$category!="Success") { # make sure the service call is valid
    showModal(modalDialog(
      title = "No Discharge Facilities Data",
      "Error retrieving discharge facilities locations data from EPA ECHO. These data are not necessary for visualizing water quality data on the dashboard.",
      easyClose = FALSE,
      footer = tagList(
        div(style="display:inline-block; width:100px;", actionButton("dismiss_discharge_modal", "Got it!"))
        )
      )
      ) # Require user to click 'Got it!' button for the modal to close
    } else {
      if(length(str_detect(content(GET(facilitiesURL))$message, "invalid:")) > 0) { # if the http is valid, but some HUCs are not found, remove those HUCs from the search
        lostHUCS <- unlist(str_extract_all(content(GET(facilitiesURL))$message, "[[:digit:]]{10}")) # extract the HUC10's
        subsetHUC <- setdiff(rv$HUC10@data[["HUC"]], lostHUCS) # remove those HUC's from the list, and try again
        facilitiesURL <- paste0("https://ofmpub.epa.gov/echo/cwa_rest_services.get_facility_info?output=GEOJSON&p_maj=Y&p_wbd=", paste(subsetHUC, collapse = ",")) # major facilities only, falls within the HUC10 boundaries
      }
      tempFacilitiesOutput <- "tempFacilities.geojson"
      cat("line2360")
      download.file(facilitiesURL, tempFacilitiesOutput)
      facilitiesPoints <- tryCatch(readOGR(dsn = tempFacilitiesOutput, dropNULLGeometries = FALSE), error=function(e) print("Error retrieving discharge facilities information"))

      if(class(facilitiesPoints)!="SpatialPointsDataFrame") {
        rv$facilitiesPointsSub <- NULL
        showModal(modalDialog(
          title = "No Discharge Facilities Data",
          "Error retrieving discharge facilities locations data from EPA ECHO. These data are not necessary for visualizing water quality data on the dashboard.",
          easyClose = FALSE,
          footer = tagList(
            actionButton("dismiss_discharge_modal", "Got it!")
            )
          )
      ) # Require user to click 'Got it!' button for the modal to close
        
        } else {
          facilitiesPoints@data %<>%
            dplyr::mutate(
              FACLAB = paste0("Discharge Facility: ", CWPName, " [", SourceID, "]"),
              FACPOP = paste0('Discharge Facility: <a href="https://echo.epa.gov/detailed-facility-report?fid=', SourceID, '" target="_blank">', CWPName, '</a>', "<br>Source ID: ", SourceID, "<br>Type: ", CWPFacilityTypeIndicator, "<br>County: ", CWPCounty, "<br>State: ", CWPState)) # CWPName
          rv$facilitiesPointsSub <- facilitiesPoints[rv$HUC10,]
          rm(facilitiesPoints)
        }
      rm(facilitiesURL, tempFacilitiesOutput)
      unlink("tempFacilities.geojson")
    }
    # If displaying shapes, points, etc., Leaflet will automatically project the WGS84 long-lat coordinates when displaying. Leaflet only supports TILES that have been published in EPSG 3857, so if using other tiles (e.g., NPS), need to change projections
  })
  
  shinyjs::showElement("new_data_P2")
    
  rv_param_temp$loadMap <- TRUE
  rv_param_temp$resetFilter <- FALSE # make sure these are still set to FALSE. User can't filter or plot data until they are downloaded/imported.
  

  showModal(modalDialog(
    title = "Done",
    "In the '2. Filter sites to download' panel of the left sidebar, select monitoring sites by HUC or by distance from an origin site, then click the 'Highlight Selected Sites' button."
  ))

}, ignoreInit = TRUE) # end of run search button
```

```{r action_button_highlightStations}
# Action to highlight selected stations ----
observeEvent(eventExpr = input$button_highlightStations, {

  # Select stations by HUC
  if(input$sel_SelectMethod == "methodHuc") {
    if(is.null(rv$selectedHucs)) {
      showModal(modalDialog(
        title = "No HUCs selected",
        "Please click on the map to select HUC(s)."
      ))
      shiny::req(!is.null(rv$selectedHucs))
    }
    if(is.null(input$sel_Organization)) {
      showModal(modalDialog(
        title = "No organization selected",
        "Please select at least one organization to download WQ data from"))
      shiny::req(!is.null(input$sel_Organization))
    }
    rv$selectedOriginStation <- NULL
    rv$selectedUpstreamLines <- NULL
    rv$selectedDownstreamLines <- NULL
    rv$selectedUpstreamStations <- NULL
    rv$selectedDownstreamStations <- NULL

    rv$selectedStations <- rv$sitesPointsSub[rv[[input$sel_HUClevel]][rv[[input$sel_HUClevel]]@data$HUC %in% rv$selectedHucs,],]@data %>% # data in selected HUCs
      dplyr::select(MonitoringLocationIdentifier, OrganizationFormalName) %>%
      dplyr::filter(OrganizationFormalName %in% input$sel_Organization) %>% # limit to selected orgs
      dplyr::distinct() %>%
      dplyr::arrange(MonitoringLocationIdentifier) %>%
      as.data.frame
    
    shiny::req(length(rv$selectedStations$MonitoringLocationIdentifier) > 0)
  
    showModal(modalDialog(
    title = "Done",
    "Selected monitoring sites are shown as larger, white-outlined circles on the map. Select gage and weather stations to download (if available) and select characteristic groups to download, then press the green 'DOWNLOAD DATA' button to import the water quality data"
    ))
    } # end of methodHuc
 
  # Select stations by distance from origin
  if(input$sel_SelectMethod == "methodDist") {
    
    if(is.null(input$sel_Organization)) {
      showModal(modalDialog(
        title = "No organization selected",
        "Please select at least one organization to download WQ data from"
      ))
      shiny::req(!is.null(input$sel_Organization))
    }
     
    if(is.null(input$sel_OriginStationID)) {
      showModal(modalDialog(
        title = "No origin monitoring site entered", 
        "To select monitoring sites based on distance from an origin, please enter an origin monitoring site"
      ))
      shiny::req(!is.null(input$sel_OriginStationID))
    }
    
    if(!input$sel_OriginStationID %in% unique(rv$sitesPointsSub$MonitoringLocationIdentifier[rv$sitesPointsSub$OrganizationFormalName %in% input$sel_Organization])) {
      showModal(modalDialog(
        title = "Cannot find the requested origin monitoring site",
        "The requested origin monitoring site is not available for the Park and organizations of interest."
      ))
      shiny::req(input$sel_OriginStationID %in% unique(rv$sitesPointsSub$MonitoringLocationIdentifier[rv$sitesPointsSub$OrganizationFormalName %in% input$sel_Organization]))
    }
 
  if(input$sel_DistKmUpstream == 0 & input$sel_DistKmDownstream == 0) {
        showModal(modalDialog(
          title = "No distance from origin monitoring site entered",
          "To select monitoring sites based on distance from an origin, please enter a distance (in km) upstream or downstream from the origin monitoring site."
        ))
        shiny::req(input$sel_DistKmUpstream > 0 | input$sel_DistKmDownstream > 0)
      }

    withProgress(message = "Downloading from Hydro Network-Linked Data Index...", value = 0, {
      
        showModal(tags$div(id = "gif_modal", modalDialog(
      HTML('<img src="https://media.giphy.com/media/l44QjgeQ5ium91n9K/source.gif"><br><center>I am just your entertainment.<br><center>The progress bar is below.'), # custom loading gif--raccoon thief
      easyClose = TRUE,
      footer = NULL
      )))
      
    nldiURLS <- list(
      selectedOriginStation = paste0("https://labs.waterdata.usgs.gov/api/nldi/linked-data/wqp/", input$sel_OriginStationID),
      selectedUpstreamLines = ifelse(input$sel_DistKmUpstream > 0, paste0("https://labs.waterdata.usgs.gov/api/nldi/linked-data/wqp/", input$sel_OriginStationID, "/navigate/", ifelse(input$sel_IncludeTribs, "UT", "UM"), "?distance=", input$sel_DistKmUpstream), NA),
      selectedDownstreamLines = ifelse(input$sel_DistKmDownstream > 0, paste0("https://labs.waterdata.usgs.gov/api/nldi/linked-data/wqp/", input$sel_OriginStationID, "/navigate/", ifelse(input$sel_IncludeDiversions, "DD", "DM"), "?distance=", input$sel_DistKmDownstream), NA),
      selectedUpstreamStations = ifelse(input$sel_DistKmUpstream > 0, paste0("https://labs.waterdata.usgs.gov/api/nldi/linked-data/wqp/", input$sel_OriginStationID, "/navigate/", ifelse(input$sel_IncludeTribs, "UT", "UM"), "/wqp?distance=", input$sel_DistKmUpstream), NA),
      selectedDownstreamStations = ifelse(input$sel_DistKmDownstream > 0, paste0("https://labs.waterdata.usgs.gov/api/nldi/linked-data/wqp/", input$sel_OriginStationID, "/navigate/", ifelse(input$sel_IncludeDiversions, "DD", "DM"), "/wqp?distance=", input$sel_DistKmDownstream), NA))
 
    for(n in names(nldiURLS)) {
   
      incProgress(1/7, detail = paste0("...", n))
      if(!is.na(nldiURLS[[n]])) { # if URL is specified
        tempURL <- nldiURLS[[n]]
      
        if(http_status(GET(tempURL))$category!="Success") { # make sure the service call is valid
          showModal(
            urlModal(tempURL, title = "Data Retrieval Error", subtitle = paste0("Error retrieving data from the Hydro Network-Linked Data Index for the `", n, "` query. The message from the web service is: `", http_status(GET(tempURL))$message, "`.\n\nTo confirm this is a problem with the web service (and not the dashboard), enter the above URL in a browser and see if data successfully downloads."))
            )
          }
   
        shiny::validate(need(http_status(GET(tempURL))$category=="Success", message = FALSE)) # if not a valid service call, abort
        
        checkhydro <- tryCatch(rgdal::readOGR(dsn = tempURL[[1]], verbose = FALSE), error=function(e) NULL)
    
        if(is.null(checkhydro)) {
        showModal(modalDialog(
          title = "No Data",
          "Error retrieving data from the Hydro Network-Linked Data Index",
          footer = modalButton("OK")
          ))
        } else {
          checkhydro <- spTransform(checkhydro, CRS("+proj=longlat +datum=WGS84")) # convert to WGS84
          rv[[n]] <- checkhydro 
        }
      
        # renderText(paste(n, "is of class", class(nldiData[n][[1]])[1], "and has", length(nldiData[n][[1]]), "features"))
      }
    }
    }) # end of with Progress
# 
    rv$selectedStations <- 
      rbind.fill(rv$selectedOriginStation@data, if(!is.null(rv$selectedUpstreamStations)) rv$selectedUpstreamStations@data, if(!is.null(rv$selectedDownstreamStations)) rv$selectedDownstreamStations@data) %>% # combine into one data frame
      dplyr::rename(MonitoringLocationIdentifier = identifier) %>%
      left_join(unique(rv$sitesPointsSub@data[, c("MonitoringLocationIdentifier", "OrganizationFormalName")]), by = "MonitoringLocationIdentifier") %>%
      dplyr::filter(OrganizationFormalName %in% input$sel_Organization) %>%
      dplyr::distinct() %>%
      dplyr::arrange(MonitoringLocationIdentifier) %>%
      as.data.frame
    
    shiny::req(length(rv$selectedStations$MonitoringLocationIdentifier) > 0)

    showModal(modalDialog(
    title = "Done",
    "Selected monitoring sites are shown as larger, white-outlined circles on the map. The origin site is outlined in red. The selected streamlines upstream of the origin are shown in white; downstream, in brown. Filter weather stations (if available) and characteristic groups to download, then press the green 'DOWNLOAD DATA' button to get the selected data"
    ))
} # end of methodDist
  
  if(!is.null(rv$meteoStations)|!is.null(rv$gageStations)) {shinyjs::showElement("new_data_P3")}
  shinyjs::showElement("new_data_P4")
  # shinyjs::enable("new_data_P4")
  }, ignoreInit = TRUE) # end of observeEvent
```

```{r action_button_downloadData}
# Action to download WQP data ----
observeEvent(eventExpr = input$button_downloadData, { 

    if(length(input$sel_Organization) == 0) { # make sure organization(s) have been selected
    showModal(modalDialog(
      title = "No organizations selected",
      "Please select (from the checklist) at least one organization from which you would like water quality data."
    ))
    }
  shiny::req(length(input$sel_Organization) > 0)
  
  if(length(input$sel_CharType) == 0) { # make sure characteristic group(s) have been selected
    showModal(modalDialog(
      title = "No characteristic groups selected",
      "Please select (from the checklist) at least one characteristic group of data to import."
    ))
    }
  shiny::req(length(input$sel_CharType) > 0)
  
  if(is.null(rv$selectedStations) | length(rv$selectedStations$MonitoringLocationIdentifier) == 0) {
    showModal(modalDialog(
      title = "No monitoring sites selected",
      "Please select monitoring sites from which you would like to import data (filter sites by HUC or by distance from origin, then click the 'Highlight Selected Stations' button)."
    ))
  }
  shiny::req(!is.null(rv$selectedStations), !is.null(rv$sitesPointsSub))
  shiny::req(length(rv$selectedStations$MonitoringLocationIdentifier) > 0)

    withProgress(message = "Processing data request...", detail = "Importing data from Water Quality Portal", value = 0, {
      
      showModal(tags$div(id = "gif_modal", modalDialog(
        HTML('<img src="https://media.giphy.com/media/33zX3zllJBGY8/source.gif"><br><center>I am just your entertainment.<br><center>The progress bar is below.'), # custom loading gif--running elephant
        easyClose = TRUE,
        footer = NULL
      )))
      
      siteTypeChoiceString <- paste0(input$sel_SiteType, collapse = "&siteType=")
      
      sel_OrgIdentifier <- sort(unique(rv$sitesPointsSub@data$OrganizationIdentifier[rv$sitesPointsSub@data$OrganizationFormalName %in% input$sel_Organization]))
  orgChoiceString <- paste0(sel_OrgIdentifier, collapse = "&organization=") 

  charTypeChoiceString <- paste(input$sel_CharType, collapse = "&characteristicType=", sep = ";") %>%
    gsub(",", "%2C", .) %>%
    gsub(" ", "%20", .)
  
  stationChoiceTemp <- 
    rv$selectedStations %>%
    dplyr::filter(OrganizationFormalName %in% input$sel_Organization) %>% # only download data for stations within the selected organizations
    dplyr::select(MonitoringLocationIdentifier) %>%
    dplyr::distinct() %>%
    dplyr::arrange() %>%
    .$MonitoringLocationIdentifier 
  stationChoiceString <- paste0(stationChoiceTemp, collapse = "&siteid=")
  
  datURL <- paste0("https://www.waterqualitydata.us/data/Result/search?siteType=", siteTypeChoiceString, "&organization=", orgChoiceString, "&siteid=", stationChoiceString, "&characteristicType=", charTypeChoiceString, "&minactivities=", input$sel_MinActivities, "&startDateLo=", format(input$sel_ImportStartDate,"%m-%d-%Y"), "&startDateHi=", format(input$sel_ImportEndDate,"%m-%d-%Y"), "&sampleMedia=Water&mimeType=csv&zip=no") # could not find a way to use dataRetrieval for multiple HUCs or multiple sites
  
  rv$wqp_url <- datURL
  cat(datURL)

  if(http_status(GET(datURL))$category!="Success") { # make sure the service call is valid
      showModal(
        urlModal(datURL, title = "Data Retrieval Error", subtitle = paste0("Error retrieving data from the Water Quality Portal for the requested query. The message from the web service is: `", http_status(GET(datURL))$message, "`.\n\nTo confirm this is a problem with the web service (and not the dashboard), enter the above URL in a browser and see if data successfully downloads. If an error results, email WQP support (wqx@epa.gov) for assistance."))
        )
      }

  shiny::validate(need(http_status(GET(datURL))$category=="Success", message = FALSE)) # if not a valid service call, abort
  
  setProgress(1/4, detail = "Formatting data")

  download.file(datURL, "tempDat.csv", mode = "w") # in Windows, mode = "w" when opening text files and "wb" for other types, such as .jpg
 
  rawDat <- read.csv("tempDat.csv") # use read.csv instead of read_csv so will convert '/' in column names to '.'
  tempDat <- rawDat

# Format WQP data ----
  
  tempDat[tempDat==""] <- NA
  tempDat$ResultMeasure.MeasureUnitCode[is.na(tempDat$ResultMeasure.MeasureUnitCode) & !is.na(tempDat$DetectionQuantitationLimitMeasure.MeasureUnitCode)] <- tempDat$DetectionQuantitationLimitMeasure.MeasureUnitCode[is.na(tempDat$ResultMeasure.MeasureUnitCode) & !is.na(tempDat$DetectionQuantitationLimitMeasure.MeasureUnitCode)]
  tempDat$ResultDetectionConditionText[is.na(tempDat$ResultDetectionConditionText)] <- "Detected and Quantified"
 
  # Split survey date
  tempDat$ActivityStartDate = base::as.Date(tempDat$ActivityStartDate)
  tempDat2 <- FuncBreakDates(tempDat) %>%
    dplyr::mutate(CharacteristicSet = paste(OrganizationIdentifier, CharacteristicName, ResultSampleFractionText, ResultMeasure.MeasureUnitCode, ResultAnalyticalMethod.MethodIdentifier, sep = "_")) %>% # this is the column for identifying comparable records (also optionally consider OrganizationIdentifier and LaboratoryName)
    dplyr::arrange(CharacteristicName, MonitoringLocationIdentifier, ActivityStartDate)
 
  # Remove characteristics with string class values
  paramText <- unique(tempDat2$CharacteristicName[grepl(pattern="(text)", x=tempDat2$CharacteristicName)])
  tempDat2 %<>%
    dplyr::filter(!CharacteristicName %in% paramText)

  convert_factors <- c("OrganizationIdentifier", "OrganizationFormalName", "ActivityTypeCode", "ActivityStartTime.TimeZoneCode", "MonitoringLocationIdentifier", "HydrologicCondition", "HydrologicEvent", "ResultDetectionConditionText", "CharacteristicName", "ResultSampleFractionText", "ResultStatusIdentifier", "ResultValueTypeName", "DetectionQuantitationLimitTypeName", "CharacteristicSet")
  tempDat2[convert_factors] <- sapply(tempDat2[convert_factors], as.factor) # convert these to factor class so they can be searched with drop-down lists
  
  rv$dat <- tempDat2 %>%
    dplyr::ungroup() %>%
    dplyr::select(OrganizationIdentifier, OrganizationFormalName, MonitoringLocationIdentifier, ActivityStartDate, ActivityTypeCode, CharacteristicName, ResultSampleFractionText, ResultMeasureValue, ResultMeasure.MeasureUnitCode, ResultDetectionConditionText, everything()) # Most important variables first, followed by everything else
  rm(tempDat, tempDat2, paramText)
  unlink("tempDat.csv")
 
  # Get streamflow data from selected gage stations ----
  if(!is.null(rv$gageStations) & !is.null(rv$selectedGages)) {
    if (nrow(rv$gageStations) > 0 & length(rv$selectedGages) > 0) {
  setProgress(2/4, detail = "Getting streamflow data from selected USGS gage stations")
      
  gagesDatURL <- paste0("https://waterservices.usgs.gov/nwis/dv/?format=rdb,1.0&sites=", paste(rv$selectedGages$GageID, collapse = ","), "&startDT=", format(input$sel_ImportStartDate,"%Y-%m-%d"), "&endDT=", format(input$sel_ImportEndDate,"%Y-%m-%d"), "&siteStatus=all")
  
  if(http_status(GET(gagesDatURL))$category!="Success") { # make sure the service call is valid
    rv$gagesDat <- NULL
    showModal(modalDialog(
      title = "No Streamflow Data",
      "Error retrieving data for selected selected stream gages."
      ))
    } else {
      download.file(gagesDatURL, "tempGagesDat.txt", mode = "w")
      
      gagesDat <- tryCatch(read.delim("tempGagesDat.txt", comment.char = '#'), error=function(e) print("Error retrieving USGS streamflow data")) # These daily data are  'Discharge, cubic feet per second (Mean)'. QC: 'A' means approved for publication, processing and review completed; 'e' means value has been estimated
     
    shiny::req(!is.null(gagesDat))
    names(gagesDat) <- c("Agency", "GageID", "ActivityStartDate", "MeanDailyDischarge", "MeanDailyDischargeQC")
    gagesDat <- subset(gagesDat, Agency == "USGS") %>%
      dplyr::select(Agency, GageID, ActivityStartDate, MeanDailyDischarge, MeanDailyDischargeQC) %>%
      left_join(unique(rv$selectedGages[c("GageName", "GageID")]), by = "GageID")
    gagesDat$ActivityStartDate<- base::as.Date(gagesDat$ActivityStartDate)
    gagesDat$MeanDailyDischarge <- as.integer(gagesDat$MeanDailyDischarge)
    rv$gagesDat <- FuncBreakDates(gagesDat)
    rm(gagesDat, gagesDatURL)
    unlink("tempGagesDat.txt")
    }
    }
  }
  
  # Get precipitation data from selected weather stations ----
  if(!is.null(rv$meteoStations) & !is.null(rv$selectedMeteo)) {
    if (nrow(rv$meteoStations) > 0 & length(rv$selectedMeteo) > 0) {
  setProgress(3/4, detail = "Getting precipitation data from selected weather stations")
  
  tempMeteoDat <- meteo_pull_monitors(monitors = sort(unique(rv$selectedMeteo$MeteoShortID)), keep_flags = TRUE, date_min = min(rv$dat$ActivityStartDate, na.rm = TRUE), date_max = max(rv$dat$ActivityStartDate, na.rm = TRUE), var = "PRCP") %>% # pull precipitation data (tenths of mm) for the stations and date range corresponding with downloaded WQP data
    dplyr::filter(!is.na(prcp)) %>%
    dplyr::mutate(prcp = as.numeric(prcp))
  if(!is.null(tempMeteoDat)) {
    if(nrow(tempMeteoDat) > 0 ) {
    tempMeteoDat %<>%
    dplyr::mutate(PRCP_cm = prcp/100) %>% # convert precip measure to cm
    dplyr::filter(qflag_prcp == " ") %>% # only keep data without quality flags
    dplyr::select(MeteoShortID = id, ActivityStartDate = date, PRCP_cm) 
  
  tempMeteoDat2 <- tempMeteoDat[complete.cases(tempMeteoDat), ] %>% left_join(rv$selectedMeteo[, c("MeteoName", "MeteoShortID")])
  tempMeteoDat2$ActivityStartDate <- base::as.Date(tempMeteoDat2$ActivityStartDate)
  rv$meteoDat <- FuncBreakDates(tempMeteoDat2)
  rm(tempMeteoDat, tempMeteoDat2)
  }
    } else {
    rv$meteoDat <- NULL
    rv$meteoStations <- NULL
    rv$selectedMeteo <- NULL
  }
    }
  }
  
  # Save query ----
  
  # Update rv$userSelect with the import settings
  import_input <- c("sel_UnitCode", "sel_ImportStartDate", "sel_ImportEndDate", "sel_MinActivities", "sel_SiteType", "sel_HUClevel", "sel_SelectMethod", "sel_OriginStationID", "sel_DiskKmUpstream", "sel_IncludeTribs", "sel_DistKmDownstream", "sel_IncludeDiversions", "sel_Organization", "sel_Gages", "sel_Meteo", "sel_CharType")
  FuncUpdateUserSelect(inputs_to_update = import_input) 
  
    rv$orgs$Selected <- FALSE
    rv$orgs$Selected[rv$orgs$OrganizationFormalName %in% input$sel_Organization] <- TRUE # identify if each organization was selected for import or not

  rv_param_temp$resetFilter <- TRUE
  rv_param_temp$newImport <- TRUE
 
    showModal(modalDialog(
      title = "Done",
      paste0("Data import SUCCESSFUL. You may now navigate to the FILTER DATA tab to choose a subset of data to work with. OPTIONAL: To download the formatted data file (.RDS) to your computer, press the `Download Formatted RDS` button in the left side panel. ") 
    ))
  })
}, ignoreInit = TRUE) # end of observeEvent
```
  
```{r if_resetFilter_TRUE}
# When new data loaded, reset filter inputs to default values ----
renderUI({
  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$resetFilter))
  if(rv_param_temp$resetFilter == TRUE) {

    # Update the input values on Filter page - note that the updates won't activate until the Filter page is in focus (at least once during session)
    FuncUpdateFilter() 
    
    rv_param_temp$subDatYears <- NULL
    rv_param_temp$subDat <- NULL
    rv_param_temp$resetFilter <- FALSE # once the inputs have updated, set resetFilter back to FALSE and update the plot inputs

  }

})
```

```{r events_import_page}
observeEvent(eventExpr = input$dismiss_discharge_modal, {
  removeModal()
  })

observeEvent(eventExpr = input$dismiss_weather_modal, {
  removeModal()
  })

observeEvent(eventExpr = input$dismiss_gages_modal, {
  removeModal()
  })
  
renderUI({
  shiny::req(!is.null(rv$meteoStations), !is.null(input$sel_GetData), is.null(rv$dat))
  shiny::req(input$sel_GetData == "new_data")
  rv$selectedMeteo <- switch(is.null(input$sel_Meteo)+1, rv$meteoStations[rv$meteoStations$MeteoName %in% input$sel_Meteo,], NULL)
  # Sys.sleep(1)
})

renderUI({
  shiny::req(!is.null(rv$gageStations), !is.null(input$sel_GetData), is.null(rv$dat))
  shiny::req(input$sel_GetData == "new_data")
  rv$selectedGages <- switch(is.null(input$sel_Gages)+1, rv$gageStations[rv$gageStations$GageName %in% input$sel_Gages,], NULL)
  # Sys.sleep(1)
})
```

```{r events_filter_page}
# Show or hide the well panels based on checkbox selection, but enable them as soon as rv$dat is available ----
renderUI({
  FuncShowWellPanel(input$sel_FilterYrSeason, "wp_filter_yr_season")
  FuncShowWellPanel(input$sel_FilterSamplingChars, "wp_filter_sampling_chars")
  FuncShowWellPanel(input$sel_FilterOrg, "wp_filter_org")
  # FuncShowWellPanel(input$sel_FilterWQChar, "wp_filter_wqchar")
})

# Action to attach a thresholds file ----
observeEvent(eventExpr = input$button_getThreshFile, { 
  if(is.null(rv$dat)) { # can't print validation message within observeEvent, so use modalDialogs
    rv_param_temp$threshList <- NULL
    showModal(modalDialog(
      title = "No Data",
      "Could not find any water quality data to associate with a threshold limits file. To import or load water quality data, use the dashboard page titled 'Get WQP Data'."
    ))
  }
  
  shiny::req(!is.null(input$sel_GetThreshFile))
  if (input$sel_GetThreshFile == "existing_data") {
    showModal(modalDialog(
      fileInput("saved_thresh_file", label = "Attach a threshold limits file ('csv' extension)", placeholder = "Click 'Browse...' button then navigate to file", accept = c('.csv'), width = "100%"),
               footer = tagList(
                 modalButton("Cancel")
               )
    ))
  }
}) # end observeEvent

# Action to load optional threshold limits .csv file ----
observeEvent(eventExpr = input$saved_thresh_file, {
  shiny::req(!is.null(input$saved_thresh_file$datapath))
  if(!tools::file_ext(input$saved_thresh_file$datapath) == "csv") {
    showModal(modalDialog(
    title = "Error",
    "File must have .csv extension. Please select a different file."
    ))
  } else {

    tryCatch(out_thresh_file <- read_csv(input$saved_thresh_file$datapath),
             error = function(e) {out_categ_file <- NULL; print("Cannot import the selected file")})
    
  shiny::req(!is.null(out_thresh_file))
  tempThresh_df <- out_thresh_file %>%
      dplyr::mutate(ID = paste0(CharacteristicName, " (", MeasureUnit, ")")) # unique ID, for user choice

    tempThresh_list <- list()
    for (i in 1:nrow(tempThresh_df)) {
      threshID <- unlist(tempThresh_df[i, "ID"])
      tempThresh_list[[threshID]]$CharacteristicName <- tempThresh_df$CharacteristicName[i]
      tempThresh_list[[threshID]]$ResultMeasure.MeasureUnitCode <- tempThresh_df$MeasureUnit[i]
      tempThresh_list[[threshID]]$Notes <- tempThresh_df$Notes[i]
      tempThresh_list[[threshID]]$cut_breaks <- as.numeric(unlist(base::strsplit(str_replace_all(tempThresh_df$ThreshBreaks[i], "[()]", ""), split=",")))
      tempThresh_list[[threshID]]$cut_categ <- unlist(base::strsplit(str_replace_all(tempThresh_df$ThreshCateg[i], "[()]", ""), split=","))
      tempThresh_list[[threshID]]$cut_colors <- unlist(base::strsplit(str_replace_all(tempThresh_df$ThreshColor[i], "[()]", ""), split=","))
    }
    
    rv_param_temp$threshList <- tempThresh_list
    rm(tempThresh_df, tempThresh_list)
    
    showModal(modalDialog(
    title = "Done",
    "Threshold limits file has been imported"
    ))
  }
}, ignoreInit = TRUE) # end of observeEvent

```

```{r events_datacheck_page}
# Conditions for showing vs. hiding well panels ----
renderUI({
  if(!is.null(rv_param_temp$subDat) & !is.null(input$sel_CheckChar)) {
  shinyjs::showElement("data_check_stations")
  } else {
    shinyjs::hideElement("data_check_stations")
  }
})

renderUI({
  if(!is.null(rv_param_temp$subDat) & !is.null(input$sel_CheckChar) & !is.null(input$sel_CheckStations)) {
  shinyjs::showElement("data_check_var")
  } else {
    shinyjs::hideElement("data_check_var")
  }
})

# Action to select all stations ----
observeEvent(eventExpr = input$button_allStationCheck, {
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_CheckChar))
  
  updateCheckboxGroupInput(session,
                           "sel_CheckStations",
                           # label = h6("Monitoring sites to include: "),
                           choices = sort(unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharacteristicName==input$sel_CheckChar])),
                           selected = sort(unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharacteristicName==input$sel_CheckChar])))}, ignoreInit = TRUE) # end of observeEvent

# Action to select no stations ----
observeEvent(eventExpr = input$button_noStationCheck, {
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_CheckChar))
  
  updateCheckboxGroupInput(session,
                           "sel_CheckStations",
                           # label = h6("Monitoring sites to include: "),
                           choices = sort(unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharacteristicName==input$sel_CheckChar])),
                           selected = character(0))
  }, ignoreInit = TRUE) # end of observeEvent

```

```{r events_categfiles_page}
# Action to define categorical characteristics ----
observeEvent(eventExpr = input$button_getCategFile, { 
  # initiate categorical levels data frame
  if(is.null(rv$dat)) { # can't print validation message within observeEvent, so use modalDialogs
    rv_param_temp$categLevelsPlot <- NULL
    showModal(modalDialog(
      title = "No Data",
      "Could not find any water quality data to associate with a color coding file. To import or load water quality data, use the dashboard page titled 'Get WQP Data'."
    ))
    }
  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$subDatTypes))
  
  if(length(rv_param_temp$subDatTypes$CharacteristicName[rv_param_temp$subDatTypes$DataType == "categorical"])==0) { # can't print validation message within observeEvent, so use modalDialogs
    rv_param_temp$categLevelsPlot <- NULL
    showModal(modalDialog(
      title = "No categorical parameters",
      "Could not find any categorical parameters among the filtered water quality data."
    ))
    }
  shiny::req(length(rv_param_temp$subDatTypes$CharacteristicName[rv_param_temp$subDatTypes$DataType == "categorical"]) > 0)
  
    rv_param_temp$categLevelsPlot <- tibble("CharacteristicName" = as.character(), "CategOrder" = as.character(), "CategColor" = as.character())
  
shiny::req(!is.null(input$sel_GetCategFile))
  if (input$sel_GetCategFile == "new_data" & !is.null(rv_param_temp$categLevelsPlot)) { # if user chooses to create a new file...
    shinyjs::showElement("create_categfile_P1")
    shinyjs::showElement("create_categfile_P2")
    shinyjs::showElement("create_categfile_P3")
    } else { # if user chooses to load existing data...
      shinyjs::hideElement("create_categfile_P1")
      shinyjs::hideElement("create_categfile_P2")
      shinyjs::hideElement("create_categfile_P3")
      
      showModal(modalDialog(
        fileInput("saved_categ_file", label = "Attach a categorical definitions file ('csv' extension)", placeholder = "Click 'Browse...' button then navigate to file", accept = c('.csv'), width = "100%"),
               footer = tagList(
                 modalButton("Cancel")
               )
             ))
           }
         }) # end observeEvent

# Action to load optional color-coding .csv file ----
observeEvent(eventExpr = input$saved_categ_file, {
  shiny::req(!is.null(input$saved_categ_file$datapath))
  if(!tools::file_ext(input$saved_categ_file$datapath) == "csv") {
    showModal(modalDialog(
    title = "Error",
    "File must have .csv extension. Please select a different file."
    ))
  } else {

    tryCatch(out_categ_file <- read_csv(input$saved_categ_file$datapath),
             error = function(e) {out_categ_file <- NULL; print("Cannot import the selected file")})
    
  shiny::req(!is.null(out_categ_file))
  rv_param_temp$categLevelsPlot <- out_categ_file
  showModal(modalDialog(
    title = "Done",
    "Categorical definitions have been imported"
    ))
  }
  })

# Action to add category level ----
observeEvent(eventExpr = input$button_addCategLevel, {
  showModal(
    modalDialog(
      textInput("new_categlevel_text", "Enter a new level for the categorical characteristic: "),
      footer = tagList(
        div(style="display:inline-block; width:100px; margin-right:10px;", actionButton("button_cancelModal", "Cancel")),
        div(style="display:inline-block; width:180px;", actionButton("button_okAddCategLevelsModal", "Add to List"))
        ) # end footer tagList
      )
    )
  })

observeEvent(eventExpr = input$button_okAddCategLevelsModal, {
  shiny::req(!is.null(rv_param_temp$categLevels), !is.null(input$new_categlevel_text), nzchar(input$new_categlevel_text))
  rv_param_temp$categLevels <- data.frame(ResultMeasureValue = c(input$categ_ranked, input$new_categlevel_text)) # append the new category level, preserving the user-defined rank order
  removeModal()

  })

# Action to delete category level ----
observeEvent(eventExpr = input$button_deleteCategLevel, {
  shiny::req(!is.null(rv_param_temp$categLevels))
  if(nrow(rv_param_temp$categLevels)==0) { # can't print validation message within observeEvent, so use modalDialogs
    showModal(modalDialog(
      title = "No Data",
      "No categorical levels in list."
    ))
    }
  
  shiny::req(nrow(rv_param_temp$categLevels) > 0)
  showModal( 
    modalDialog(
      renderUI({
        selectInput("remove_categ_level",
                    label = "Categorical level to remove from list (will be color-coded as NA): ",
                    choices = rv_param_temp$categLevels$ResultMeasureValue,
                    selected = rv_param_temp$categLevels$ResultMeasureValue[1]
                    )
        }),
      footer = tagList(
        div(style="display:inline-block; width:100px; margin-right:10px;",
            
            actionButton("button_cancelModal", "Cancel")), # use actionButton instead of modalButton to ensure consistent sizing with other actionButton
        div(style="display:inline-block; width:180px;",
            actionButton("button_okDeleteCategLevelsModal", "Remove From List"))
        ) # end footer tagList
      )
    )
  })

observeEvent(eventExpr = input$button_okDeleteCategLevelsModal, {
  shiny::req(nrow(rv_param_temp$categLevels) > 0, !is.null(input$remove_categ_level))
  rv_param_temp$categLevels <- data.frame(ResultMeasureValue = setdiff(input$categ_ranked, input$remove_categ_level)) # remove the category level
  removeModal()
  })

# Action to show color palette options ----
observeEvent(eventExpr = input$button_showPalettes, {
  removeModal()
  showModal(
    modalDialog(
      renderPlot({display.brewer.all()}, height = 700),
      size = "l"
    )
  )
}) # originally tried bsModal() from package 'shinyBS' but it seems to have problems with the current shiny version

# Action to update the categorical definitions file ----
observeEvent(eventExpr = input$button_updateCategFile, {

  shiny::req(!is.null(rv_param_temp$categLevelsPlot), !is.null(input$sel_CategParam), !is.null(input$categ_ranked), !is.null(input$sel_CategPalette))  
  
  rv_param_temp$categLevelsPlot %<>%
    add_row(
      CharacteristicName = input$sel_CategParam, # characteristic name
      CategOrder = paste0("(", paste(input$categ_ranked, collapse = "//"), ")"), # categ order
      CategColor = paste0("(", paste(get_brewer_pal(input$sel_CategPalette, length(input$categ_ranked), plot = FALSE), collapse = "//"), ")") # categ color
    )
  })             
              
# Action to edit table cells ----
observeEvent(input$categDT_cell_edit, {
info = input$categDT_cell_edit
i = info$row
j = info$col
v = info$val
rv_param_temp$categLevelsPlot[i, j] <<- DT::coerceValue(v, rv_param_temp$categLevelsPlot[i, j])
replaceData(proxyDT, rv_param_temp$categLevelsPlot, resetPaging = FALSE)
})

# Action to delete table row ----
observeEvent(input$button_categDeleteRow, {
  shiny::req(!is.null(rv_param_temp$categLevelsPlot), !is.null(input$categDT_rows_selected))
    i = input$categDT_rows_selected
    rv_param_temp$categLevelsPlot <- rv_param_temp$categLevelsPlot[-i,]
    replaceData(proxyDT, rv_param_temp$categLevelsPlot, resetPaging = FALSE)
})

# Action to add table row ----
observeEvent(input$button_categAddRow, {
  shiny::req(!is.null(rv_param_temp$categLevelsPlot))
  rv_param_temp$categLevelsPlot %<>% 
    add_row()
  replaceData(proxyDT, rv_param_temp$categLevelsPlot, resetPaging = FALSE)
})
```

```{r events_plots_page}

# Action to select all parameters for filter----
observeEvent(eventExpr = input$button_allSummaryParam, {
  shiny::req(!is.null(rv_param_temp$selectParam))

  updateCheckboxGroupInput(session,
                           "sel_SummaryParam",
                           selected = sort(rv_param_temp$selectParam))
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select no parameters for filter ----
observeEvent(eventExpr = input$button_noSummaryParam, {
  shiny::req(!is.null(rv_param_temp$selectParam))

  updateCheckboxGroupInput(session,
                           "sel_SummaryParam",
                           selected = character(0))
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select all stations ----
observeEvent(eventExpr = input$button_allStations, {
  shiny::req(!is.null(rv_param_temp$subDat), input$sel_SummarizeBy == "by_char")
  updateCheckboxGroupInput(session,
                           "sel_ShowStations",
                           selected = sort(unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowChar])))
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select no stations ----
observeEvent(eventExpr = input$button_noStations, {
  shiny::req(!is.null(rv_param_temp$subDat), input$sel_SummarizeBy == "by_char")
  updateCheckboxGroupInput(session,
                           "sel_ShowStations",
                           selected = character(0))
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select all characteristics ----
observeEvent(eventExpr = input$button_allStationChars, {
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
  updateCheckboxGroupInput(session,
                           "sel_ShowStationChars",
                           selected = sort(intersect(unique(rv_param_temp$subDat$CharacteristicName[rv_param_temp$subDat$MonitoringLocationIdentifier == input$sel_ShowOneStation]), rv_param_temp$subDatTypes$CharacteristicName[rv_param_temp$subDatTypes$DataType == "numeric"]))
  )
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select no characteristics ----
observeEvent(eventExpr = input$button_noStationChars, {
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
  updateCheckboxGroupInput(session,
                           "sel_ShowStationChars",
                           # label = h6("Select characteristic(s):"),
                           selected = character(0))
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select all characteristic sets for one characteristic ----
observeEvent(eventExpr = input$button_allCharSets, {
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowChar), !is.null(input$sel_ShowStations))
  shiny::req(input$sel_SummarizeBy == "by_char")
  updateCheckboxGroupInput(session,
                           "sel_ShowCharSets",
                           selected = sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName==input$sel_ShowChar & rv_param_temp$subDat$MonitoringLocationIdentifier %in% input$sel_ShowStations]))
  )
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select no characteristic sets for one characteristic ----
observeEvent(eventExpr = input$button_noCharSets, {
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowChar), !is.null(input$sel_ShowStations))
  shiny::req(input$sel_SummarizeBy == "by_char")
  updateCheckboxGroupInput(session,
                           "sel_ShowCharSets",
                           selected = character(0)
  )
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select all characteristic sets for one station ----
observeEvent(eventExpr = input$button_allStationCharSets, {
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
  updateCheckboxGroupInput(session,
                           "sel_ShowStationCharSets",
                           selected = switch((!is.null(input$sel_ShowStationChars))+1, NULL, sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowStationChars & rv_param_temp$subDat$MonitoringLocationIdentifier == input$sel_ShowOneStation])))
  )
  }, ignoreInit = TRUE) # end of observeEvent

# Action to select no characteristic sets for one station ----
observeEvent(eventExpr = input$button_noStationCharSets, {
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
  updateCheckboxGroupInput(session,
                           "sel_ShowStationCharSets",
                           selected = character(0))
  }, ignoreInit = TRUE) # end of observeEvent
      
# Summarize plot data ----
renderUI({
  shiny::req(!is.null(input$sel_SummaryTab), !is.null(rv_param_temp$plotSummarizeBy), !is.null(rv_param_temp$plotDat))

temp_plot_summary <- rv_param_temp$plotDat %>% 
  {if (rv_param_temp$plotSummarizeBy == "by_char") {
    if(input$sel_SummaryTab =="sum_station_yr") group_by(., MonitoringLocationIdentifier, Yr) else group_by(., MonitoringLocationIdentifier)
  } else {
    if(input$sel_SummaryTab =="sum_char_yr") group_by(., CharacteristicName, Yr) else group_by(., CharacteristicName)
  }
  } %>% 
  summarise(N = n(),
            Min = round(min(ResultMeasureValue, na.rm = TRUE), 2),
            Max = round(max(ResultMeasureValue, na.rm = TRUE), 2),
            Mean = round(mean(ResultMeasureValue, na.rm = TRUE), 2),
            Median = round(median(ResultMeasureValue, na.rm = TRUE), 2))
param_tab_list <- list()

for (i in c("ResultDetectionConditionText", "ThreshCateg", "PercCateg", "Season")) {
  if(sum(!is.na(rv_param_temp$plotDat[i])) > 0) {
    tab_temp <- rv_param_temp$plotDat %>% 
      dplyr::rename("CategVar" = i)
    
    if (rv_param_temp$plotSummarizeBy == "by_char") {
      if (input$sel_SummaryTab =="sum_station_yr") {
        tab_temp %<>% group_by(MonitoringLocationIdentifier, Yr) %>%
          dplyr::count(CategVar) %>%
          left_join(temp_plot_summary[, c("MonitoringLocationIdentifier", "Yr", "N")], by = c("MonitoringLocationIdentifier", "Yr"))
      } else {
        tab_temp %<>% group_by(MonitoringLocationIdentifier) %>%
          dplyr::count(CategVar) %>%
          left_join(temp_plot_summary[, c("MonitoringLocationIdentifier", "N")], by = c("MonitoringLocationIdentifier"))
      }
    }
    
    if (rv_param_temp$plotSummarizeBy == "by_station") {
      if (input$sel_SummaryTab =="sum_char_yr") {
        tab_temp %<>% group_by(CharacteristicName, Yr) %>%
          dplyr::count(CategVar) %>%
          left_join(temp_plot_summary[, c("CharacteristicName", "Yr", "N")], by = c("CharacteristicName", "Yr"))
      } else {
        tab_temp %<>% group_by(CharacteristicName) %>%
          dplyr::count(CategVar) %>%
          left_join(temp_plot_summary[, c("CharacteristicName", "N")], by = c("CharacteristicName"))
      }
    }
    tab_temp %<>%
      mutate(Perc = round((n/N)*100, 1)) %>%
      select(-n, -N) %>%
      spread(key = CategVar, value = Perc, sep = ": %", drop = FALSE, fill = 0)
    names(tab_temp) <- gsub("CategVar", i, names(tab_temp), fixed = TRUE)
    param_tab_list[[i]] <- tab_temp
  }
}

if (rv_param_temp$plotSummarizeBy == "by_char") {
  if (input$sel_SummaryTab =="sum_station_yr") {
    final_plot_summary <- c(list(temp_plot_summary), param_tab_list) %>% purrr::reduce(left_join, by =  c("MonitoringLocationIdentifier", "Yr")) # left-join multiple tables
    final_plot_summary$Yr <- as.integer(final_plot_summary$Yr)
  } else {
    final_plot_summary <- c(list(temp_plot_summary), param_tab_list) %>% purrr::reduce(left_join, by =  c("MonitoringLocationIdentifier"))
  }
}

if (rv_param_temp$plotSummarizeBy == "by_station") {
  if (input$sel_SummaryTab =="sum_char_yr") {
    final_plot_summary <- c(list(temp_plot_summary), param_tab_list) %>% purrr::reduce(left_join, by =  c("CharacteristicName", "Yr")) # left-join multiple tables
    final_plot_summary$Yr <- as.integer(final_plot_summary$Yr)
  } else {
    final_plot_summary <- c(list(temp_plot_summary), param_tab_list) %>% purrr::reduce(left_join, by =  c("CharacteristicName"))
  }
}

rv_param_temp$plotSummary <- final_plot_summary
# Sys.sleep(1)
})
```

```{r action_button_update_param_map}
# Action to update data parameter map ----
# User selects stations by clicking map (to show data plots)
observeEvent(input$param_map_marker_click, {
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(input$sel_ParamMapShow))
shiny::req(input$sel_ParamMapShow == "show")  
  isolate({
    
  
rv_param_temp$update_from_sidebar <- FALSE # during this process, put a halt to this

    clicked_site <- input$param_map_marker_click$id
    cat("GRABBED CLICKED SITE\n")
    # if(input$sel_SummarizeBy == "by_char") {
    #   # shiny::req(!is.null(input$sel_ShowStations))
    #   prior_sites <- input$sel_ShowStations
    # } else {
    #   # shiny::req(!is.null(input$sel_ShowOneStation))
    #   prior_sites <- input$sel_ShowOneStation
    # }
    

 
    if(clicked_site %in% rv_param_temp$param_map_highlight) { # if the click is in a selected site
      cat("WAS ALREADY SELECTED\n")
            if(input$sel_SummarizeBy == "by_station" & clicked_site == rv_param_temp$param_map_highlight) {
        showModal(modalDialog(
          title = "Cannot de-select station",
          "You must highlight at least one station to summarize."
        ))
            } else {
              rv_param_temp$param_map_highlight <- rv_param_temp$param_map_highlight[rv_param_temp$param_map_highlight != clicked_site] # then remove it from the list of selected sites
        cat("REMOVED CLICKED SITE FROM VECTOR\n")
        leafletProxy("param_map") %>%
          addCircleMarkers(data = rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier == clicked_site,], group = "Available monitoring sites", lat = ~LatitudeMeasure, lng = ~LongitudeMeasure, layerId = ~MonitoringLocationIdentifier, label = ~SITELAB, radius = 12, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 0.8, stroke = FALSE, color = ~rv_param_temp$palOrg(OrganizationFormalName), opacity = 0.7, options = pathOptions(pane = "pane_param_availableStations")) # and change the site to unselected on the map
        cat("REMOVED CLICKED SITE FROM MAP\n")
              
            }
      
        
        } else { # if the click is in an unselected site
          cat("CLICKED SITE IS NEW\n")
          if(input$sel_SummarizeBy == "by_station") { # if summarizing by station
            rv_param_temp$param_map_highlight <- clicked_site
            cat("UPDATED VECTOR WITH ONLY CLICKED SITE\n")
             leafletProxy("param_map") %>%
          addCircleMarkers(data = FuncParamAvailSites("by_station"), group = "Available monitoring sites", lat = ~LatitudeMeasure, lng = ~LongitudeMeasure, layerId = ~MonitoringLocationIdentifier, label = ~SITELAB, radius = 12, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 0.8, stroke = FALSE, color = ~rv_param_temp$palOrg(OrganizationFormalName), opacity = 0.7, options = pathOptions(pane = "pane_param_availableStations"))
             cat("CLEARED MAP OF ALL SELECTIONS\n")
            
            
            
          } else { # if summarizing by characteristic
            rv_param_temp$param_map_highlight <- c(rv_param_temp$param_map_highlight, clicked_site) # append the ID of clicked site
            cat("UPDATED VECTOR BY APPENDING CLICKED SITE\n")
          }
          
           leafletProxy("param_map") %>% # and highlight the site on the map
            addCircleMarkers(data = rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier == clicked_site,], group = "Available monitoring sites", lat = ~LatitudeMeasure, lng = ~LongitudeMeasure, layerId = ~MonitoringLocationIdentifier, label = ~SITELAB, radius = 15, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 1, stroke = TRUE, weight = 4, color = "white", opacity = 1, options = pathOptions(pane = "pane_param_availableStations"))
           cat("ADDED CLICKED SITE ON MAP\n")
      }
    
    # Also update the user select in left side panel

    if(input$sel_SummarizeBy == "by_char") {
      updateCheckboxGroupInput(session,
                               "sel_ShowStations",
                               selected = rv_param_temp$param_map_highlight)
    }

    if(input$sel_SummarizeBy == "by_station") {
      updateSelectInput(session,
                        "sel_ShowOneStation",
                        selected = rv_param_temp$param_map_highlight)

    }
    
    rv_param_temp$update_from_sidebar <- TRUE 
    })
    }, ignoreInit = TRUE) # end of observeEvent

```

```{r action_button_refreshPlotData}
# Action to update data summaries with current user inputs----

observeEvent(eventExpr = input$button_refreshPlotData, { 
  
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_SummarizeBy))
  rv_param_temp$plotSummarizeBy <- isolate(input$sel_SummarizeBy)
  rv_param_temp$threshType <- isolate(input$sel_ShowThresholds) # save the input setting so plots don't change unless the plot data has been refreshed
  rv_param_temp$seasonalTimeUnit <- isolate(input$sel_SeasonalTimeUnit)

  if(isolate(rv_param_temp$plotSummarizeBy) == "by_char") {
    rv_param_temp$showStations <- isolate(input$sel_ShowStations)
    rv_param_temp$showCharSets <- isolate(input$sel_ShowCharSets)
    }

  if(rv_param_temp$plotSummarizeBy == "by_station") {
    rv_param_temp$showStations <- isolate(input$sel_ShowOneStation)
    rv_param_temp$showCharSets <- isolate(input$sel_ShowStationCharSets)
   }
  
  if(is.null(rv_param_temp$showStations)) {
    showModal(modalDialog(
      title = "No Monitoring Sites Selected",
      "From the left sidebar, please select at least one monitoring site to plot"
      ))
    }
  shiny::req(!is.null(rv_param_temp$showStations))
  
  if(is.null(rv_param_temp$showCharSets)) {
    showModal(modalDialog(
      title = "No Characteristic Sets Selected",
      "From the left sidebar, please select at least one characteristic and at least one characteristic set to plot"
      ))
    }
  shiny::req(!is.null(rv_param_temp$showCharSets))
      rv_param_temp$finalPlot <- rv_param_temp$seasonalPlot <- list(plotly_page = NULL, shared_legend = NULL)

# Format plot data for time series plot tab
  if(any(is.null(rv_param_temp$subDat),  is.null(rv_param_temp$showStations), is.null(rv_param_temp$showCharSets), is.null(rv_param_temp$plotSummarizeBy), is.null(input$sel_AddQuantile), is.null(input$sel_Categ), is.null(input$sel_AddGagePrecip), is.null(rv_param_temp$threshType))) { 
   
    rv_param_temp$plotDat <- NULL

  } else {          

      withProgress(message = "Formatting plot data...", value = 0, {
          
          rv_param_temp$plotDat <- FuncPlotDat() # this function also assigns data to rv_param_temp$quantDat
      })
  }
})
```

```{r update_map_click}          

# User selects stations by clicking map (to show data plots)
observeEvent(input$param_map_marker_click, {
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(input$sel_ParamMapShow))
shiny::req(input$sel_ParamMapShow == "show")  
  isolate({
    
  
rv_param_temp$update_from_sidebar <- FALSE # during this process, put a halt to this

    clicked_site <- input$param_map_marker_click$id
    cat("GRABBED CLICKED SITE\n")
 
    if(clicked_site %in% rv_param_temp$param_map_highlight) { # if the click is in a selected site
      cat("SITE WAS ALREADY SELECTED\n")
            if(all(input$sel_SummarizeBy == "by_station", clicked_site == rv_param_temp$param_map_highlight)) {
        showModal(modalDialog(
          title = "Cannot de-select station",
          "You must highlight at least one station to summarize."
        ))
            } else {
              rv_param_temp$param_map_highlight <- rv_param_temp$param_map_highlight[rv_param_temp$param_map_highlight != clicked_site] # then remove it from the list of selected sites
        cat("REMOVED CLICKED SITE FROM VECTOR\n")
        leafletProxy("param_map") %>%
          addCircleMarkers(data = rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier == clicked_site,], group = "Available monitoring sites", lat = ~LatitudeMeasure, lng = ~LongitudeMeasure, layerId = ~MonitoringLocationIdentifier, label = ~SITELAB, radius = 12, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 0.8, stroke = FALSE, color = ~rv_param_temp$palOrg(OrganizationFormalName), opacity = 0.7, options = pathOptions(pane = "pane_param_availableStations")) # and change the site to unselected on the map
        cat("REMOVED CLICKED SITE FROM MAP\n")
            }
      
        
        } else { # if the click is in an unselected site
          cat("CLICKED SITE IS NEW\n")
          if(input$sel_SummarizeBy == "by_station") { # if summarizing by station
            rv_param_temp$param_map_highlight <- clicked_site
            cat("UPDATED VECTOR WITH ONLY CLICKED SITE\n")
             leafletProxy("param_map") %>%
          addCircleMarkers(data = FuncParamAvailSites("by_station"), group = "Available monitoring sites", lat = ~LatitudeMeasure, lng = ~LongitudeMeasure, layerId = ~MonitoringLocationIdentifier, label = ~SITELAB, radius = 12, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 0.8, stroke = FALSE, color = ~rv_param_temp$palOrg(OrganizationFormalName), opacity = 0.7, options = pathOptions(pane = "pane_param_availableStations"))
             cat("CLEARED MAP OF ALL SELECTIONS\n")
            
          } else { # if summarizing by characteristic
            rv_param_temp$param_map_highlight <- c(rv_param_temp$param_map_highlight, clicked_site) # append the ID of clicked site
            cat("UPDATED VECTOR BY APPENDING CLICKED SITE\n")
          }
          
           leafletProxy("param_map") %>% # and highlight the site on the map
            addCircleMarkers(data = rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier == clicked_site,], group = "Available monitoring sites", lat = ~LatitudeMeasure, lng = ~LongitudeMeasure, layerId = ~MonitoringLocationIdentifier, label = ~SITELAB, radius = 15, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 1, stroke = TRUE, weight = 4, color = "white", opacity = 1, options = pathOptions(pane = "pane_param_availableStations"))
           cat("ADDED CLICKED SITE ON MAP\n")
      }
    
    # Also update the user select in left side panel

    if(input$sel_SummarizeBy == "by_char") {
      updateCheckboxGroupInput(session,
                               "sel_ShowStations",
                               selected = rv_param_temp$param_map_highlight)
    }

    if(input$sel_SummarizeBy == "by_station") {
      updateSelectInput(session,
                        "sel_ShowOneStation",
                        selected = rv_param_temp$param_map_highlight)

    }
    
    rv_param_temp$update_from_sidebar <- TRUE 
    })
    }, ignoreInit = TRUE) # end of observeEvent

```


HOME
====================================== 
Spacer Column {data-width=5}
-------------------------------------

Column {data-width=750}
-------------------------------------

###
```{r}
htmltools::img(src="Images/secchi_transparent.png", width = "7%", style="position:absolute; top:20px; right:25px;")
```
<br>

#### <font size="5">**Quick-Start Instructions**</font>

* <font size="4">To import water quality data from Water Quality Portal (or load an existing .RDS file), follow the red-font instructions on the 'Get WQP Data' page.</font>

* <font size="4">Then (optionally) proceed to the 'Filter WQP Data' page to examine sample sizes and filter a subset of data to summarize on the 'Explore WQP Data' page. Alternatively, use the default filter criteria.</font>

* <font size="4">The 'Explore WQP Data' page presents time series plots, time lapse maps, and summary tables of the filtered WQP data.</font>

* <font size="4"> Use the 'Get Aquarius Data' and 'Explore Aquarius Data' pages to import and examine NPS-collected continuous water quality data for the selected park unit. All available Aquarius data are downloaded.</font>

* <font size="4">Use the 'Export Summary Report' page to output summary graphs and tables of the Aquarius data and the filtered WQP data as a .pdf report or as an interactive HTML dashboard.</font>

<br>

#### <font size="5">**About This Dashboard**</font>

<font size="4">This dashboard is an interactive tool for you to explore water quality trends in and around national park units. Use it to:</font>

* <font size="4">See what water monitoring sites, weather stations, and EPA-regulated facilities occur in and near our parks</font>

* <font size="4">Examine scatterplots, boxplots, and histograms of water quality and precipitation data</font>

* <font size="4">Identify unusually high or low water quality measurements and examine the underlying data records</font>

* <font size="4">For a water quality characteristic (e.g., E.coli), compare scorecards among monitoring sites and across years</font>

* <font size="4">Use a map time slider to see how water quality patterns change over space and time</font>

<br>

#### <font size="5">**About The Data**</font>

<font size="4">Click on the links below to learn more about each data source and the data used in this dashboard:</font>

* <font size="4">[Landscape Dynamics Project](https://www.google.com) (NPS), for National Park System unit boundaries</font>

* <font size="4">[National Watershed Boundary Dataset](https://www.google.com) (USGS), for watershed (HUC10) and subwatershed (HUC12) boundaries</font>

* <font size="4">[Water Quality Portal](https://www.google.com) (a cooperative service sponsored by the USGS, EPA, and NWQMC), for water quality data</font> 

* <font size="4">[National Climatic Data Center](https://www.google.com) (NOAA), for precipitation data</font>

* <font size="4">[Enforcement and Compliance History Online](https://www.google.com) (EPA), for compliance information for facilities regulated under the Clean Water Act</font>

<br> <br> <hr>

<font size="4"><center> *If we have data, lets look at data. If all we have are opinions, lets go with mine.  Jim Barksdale, former Netscape CEO*</center></font>

Spacer Column {data-width=5}
-------------------------------------

Data Sources {data-width=200}
-------------------------------------
```{r images}
htmltools::img(src="Images/US-NationalParkService-Logo.svg", width = "50%",  style="display:block; margin:auto; padding:15px")
  
htmltools::img(src="Images/USGS_logo.png",width = "75%",  style="display:block; margin:auto; padding:15px")

htmltools::img(src="Images/waterquality_logo.jpg", width = "100%", style="display:block; margin:auto; padding:15px")

htmltools::img(src="Images/ncei_icon_550px.jpg", width = "81%", style="display:block; margin:auto; padding:15px")

htmltools::img(src="Images/epa-seal-large.png", width = "52%", style="display:block; margin:auto; padding:15px") # height = "25%", 
```

Spacer Column {data-width=5}
-------------------------------------

Get WQP Data
====================================== 
Inputs {.sidebar data-width=300}
-------------------------------------
```{r main_data_sidebar}  

useShinyjs(rmd = TRUE)

# UI panel to import or load data----
wellPanel(
  id = "new_data_P0",
  p(strong("Choose data source")),
  
  br(),
  
  radioButtons("sel_GetData",
               label = NULL,
               choices = c("Load data file (.RDS) from computer"  = "existing_data",
                           "Download data from web services" = "new_data")),
  
  
  actionButton("button_beginSearch", "BEGIN DATA SEARCH", width = "100%", style="color:black; background-color: lightgreen; display:inline-block; border:1px; margin:5px")
) # end import-load-data panel


# UI panel to show WQP stations ----
shinyjs::hidden( # initially hide this well panel, show only if user wants to import data from WQP
  wellPanel(
    id = "new_data_P1",
    p(strong("1. Show monitoring sites for selected Park and date range")),
    
    textInput("sel_UnitCode", label = h6("Enter a 4-character Park unit ID (e.g., BITH or bith): "), placeholder = "----", value = ""),
  
        actionButton("button_showStations", "Show Sites", width = "100%", style="color:black; background-color: lightgreen; display:inline-block; border:1px; margin:5px"),
    
  dateInput("sel_ImportStartDate", label = h6("Start date for data: "), value = "1980-01-01", min = NULL, max = Sys.Date(),
            format = "yyyy-mm-dd"),
  
  dateInput("sel_ImportEndDate", label = h6("End date for data: "), value = Sys.Date(), min = NULL, max = Sys.Date(),
            format = "yyyy-mm-dd"),
  
  numericInput("sel_MinActivities",
               label = h6("Limit to sites with a minimum number of reported sampling activities: "),
               value = 5,
               min = 1),
  
  checkboxGroupInput("sel_SiteType",
             label = h6("Type(s) of water body to map: "),
             choices = c("Stream", "Estuary", "Spring", "Subsurface", "Well", "Wetland"),
             selected = c("Stream", "Estuary", "Spring")) # additional water-relevant options are: "Aggregate groundwater use", "Ocean", ""Lake, Reservoir, Impoundment", "Subsurface", and also non-aquatic options such as land and atmosphere
  ) # end show-stations panel
) # end hide for show-stations panel

conditionalPanel(
  condition = "rv_param_temp.loadMap == true", # show map zoom slider only after map data have been uploaded,
  renderUI({
    shiny::req(!is.null(rv$unitPoly))
    map_zoom <- min(RgoogleMaps::MaxZoom(lonrange = rv$unitPoly@bbox["x",], latrange = rv$unitPoly@bbox["y",]))
    sliderInput("sel_MapZoom", label = h6("Set map zoom (smaller = wider view):"), min = max(1, map_zoom - 6), max = 15, value = map_zoom - 0.5, step = 0.5, ticks = FALSE, dragRange = FALSE, width = "95%")
    })
)
  
# UI panel to select subset of WQP stations ----
shinyjs::hidden( # initially hide this well panel
  wellPanel(
    id = "new_data_P2",
    p(strong("2. Filter sites to download")),
    
    renderUI({
    shiny::req(!is.null(rv))
    huc_vec <- c("HUC10" = "HUC10 (watershed)", "HUC12" = "HUC12 (subwatershed)")
    huc_choice_names <- huc_vec[intersect(c("HUC10", "HUC12"), names(isolate(reactiveValuesToList(rv)) %>% purrr::discard(is.null)))]
    
    radioButtons("sel_HUClevel", label = h6("Display HUC level: "),
                 choiceNames = unname(huc_choice_names),
                 choiceValues = names(huc_choice_names),
                 selected = names(huc_choice_names)[1])
    }),
    
    radioButtons("sel_SelectMethod", label = h6("Select WQP monitoring sites based on: "),
                 choiceNames = c("HUCs (click on map to select)", "Distance from origin site (enter query filters below)"),
                 choiceValues = c("methodHuc", "methodDist"),
                 selected = "methodHuc"),
    
    renderUI({ # conditional panel if user selects from origin station
      shiny::req(!is.null(input$sel_SelectMethod))
      shiny::req(input$sel_SelectMethod == "methodDist")
      conditionalPanel(
        condition = "input.sel_SelectMethod == 'methodDist'",
        textInput("sel_OriginStationID",
                  label = "Enter an origin WQP monitoring site ID (e.g., USGS-08041745)",
                  value = ""),
        numericInput("sel_DistKmUpstream",
                     label = "How many km upstream of origin?",
                     value = 0,
                     min = 0),
        checkboxInput("sel_IncludeTribs",
                      label = "Include upstream tributaries",
                      value = FALSE),
        numericInput("sel_DistKmDownstream",
                     label = "How many km downstream of origin?",
                     value = 0,
                     min = 0),
        checkboxInput("sel_IncludeDiversions",
                      label = "Include downstream diversions",
                      value = FALSE)
      )
      }),
    
    renderUI({
      shiny::req(!is.null(rv$orgs$OrganizationFormalName))
      checkboxGroupInput("sel_Organization",
                         label = h6("Import WQP data only from these organizations: "),
                         choices = sort(unique(rv$orgs$OrganizationFormalName)),
                         selected = sort(unique(rv$orgs$OrganizationFormalName[rv$orgs$Selected==TRUE])))
      }),
    
    actionButton("button_highlightStations", "Highlight Selected Sites", width = "100%", style="color:black; background-color: lightgreen; display:inline-block; border:1px; margin:5px")
    ) # end subset-stations panel
  ) # end hide for subset-stations panel

# UI panel to select subset of Meteo stations ----
shinyjs::hidden( # initially hide this well panel
  wellPanel(
    id = "new_data_P3",
    p(strong("3. Filter stream gage and weather station data to download")),
    p("Data will download only for selected gage and weather stations. When selected, these stations will show as orange-colored on the map."),
    
    renderUI({
      shiny::req(!is.null(rv$gageStations))
      checkboxGroupInput("sel_Gages",
                         label = h6("Import data only from these USGS gage stations: "),
                         choices = sort(unique(rv$gageStations$GageName)))
      }),
    
    renderUI({
      shiny::req(!is.null(rv$meteoStations))
      checkboxGroupInput("sel_Meteo",
                         label = h6("Import data only from these weather stations: "),
                         choices = sort(unique(rv$meteoStations$MeteoName)))
      })
    ) # end subset-Meteo panel
  ) # end hide for subset-Meteo panel

# UI panel for finer data filter and to import the data ----
shinyjs::hidden( # initially hide this well panel
  wellPanel(
    id = "new_data_P4",
    p(strong("4. Filter characteristic groups to download")),

    checkboxGroupInput("sel_CharType",
                       label = h6("Import WQP data only from these characteristic groups: "),
                       choices = c("Biological",
                                   "Inorganics, Major, Metals",
                                   "Inorganics, Major, Non-metals",
                                   "Microbiological",
                                   "Nutrient",
                                   "Organics, Other",
                                   "Organics, PCBs",
                                   "Organics, Pesticide",
                                   "Physical",
                                   "Sediment",
                                   "Stable Isotopes",
                                   "Toxicity"),
                       selected = c("Inorganics, Major, Metals", "Inorganics, Major, Non-metals", "Microbiological", "Nutrient", "Physical")),
  
    actionButton("button_downloadData", "DOWNLOAD SELECTED DATA", width = "100%", style="color:black; background-color: lightgreen; display:inline-block; border:1px; margin:5px"),
    
    ) # end filter-import panel
  ) # end hide for filter-import panel

br()

# Download RDS to user location ----
renderUI({
  shiny::req(!is.null(rv))
  
  shiny::req(rv_param_temp$newImport == TRUE)
             
  download_button(
  outputId = "download_RDS", 
  label = "Download Formatted RDS File")
})

output$download_RDS <- downloadHandler(
  shiny::req(!is.null(rv)),
  filename = function() {
    paste0("WQdash_", rv$parkID, "_", paste0(gsub(pattern = "-", replacement = "", x = Sys.Date()), ".RDS"))
    },
    content = function(file) {
      saveRDS(isolate(reactiveValuesToList(rv)), file)
    }
  )

```

Data for Import {.tabset .tabset-fade}
-------------------------------------
<center>*NOTE:  Data collected by NPS Inventory & Monitoring are listed as 'National Park Service Water Resources Division'*</center>

<br>

### Map
```{r initial_map}
output$initial_map <- renderLeaflet({
  shiny::req(!is.null(rv_param_temp$loadMap))
  
  shiny::validate(
      need(rv_param_temp$loadMap == TRUE, message = "No data to show. From the left sidebar, please choose to load a data file or download data from web services and then click the green 'BEGIN DATA SEARCH' button"))
  
  shiny::req(!is.null(input$sel_GetData))
  if(input$sel_GetData == "new_data"){
      rv$userSelect <- list(sel_SelectMethod = input$sel_SelectMethod, sel_HUClevel = input$sel_HUClevel, sel_Organization = input$sel_Organization)} # make sure the map will show even if WQP data have not yet been imported
  
  shiny::req(!is.null(rv$parkID), !is.null(rv$userSelect$sel_Organization), !is.null(rv$sitesPointsSub))

  if(any(is.null(rv$userSelect$sel_SelectMethod), is.null(rv$userSelect$sel_HUClevel), is.null(rv$userSelect$sel_Organization), is.null(rv$unitPoly), is.null(rv$HUC10), is.null(rv$sitesPointsSub), rv$parkID=="", !rv$userSelect$sel_Organization %in% rv$sitesPointsSub@data$OrganizationFormalName)) {
      map <- leaflet()
      } else {
        map <- FuncBaseMap(maptype = "initial") # Base map, which will not react to user selections
        
        # Initial map controls
        map %<>%
          addLegend(title = "Data source for water quality monitoring data", pal = rv_param_temp$palOrg, values = sort(rv$userSelect$sel_Organization), group = "Map legend", position = "bottomleft") %>%
          addLayersControl(
            baseGroups = c("Street", "Satellite"),
            overlayGroups = na.omit(c("NPS unit", rv$userSelect$sel_HUClevel, "Available monitoring sites", ifelse(!is.null(rv$selectedStations), "Selected monitoring sites", NA), ifelse(!is.null(rv$facilitiesPointsSub), "Discharge facilities", NA), ifelse(!is.null(rv$gageStations), "Gage stations", NA), ifelse(!is.null(rv$meteoStations), "Weather stations", NA), "Map legend")),
            options = layersControlOptions(collapsed = TRUE)) %>%
          setView(lng = switch((is.null(isolate(input$map_center$lng))+1), isolate(input$map_center$lng), mean(rv$unitPoly@bbox["x",])), lat = switch((is.null(isolate(input$map_center$lat))+1), isolate(input$map_center$lat), mean(rv$unitPoly@bbox["y",])), zoom = input$sel_MapZoom)
      }
})

leafletOutput("initial_map", width = "100%")
  
  # User selects HUCs by clicking (when new data imported) ----
observeEvent(input$map_shape_click, {
  shiny::req(rv$userSelect$sel_SelectMethod=="methodHuc", !is.null(rv), !is.null(rv$userSelect$sel_HUClevel), !is.null(input$sel_GetData))
  shiny::req(input$sel_GetData=="new_data")
    click <- input$map_shape_click

      if(click$id %in% rv$selectedHucs) { # check if the click is in a selected HUC
          rv$selectedHucs <- rv$selectedHucs[rv$selectedHucs != click$id] # then remove it from the list of selected HUCs
      leafletProxy("map") %>% addPolygons(data = rv[[rv$userSelect$sel_HUClevel]][rv[[rv$userSelect$sel_HUClevel]]$HUC==click$id,], group = rv$userSelect$sel_HUClevel, color = "blue", fillColor = "lightblue", fillOpacity = 0.3, weight = 0.5, layerId = ~HUC, options = pathOptions(pane = "pane_HUC")) # and change the polygon to unselected color
      } else { # if the click is in an unselected HUC
        rv$selectedHucs <- c(rv$selectedHucs, click$id) # append the ID of clicked HUC polygon
        leafletProxy("map") %>% addPolygons(data = rv[[rv$userSelect$sel_HUClevel]][rv[[rv$userSelect$sel_HUClevel]]$HUC==click$id,], group = rv$userSelect$sel_HUClevel, color = "blue", fillColor = "lightblue", fillOpacity = 0.7, opacity = 1, weight = 1.5, layerId = ~HUC, options = pathOptions(pane = "pane_HUC"))
      } # and change the polygon to selected color
  }, ignoreInit = TRUE) # end of observeEvent
```

### Selected Sites

```{r summarize_locations}
output$table_selected_orgs <- renderReactable({
  # shiny::validate(
    # need(!is.null(rv$dat), message = "No data available. Please first import or load water quality data.")) # can't call FuncOrderCheck from in here
  shiny::req(!is.null(rv$dat), !is.null(rv$sitesPointsSub), !is.null(rv$userSelect$sel_Organization))
          
  df_site <- rv$sitesPointsSub@data %>%
    dplyr::filter(MonitoringLocationIdentifier %in% rv$selectedStations$MonitoringLocationIdentifier & OrganizationFormalName %in% rv$userSelect$sel_Organization) %>%
    dplyr::select(OrganizationFormalName, MonitoringLocationIdentifier, MonitoringLocationName, MonitoringLocationTypeName, Latitude = LatitudeMeasure, Longitude = LongitudeMeasure) %>%
    left_join(rv$dat %>% dplyr::select(MonitoringLocationIdentifier, MeteoYr, CharacteristicName), by = "MonitoringLocationIdentifier") %>%
    dplyr::distinct() %>%
    group_by_at(vars(-MeteoYr, -CharacteristicName)) %>%
    mutate(SiteStartYr = min(MeteoYr, na.rm = TRUE), 
           SiteEndYr = max(MeteoYr, na.rm = TRUE),
           TotalSurveyYrs = dplyr::n_distinct(MeteoYr)) %>%
    group_by_at(vars(-MeteoYr)) %>%
    dplyr::mutate(PercParamYrs = n()/TotalSurveyYrs) %>%
    dplyr::filter(PercParamYrs >=.8) %>% # only keep parameters that were surveyed in at least 80% of years the site was surveyed
    dplyr::select(-MeteoYr, -PercParamYrs) %>%
    dplyr::distinct() %>%
    arrange(CharacteristicName) %>%
    group_by_at(vars(-CharacteristicName)) %>%
    summarise_all(funs(paste(na.omit(.), collapse = " // "))) %>% # for each site, the characteristics surveyed in at least 80% of survey years
    dplyr::rename(TopCharacteristics = CharacteristicName) 
  
  df_site$TopCharacteristics[df_site$TotalSurveyYrs < 3] <- NA # if a site was surveyed less than 3 years, TopCharacteristics is NA (otherwise can get, e.g., huge list of characteristics surveyed only once because site surveyed only once)
  
    df_org <- rv$orgs %>% # alternatively, these column calculations can all be done within reactable()
      dplyr::filter(OrganizationFormalName %in% rv$userSelect$sel_Organization) %>%
      dplyr::select(-Selected) %>%
      left_join(df_site %>% ungroup() %>% dplyr::select(OrganizationFormalName, TotalSurveyYrs), by = "OrganizationFormalName") %>%
      dplyr::add_count(OrganizationFormalName) %>%
      dplyr::rename(NumSites = n) %>%
      dplyr::group_by_at(vars(-TotalSurveyYrs)) %>%
      dplyr::mutate(MinYrsSiteSurveyed = min(TotalSurveyYrs, na.rm = TRUE),
                    MedianYrsSiteSurveyed = median(TotalSurveyYrs, na.rm = TRUE),
                    MaxYrsSiteSurveyed = max(TotalSurveyYrs, na.rm = TRUE)) %>%
      dplyr::select(-TotalSurveyYrs) %>%
      dplyr::distinct() %>%
      arrange(OrganizationFormalName)
    
  reactable(
    df_org,
    columns = list(
      OrganizationFormalName = colDef(name = "Organization"),
      Phone = colDef(width = 120),
      NumSites = colDef(header = with_tooltip("# of Sites", "# of sites with data imported (based on user-defined import filters)"), width = 100, align = "center"),
      MinYrsSiteSurveyed = colDef(header = with_tooltip("Min", "Minimum # of years surveyed at a site"), width = 70, align = "center"),
      MedianYrsSiteSurveyed = colDef(header = with_tooltip("Median", "Median # of years surveyed at a site (50% of sites have been surveyed for longer)"), width = 75, align = "center"),
      MaxYrsSiteSurveyed = colDef(header = with_tooltip("Max", "Maximum # of years surveyed at a site"), width = 70, align = "center")
      ),
    columnGroups = list(
      colGroup(name = "# of Years Surveyed", columns = c("MinYrsSiteSurveyed", "MedianYrsSiteSurveyed", "MaxYrsSiteSurveyed"))
      ),
    details = function(index) {
      site_info <- df_site[df_site$OrganizationFormalName == df_org$OrganizationFormalName[index], ]
      htmltools::div(style = "padding: 50px",
                     reactable(site_info, 
                               columns = list(
                                 OrganizationFormalName = colDef(show = FALSE),
                                 MonitoringLocationIdentifier = colDef(name = "Site ID", minWidth = 140),
                                 MonitoringLocationName = colDef(name = "Site", minWidth = 140),
                                 MonitoringLocationTypeName = colDef(name = "Type", width = 100, align = "center"),
                                 Latitude = colDef(width = 85, align = "center"),
                                 Longitude = colDef(width = 85, align = "center"),
                                 SiteStartYr = colDef(name = "Start", width = 85, align = "center"),
                                 SiteEndYr = colDef(name = "End", width = 85, align = "center"),
                                 TotalSurveyYrs = colDef(
                                   header = with_tooltip("# of Years Site Surveyed", "Full (gray) bar length is maximum # of years among all (imported) sites surveyed by the organization, red bar length is # of years this site surveyed (a site may not be surveyed every year)"),
                                   width = 150,
                                   cell = function(value) {
                                     width <- paste0(value * 100 / max(site_info$TotalSurveyYrs), "%")
                                     bar_chart(value, width = width, fill = "#fc5185", background = "#e1e1e1")
                                     }),
                                 TopCharacteristics = colDef(
                                   header = with_tooltip("Top Characteristics Surveyed", "These characteristics were surveyed in at least 80% of site's survey years. If site has been surveyed less than 3 years, then characteristics are not listed"),
                                   minWidth = 250)
                               ),
                               columnGroups = list(
                                 colGroup(name = "Calendar Years Surveyed", columns = c("SiteStartYr", "SiteEndYr"))),
                               defaultSorted = list(TotalSurveyYrs = "desc"),
                               resizable = TRUE,
                               filterable = TRUE,
                               striped = FALSE,
                               highlight = TRUE,
                               showSortIcon = TRUE, 
                               compact = TRUE,
                               pagination = FALSE,
                               outlined = FALSE,
                               bordered = FALSE,
                               theme = reactableTheme(backgroundColor = "hsl(186, 56%, 94%)")
                               )
      )
    },
    resizable = TRUE, 
    filterable = FALSE,
    striped = FALSE,
    highlight = TRUE,
    showSortIcon = TRUE,
    compact = FALSE,
    bordered = TRUE,
    showPageSizeOptions = TRUE, 
    onClick = "select")
})
reactableOutput("table_selected_orgs")
tags$style("#table_selected_orgs{height:100vh;overflow-x:scroll;overflow-y:scroll}")
```

Filter WQP Data
======================================

Inputs {.sidebar data-width=320}
-------------------------------------

```{r define_filter_sidebar}
br()

strong("Data Filter Options")

br()

renderUI({
  shiny::req(!is.null(rv$dat))
  checkboxInput("sel_FilterYrSeason",
                label = "Show options to filter by year & season",
                value = switch(is.null(input$sel_FilterYrSeason)+1,
                               input$sel_FilterYrSeason, TRUE))
  })

shinyjs::hidden( # initially hide this well panel
  wellPanel(
    id = "wp_filter_yr_season",
        
    renderUI({
      shiny::req(!is.null(rv$dat$MeteoYr))
      sliderInput("sel_YrRange",
                  label = h6("Select range of years to summarize:"),
                  min = min(rv$dat$MeteoYr, na.rm = TRUE),
                  max = max(rv$dat$MeteoYr, na.rm = TRUE), 
                  step = 1, 
                  sep="", 
                  value = c(min(rv$dat$MeteoYr, na.rm = TRUE), max(rv$dat$MeteoYr, na.rm = TRUE)),
                  dragRange = TRUE, 
                  width = "85%")
      }),
    
    renderUI({
      numericInput("sel_MinYrs",
                 h6("Only show site-characteristic combinations with number of survey years exceeding: "), 
                 min = 0, 
                 step = 1, 
                 value = 1)
    }),
        
    renderUI({
      shiny::req(!is.null(rv$dat))
      numericInput("sel_MinStations",
                    h6("Only show characteristics meeting filter requirements for this minimum number of sites:"),
                   min = 1,
                   step = 1,
                   value = 1)
                   
    }),
    
        renderUI({
      radioButtons("sel_DefineSeasons",
                 label = h6("Define seasons as: "),
                 choiceNames = c("Meteorological seasons (calendar year)", "USGS water year seasons (starts Oct. 1)", "Custom seasons (up to 4)"),
                 choiceValues = c("MeteoSeasons", "WaterSeasons", "CustomSeasons"),
                 selected = switch(is.null(input$sel_DefineSeasons)+1, input$sel_DefineSeasons, "MeteoSeasons"))
      }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons")
      
      sliderInput("sel_SeasonsStart", 
                  label = "Starting day for season level 1:", 
                  min = as.Date("2018-01-01"), # avoid leap year
                  max = as.Date("2018-12-31"), 
                  value = switch(is.null(input$sel_SeasonsStart)+1, input$sel_SeasonsStart, as.Date("2018-01-01")), 
                  timeFormat = "%b-%d")
      }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", !is.null(input$sel_SeasonsStart))
      textInput("sel_Season1Name",
                label = "LEVEL 1 name and range (inclusive)",
                value = "CustomSeason1",
                placeholder = "E.g., Summer")
    }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", !is.null(input$sel_SeasonsStart))
      sliderInput("sel_Season1Range",
                  label = NULL,
                  min = input$sel_SeasonsStart, 
                  max = input$sel_SeasonsStart + 364,
                  step = 1,
                  value = c(input$sel_SeasonsStart, input$sel_SeasonsStart + 364), 
                  timeFormat = "%b-%d")
    }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons), !is.null(input$sel_SeasonsStart), !is.null(input$sel_Season1Range[2]))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", input$sel_Season1Range[2] < (input$sel_SeasonsStart + 364))
      br()
      textInput("sel_Season2Name",
                label = "LEVEL 2 name and start/end (inclusive)",
                placeholder = "E.g., Summer")
    }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons), !is.null(input$sel_SeasonsStart), !is.null(input$sel_Season1Range[2]))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", input$sel_Season1Range[2] < (input$sel_SeasonsStart + 364))
      sliderInput("sel_Season2Range",
                  label = NULL,
                  min = input$sel_SeasonsStart, 
                  max = input$sel_SeasonsStart + 364,
                  step = 1,
                  value = c(input$sel_Season1Range[2] + 1, input$sel_SeasonsStart + 364), 
                  timeFormat = "%b-%d")
    }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons), !is.null(input$sel_SeasonsStart), !is.null(input$sel_Season2Range[2]))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", input$sel_Season2Range[2] < (input$sel_SeasonsStart + 364))
      br()
      textInput("sel_Season3Name",
                label = "LEVEL 3 name and start/end (inclusive)",
                placeholder = "E.g., Summer")
    }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons), !is.null(input$sel_SeasonsStart), !is.null(input$sel_Season2Range[2]))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", input$sel_Season2Range[2] < (input$sel_SeasonsStart + 364))
      sliderInput("sel_Season3Range",
                  label = NULL,
                  min = input$sel_SeasonsStart, 
                  max = input$sel_SeasonsStart + 364,
                  step = 1,
                  value = c(input$sel_Season2Range[2] + 1, input$sel_SeasonsStart + 364), 
                  timeFormat = "%b-%d")
    }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons), !is.null(input$sel_SeasonsStart), !is.null(input$sel_Season3Range[2]))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", input$sel_Season3Range[2] < (input$sel_SeasonsStart + 364))
      br()
      textInput("sel_Season4Name",
                label = "LEVEL 4 name and start/end (inclusive)",
                placeholder = "E.g., Summer")
    }),
    
    renderUI({
      shiny::req(!is.null(input$sel_DefineSeasons), !is.null(input$sel_SeasonsStart), !is.null(input$sel_Season3Range[2]))
      shiny::req(input$sel_DefineSeasons == "CustomSeasons", input$sel_Season3Range[2] < (input$sel_SeasonsStart + 364))
      sliderInput("sel_Season4Range",
                  label = NULL,
                  min = input$sel_SeasonsStart, 
                  max = input$sel_SeasonsStart + 364, 
                  step = 1,
                  value = c(input$sel_Season3Range[2] + 1, input$sel_SeasonsStart + 364), 
                  timeFormat = "%b-%d")
    })
    )
)  # end of 'wp_filter_yr_season'
  
# Filter data by WQ characteristic
# renderUI({
#   checkboxInput("sel_FilterWQChar",
#                 label = "Show options to filter by water quality characteristic",
#                 value = switch(is.null(input$sel_FilterWQChar)+1, input$sel_FilterWQChar, TRUE))
# 
#   })

# shinyjs::hidden( # initially hide this well panel
  wellPanel(
    id = "wp_filter_wqchar",

    renderUI({
      shiny::req(!is.null(rv$dat))
      checkboxInput("sel_NPSparam",
                    "Only show characteristics reported by NPS for the imported monitoring sites",
                    value = "National Park Service Water Resources Division" %in% rv$dat$OrganizationFormalName)
    }),
    
    renderUI({
            shiny::req(!is.null(rv$dat), !is.null(input$sel_NPSparam), !is.null(input$sel_YrRange), !is.null(input$sel_SummaryOrg), !is.null(input$sel_ActivityType), !is.null(input$sel_ResultStatus), !is.null(input$sel_MinYrs), !is.null(input$sel_MinStations))

rv_param_temp$selectParam <- rv$dat %>% 
        {if (input$sel_NPSparam == TRUE & "National Park Service Water Resources Division" %in% rv$dat$OrganizationFormalName) dplyr::filter(., OrganizationFormalName == "National Park Service Water Resources Division") else .} %>%
        dplyr::filter(ResultDetectionConditionText != "Not Reported") %>%
        dplyr::mutate(Yr = MeteoYr) %>%
        dplyr::filter(Yr >= as.integer(input$sel_YrRange[1]) & Yr <= as.integer(input$sel_YrRange[2]) & OrganizationFormalName %in% input$sel_SummaryOrg & ActivityTypeCode %in% input$sel_ActivityType & ResultStatusIdentifier %in% input$sel_ResultStatus) %>%
        dplyr::select(CharacteristicName, MonitoringLocationIdentifier, Yr) %>%
        dplyr::distinct() %>%
        group_by(CharacteristicName, MonitoringLocationIdentifier) %>%
        dplyr::mutate(TotalSurveyYrs = dplyr::n_distinct(Yr)) %>%
        dplyr::filter(TotalSurveyYrs >= input$sel_MinYrs) %>%
        dplyr::select(-Yr) %>%
        dplyr::distinct() %>%
        dplyr::ungroup() %>%
        dplyr::count(CharacteristicName) %>%
        dplyr::filter(n >= input$sel_MinStations) %>%
        .$CharacteristicName

      shiny::req(!is.null(rv_param_temp$selectParam))

      checkboxGroupInput("sel_SummaryParam",
                         label = h6("Water quality characteristics to summarize: "),
                         choices = sort(rv_param_temp$selectParam),
                         selected = switch(is.null(input$sel_SummaryParam)+1, input$sel_SummaryParam, rv_param_temp$selectParam[rv_param_temp$selectParam %in% c("Dissolved oxygen (DO)", "Escherichia coli", "Flow, severity (choice list)", "Flow, stream stage (choice list)", "Nitrate", "pH", "Specific conductance", "Temperature, water", "Turbidity")])
      )
    }),

renderUI({
  shiny::req(!is.null(rv_param_temp$selectParam))

      FuncAllNoneButtons(cond = "input.sel_SummaryParam", name_all = "button_allSummaryParam", name_none = "button_noSummaryParam")
})
)
# ) # end of 'wp_filter_wqchar'

# Filter data by organization
renderUI({
  checkboxInput("sel_FilterOrg",
                label = "Show options to filter by organization",
                value = switch(is.null(input$sel_FilterOrg)+1, input$sel_FilterOrg, TRUE))
  })

shinyjs::hidden( # initially hide this well panel
  wellPanel(
    id = "wp_filter_org",
    
    renderUI({
      checkboxGroupInput("sel_SummaryOrg",
                         label = h6("Organizations to summarize: "),
                         choices = sort(unique(rv$dat$OrganizationFormalName)),
                         selected = switch(is.null(input$sel_SummaryOrg)+1, input$sel_SummaryOrg, sort(unique(rv$dat$OrganizationFormalName))))
    })
    )
  ) # end of 'wp_filter_org'

# Filter data by sampling characteristics
renderUI({
  checkboxInput("sel_FilterSamplingChars",
                label = "Show options to filter by sampling characteristics",
                value = switch(is.null(input$sel_FilterSamplingChars)+1, input$sel_FilterSamplingChars, TRUE))
  })
  
shinyjs::hidden( # initially hide this well panel
  wellPanel(
    id = "wp_filter_sampling_chars",
    
    renderUI({
      checkboxGroupInput("sel_ActivityType",
                         label = h6("Include these activity types: "),
                         choices = sort(unique(rv$dat$ActivityTypeCode)),
                         selected = sort(intersect(unique(rv$dat$ActivityTypeCode), c("Field Msr/Obs", "Sample", "Sample-Routine"))))
      }),
    
    renderUI({
      checkboxGroupInput("sel_ResultStatus",
                         label = h6("Include these result statuses: "),
                         choices = sort(unique(rv$dat$ResultStatusIdentifier)),
                         selected = sort(intersect(unique(rv$dat$ResultStatusIdentifier), c("Accepted", "Final"))))
      }),
    
    renderUI({
      shiny::req(any(!is.na(rv$dat$ActivityBottomDepthHeightMeasure.MeasureValue)))
      shiny::req(length(sort(unique(rv$dat$ActivityBottomDepthHeightMeasure.MeasureValue))) > 1)
      
      checkboxInput("sel_LimitDepths",
                    label = h6("Limit the range of sampling depth"),
                    value = FALSE)
      }),
    
    renderUI({
      shiny::req(!is.null(input$sel_LimitDepths))
      shiny::req(
        any(!is.na(rv$dat$ActivityBottomDepthHeightMeasure.MeasureValue)),
        length(sort(unique(rv$dat$ActivityBottomDepthHeightMeasure.MeasureValue))) > 1,
        input$sel_LimitDepths == TRUE)
      conditionalPanel(
        condition = "input.sel_LimitDepths==true",
        em("Only data with recorded sampling depth and measurement unit will be included"),
        radioButtons("sel_DepthUnit",
                     label = "Recorded measurement unit: ",
                     choices = sort(unique(rv$dat$ActivityDepthHeightMeasure.MeasureUnitCode)),
                     selected = switch(is.null(input$sel_DepthUnit)+1, input$sel_DepthUnit, sort(unique(rv$dat$ActivityDepthHeightMeasure.MeasureUnitCode))[1])),
        
        numericInput("sel_MinDepth",
                     label = "Minimum depth to include: ",
                     value = switch(is.null(input$sel_MinDepth)+1, input$sel_MinDepth, min(rv$dat$ActivityBottomDepthHeightMeasure.MeasureValue, na.rm = TRUE))),
        
        numericInput("sel_MaxDepth",
                     label = "Maximum depth to include: ",
                     value = switch(is.null(input$sel_MaxDepth)+1, input$sel_MaxDepth, max(rv$dat$ActivityBottomDepthHeightMeasure.MeasureValue, na.rm = TRUE)))
        )
      }) # end of limit depths conditional panel
  )
) # end of 'wp_filter_sampling_chars'

br()

# strong("Define threshold limits")
# 
# radioButtons("sel_GetThreshFile",
#              label = h6("Method for generating file:"),
#              choices = c("Attach threshold limits file from computer" = "existing_data", "Follow steps to create a threshold limits file" = "new_data"))
# actionButton("button_getThreshFile", "Add a Threshold Limits File", width = "100%") 
# 
# br()
  
strong("Sample Size Matrix Options")

renderUI({
      shiny::req(!is.null(rv_param_temp$subDat))
      radioButtons("sel_TimeSubunit",
               label = h6("Time unit for 'Filtered Data Sample Sizes'"),
               choices = c("Month" = "Mnth", "Season" = "Season"),
               selected = switch(is.null(input$sel_TimeSubunit)+1, input$sel_TimeSubunit, "Season"))
    })
```


Define & Filter Data {.tabset .tabset-fade}
-------------------------------------
### Filtered Data Summary

#### <font size="3">**Sites and survey years by parameter, for filtered data**</font>

* <font size="2"> The full list of characteristics for the filtered data are shown under 'Water quality characteristics to summarize', in the left sidebar. Only 'checked' characteristics are shown in this table.</font> 

* <font size="2"> The filtered data shown here will be used on the Explore WQP Data page.</font>

* <font size="2"> Years and seasons are defined by the user as meteorological seasons (calendar year), USGS water year seasons (starts Oct. 1), or custom-defined seasons (see 'Define seasons as:' in left sidebar). These year and season definitions will be used on all subsequent pages of the dashboard.</font>

```{r filter_summary}
output$table_filtered_chars <- renderReactable({
  shiny::validate(
     need(!is.null(rv$dat), message = "No data available. Please use the 'Get WQP Data' tab to first import or load water quality data."))
  # shiny::validate(
    # need(!is.null(rv_param_temp$subDat) & !is.null(rv_param_temp$subDatTypes), message = "From the left sidebar, select new filter criteria (or use default settings) and then click the green 'REFRESH FILTER' button"))
  
  FuncFilterDat()
  
  if(!is.null(rv_param_temp$subDat)) {
    rv_param_temp$subDatTypes <- as.data.frame(FuncDataTypes(dat = rv_param_temp$subDat))}
    shiny::req(!is.null(rv_param_temp$subDatTypes), !is.null(rv_param_temp$subDatYears))
    
    df_char <- rv_param_temp$subDatTypes %>%
      left_join(rv_param_temp$subDatYears %>% ungroup() %>% dplyr::select(CharacteristicName, TotalSurveyYrs), by = "CharacteristicName") %>%
  dplyr::add_count(CharacteristicName) %>%
  dplyr::rename(NumSites = n) %>%
  dplyr::group_by_at(vars(-TotalSurveyYrs)) %>%
  dplyr::mutate(MinYrsSiteSurveyed = min(TotalSurveyYrs, na.rm = TRUE),
                MedianYrsSiteSurveyed = median(TotalSurveyYrs, na.rm = TRUE),
                MaxYrsSiteSurveyed = max(TotalSurveyYrs, na.rm = TRUE)) %>%
  dplyr::select(-TotalSurveyYrs) %>%
  dplyr::distinct() %>%
  arrange(CharacteristicName)
                
  reactable(
    df_char,
    columns = list(
      CharacteristicName = colDef(name = "Characteristic"),
      DataType = colDef(header = with_tooltip("Data Type", "The characteristic is classified as 'categorical' if any entry is non-numeric (excluding missing data)"), width = 100, align = "center"),
      NonNumericEntries = colDef(header = with_tooltip("Non-Numeric Entries", "Lists all non-numeric entries for a characteristic classified as 'categorical'. Includes entries with mathematical symbols, e.g., '< 2.5', because these cannot be interpreted as a number (if these values are detection thresholds, the Water Quality Portal defines an appropriate way for such data to be entered, so they can be used in analyses)"), minWidth = 110),
      NumSites = colDef(header = with_tooltip("# of Sites", "# of sites with data imported (based on user-defined import filters)"), width = 100, align = "center"),
    MinYrsSiteSurveyed = colDef(header = with_tooltip("Min", "Minimum # of years surveyed at a site"), width = 70, align = "center"),
    MedianYrsSiteSurveyed = colDef(header = with_tooltip("Median", "Median # of years surveyed at a site (50% of sites have been surveyed for longer)"), width = 75, align = "center"),
    MaxYrsSiteSurveyed = colDef(header = with_tooltip("Max", "Maximum # of years surveyed at a site"), width = 70, align = "center"),
      NumRecords = colDef(header = with_tooltip("# of Records", "Total number of data records for this characteristic"), width = 80, align = "center")
    ),
    columnGroups = list(
    colGroup(name = paste0("# of ", rv_param_temp$seasonType, " Surveyed"), columns = c("MinYrsSiteSurveyed", "MedianYrsSiteSurveyed", "MaxYrsSiteSurveyed"))
  ),
    details = function(index) {
      site_info <- rv_param_temp$subDatYears[rv_param_temp$subDatYears$CharacteristicName == df_char$CharacteristicName[index], ]
      htmltools::div(style = "padding: 20px",
                     reactable(site_info,
                               columns = list(
                                 CharacteristicName = colDef(show = FALSE),
                                 MonitoringLocationIdentifier = colDef(name = "Site ID"),
                                 StartYr = colDef(name = "Start", width = 90, align = "center"),
                               EndYr = colDef(name = "End", width = 90, align = "center"),
                               TotalSurveyYrs = colDef(
                                 header = with_tooltip("# of Years Site Surveyed", "Full (gray) bar length is maximum # of years among all (filtered) sites that data have been collected on this characteristic, red bar length is # of years this site  has collected data on this characteristic"),
                                 width = 150,
                                 cell = function(value) {
                                   width <- paste0(value * 100 / max(site_info$TotalSurveyYrs), "%")
                                   bar_chart(value, width = width, fill = "#fc5185", background = "#e1e1e1")
                                 }),
                               NumRecords = colDef(name = "# of Records", width = 80, align = "center")),
                               columnGroups = list(
                               colGroup(name = paste0(rv_param_temp$seasonType, " Surveyed"), columns = c("StartYr", "EndYr"))),
                               defaultSorted = list(TotalSurveyYrs = "desc"),
                     resizable = TRUE,
                     filterable = TRUE,
                     striped = FALSE,
                     highlight = TRUE,
                     showSortIcon = TRUE,
                     compact = TRUE,
                     pagination = FALSE,
                     outlined = FALSE,
                     bordered = FALSE,
                     theme = reactableTheme(backgroundColor = "hsl(186, 56%, 94%)")
      )
  )
      },
  defaultSorted = list(CharacteristicName = "asc"),
    resizable = TRUE, 
    filterable = FALSE,
    striped = FALSE,
    highlight = TRUE,
    showSortIcon = TRUE,
    compact = FALSE,
    bordered = TRUE,
    showPageSizeOptions = TRUE)

  })
reactableOutput("table_filtered_chars")
tags$style("#table_filtered_chars{height:100vh;overflow-x:scroll;overflow-y:scroll}")

```

### Sample Size Matrix

```{r sample_sizes}
  
output$out_SamplePlots <- renderPlot({ 
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_TimeSubunit))
  
  withProgress(message = "Generating plots", detail = "...calculating sample sizes", value = 0, {
  # Create sample size matrix
  
          N_dat <- rv_param_temp$subDat %>%
            dplyr::rename(TimeUnit = input$sel_TimeSubunit) %>%

            dplyr::group_by(CharacteristicName, MonitoringLocationIdentifier, TimeUnit, Yr) %>%
            dplyr::summarise(FillCol = n()) %>%
            dplyr::ungroup()
          
          # Fill missing values
          heatmap_dat <- merge(
            N_dat %>%
              dplyr::select(CharacteristicName, MonitoringLocationIdentifier) %>%
    dplyr::distinct(), expand_grid(TimeUnit = levels(N_dat$TimeUnit), Yr = min(N_dat$Yr, na.rm = TRUE):max(N_dat$Yr, na.rm = TRUE))) %>%
            left_join(N_dat, by = c("CharacteristicName", "MonitoringLocationIdentifier", "TimeUnit", "Yr")) %>%
            dplyr::mutate(TimeUnit = factor(TimeUnit, levels = levels(rv_param_temp$subDat[[input$sel_TimeSubunit]]))) %>%
            dplyr::arrange(CharacteristicName, MonitoringLocationIdentifier, TimeUnit, Yr)
          shiny::req(!is.null(heatmap_dat)) 
          
          rv_param_temp$filterNPlot <- FuncPlotHeatMap(dat = heatmap_dat, y_name = input$sel_TimeSubunit,  legend_name = "# of Survey Events")
          FuncRefreshFilterShowOptions(set_value = FALSE)
  })
          rv_param_temp$filterNPlot
  },
  height = reactive({switch(is.null(rv_param_temp$filterNPlot)+1, (250*nrow(rv_param_temp$filterNPlot$grobs[[1]]))+30*nrow(rv_param_temp$subDat %>% dplyr::select(CharacteristicName, MonitoringLocationIdentifier) %>% dplyr::distinct())*(1+length(levels(rv_param_temp$subDat[[input$sel_TimeSubunit]]))), 400)}),
                    width = reactive({switch(is.null(rv_param_temp$filterNPlot)+1, max(800, 25*(max(rv_param_temp$subDat$Yr, na.rm = TRUE)-min(rv_param_temp$subDat$Yr, na.rm = TRUE)+1)+100), 800)})
)
tags$style("#out_SamplePlots{height:100vh;overflow-x:scroll;overflow-y:scroll}")
plotOutput("out_SamplePlots", height="100%", width = "100%")
```

<!-- Define Categorical Characters {.hidden} -->
Define Categorical Characters
====================================== 

Leftside Panel  {data-width=210}
-------------------------------------

###

```{r categfile_leftside_panel} 
useShinyjs(rmd = TRUE)
# Panel for user to initiate color coding file ----

strong("File for defining categorical data")

radioButtons("sel_GetCategFile",
               label = h6("Method for generating file:"),
               choices = c("Attach file from computer" = "existing_data", "Follow steps to create a file" = "new_data"),
             selected = "new_data")

actionButton("button_getCategFile", "Create Definitions File", width = "100%")

br()

br()

# Panel to select a categorical characteristic
shinyjs::hidden(
wellPanel(
  id = "create_categfile_P1",
  p(strong("1. Identify a categorical characteristic")),
  
  renderUI({
    shiny::req(!is.null(rv_param_temp$subDatTypes))
    shiny::req(input$sel_GetCategFile == "new_data")
    conditionalPanel(
      condition = "input.sel_GetCategFile == 'new_data'",

      selectInput("sel_CategParam",
                  label = "",
                  choices = rv_param_temp$subDatTypes$CharacteristicName[rv_param_temp$subDatTypes$DataType == "categorical"],
                  selected = switch(is.null(input$sel_CategParam)+1, input$sel_CategParam, rv_param_temp$subDatTypes$CharacteristicName[rv_param_temp$subDatTypes$DataType == "categorical"][1]))
      )
    })
  ) # end create_categfile_P1
) # end hidden

# Panel to set categorical levels (and, if applicable, their order) ----
shinyjs::hidden(
  wellPanel(
  id = "create_categfile_P2",
  p(strong("2. Specify category levels")),
         renderUI({
           shiny::req(!is.null(input$sel_GetCategFile), !is.null(input$sel_CategParam))

              rv_param_temp$categLevels <- rv$dat %>% dplyr::filter(CharacteristicName == input$sel_CategParam, !is.na(ResultMeasureValue)) %>% dplyr::select(ResultMeasureValue) %>% dplyr::distinct() %>% arrange() # can't just assign a vector to a reactive value initially assigned as NULL because it's expecting a dataframe or a single variable
              
              shiny::req(input$sel_GetCategFile == "new_data")
           conditionalPanel(
             condition = "input.sel_GetCategFile == 'new_data'",
             
             splitLayout(
  cellWidths = c("35%", "35%", "30%"),

             actionButton("button_addCategLevel", "Add a Level"), # user can add a category level that is not present in the data
             actionButton("button_deleteCategLevel", "Delete a Level") # user can set category levels to NA)
             ),

             renderUI({rank_list( # wrap in renderUI to update when user adds or deletes a level
               text = "List of category levels (drag to rearrange order)",
               labels = rv_param_temp$categLevels$ResultMeasureValue,
               input_id = "categ_ranked") # this is the ID for the ranked category vector
             })
           )
         })
) # end create_categfile_P2
) # end hidden
```

Middle Panel  {data-width=190}
-------------------------------------

###

```{r categfile_middle_panel}

# Panel to assign colors to category levels ----

shinyjs::hidden(
  wellPanel(
    id = "create_categfile_P3",
    p(strong("3. Assign colors to category levels")),

    actionButton("button_showPalettes", "Show All Color Palettes", width = "100%"),
    
    br(),
    
    renderUI({
      selectizeInput("sel_CategPalette", # using selectize so user can start by typing in text
                   label = h6("Select a color palette to apply"),
                   choices = c("YlOrRd", "YlOrBr", "YlGnBu", "YlGn", "Reds", "RdPu", "Purples", "PuRd", "PuBuGn", "PuBu", "OrRd", "Oranges", "Greys", "Greens", "GnBu", "BuPu", "BuGn", "Blues", "Set3", "Set2", "Set1", "Pastel2", "Pastel1", "Paired", "Dark2", "Accent", "Spectral", "RdYlGn", "RdYlBu", "RdGy", "RdBu", "PuOr", "PRGn", "PiYG", "BrBG"),
                   multiple = FALSE,
                   selected = switch(is.null(input$sel_CategPalette)+1, input$sel_CategPalette, "YlGnBu"))
      }),
    
    actionButton("button_updateCategFile", "Add to Color Coding File", width = "100%")
    ) # end of well panel 'create_categfile_P3'
) # end hidden

# Show the colors that will be associated with color levels ----
  renderPlot({
    if(any(is.null(input$sel_GetCategFile), is.null(input$sel_CategPalette), is.null(input$categ_ranked), input$sel_GetCategFile == "existing_data")) {
     plot(NULL, xaxt='n', yaxt='n', bty='n', ylab='', xlab='', xlim=0:1, ylim=0:1)
    } else {
      plot(NULL, xaxt='n', yaxt='n', bty='n', ylab='', xlab='', xlim=0:1, ylim=0:1)
  legend("topleft", legend = input$categ_ranked, pch=16, pt.cex=2.5, cex=1.25, bty='n', col = get_brewer_pal(input$sel_CategPalette, length(input$categ_ranked), plot = FALSE))
  mtext(input$sel_CategParam, at = 0.25, cex=1.25)
    }
  })
```

Rightside Panel {data-width=400}
-------------------------------------

<center>*Double-click in any cell to edit contents. To delete a row, click it once to select and then choose 'Delete Selected Row(s).'*</center>

```{r categfile_categ_table}
renderUI({
  FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = FALSE)
  shiny::req(!is.null(rv$userSelect$sel_Organization), !is.null(rv$sitesPointsSub))
  if(any(!rv$userSelect$sel_Organization %in% rv$sitesPointsSub@data$OrganizationFormalName))
    {rv_param_temp$categLevels <- tibble("CharacteristicName" = as.character(), "CategOrder" =as.character(), "CategColor" = as.character())} # initiate a blank categorical levels data frame if the data have not been updated
  })

# splitLayout(
#   cellWidths = c("35%", "35%", "30%"),
# actionButton("button_categAddRow", "Add a Row", width = "200px"),
# actionButton("button_categDeleteRow", "Delete Selected Row(s)", width = "200px")
# )

br()

br()

output$categDT <- DT::renderDT({
  shiny::req(!is.null(rv_param_temp$categLevelsPlot))
  rv_param_temp$categLevelsPlot}, editable = TRUE)

proxyDT <- DT::dataTableProxy("categDT")
    
dataTableOutput("categDT")

downloadLink("button_exportCateg", label = "Save table as .csv for future use")

output$button_exportCateg <- downloadHandler(
  filename = function() {
    return(paste0("WQdash_categ_", rv$parkID, "_", paste0(gsub(pattern = "-", replacement = "", x = Sys.Date())),".csv"))
    },
  content = function(file) {
    write_csv(rv_param_temp$categLevelsPlot, file)
    }
  )

```

Explore WQP Data
======================================  

Inputs {.sidebar data-width=330}
-------------------------------------
```{r summary_sidebar}  
br()

actionButton("button_refreshPlotData", "REFRESH PLOT DATA", style="border-color:black; background-color: lightgreen; width:100%; border:0px; margin:0px") # updates plots
  
br()

wellPanel(
  id = "summarize_char_stations",
  p(strong("Select data to plot")),
  
renderUI({
  radioButtons("sel_SummarizeBy",
               label = h6(" Summarize by:"),
               choiceNames = list("ONE CHARACTERISTIC for many stations", "many characteristics for ONE STATION"),
               choiceValues = list("by_char", "by_station"),
               selected = "by_station")
  }),

renderPrint({input$sel_ShowOneStation}),
renderPrint({input$sel_ShowStations}),
# Generate bold, red warning if characteristic sets with different measurement units are compared for a single characteristic
tags$div(renderText({ 
  shiny::req(!is.null(rv_param_temp$finalPlot$plotly_page), !is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$showCharSets))

  char_incomp <- rv_param_temp$plotDat %>% dplyr::group_by(CharacteristicName) %>% dplyr::summarize(num_units = length(unique(na.omit(ResultMeasure.MeasureUnitCode)))) %>% dplyr::ungroup() %>% dplyr::filter(num_units > 1) %>% .$CharacteristicName

  if(length(char_incomp) > 0) {
    paste0("WARNING!! It looks like you're summarizing data with different measurement units for these characteristics: ", paste(char_incomp, collapse = ", "), ". Results are NOT VALID if the selected units are not comparable.")  # Post a warning if it looks like different measurement units are being compared
  }
}), style = "font-size:14px; color:red;"), # could also bold it... font-weight:bold; 

hr(),

# If summarizing by characteristic (ONE CHARACTERISTIC for many stations)...
renderUI({
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(rv_param_temp$subDatTypes))
  shiny::req(input$sel_SummarizeBy == "by_char")
  
  selectInput("sel_ShowChar",
                  label = h6("Select a characteristic to plot:"),
                  choices = sort(intersect(unique(rv_param_temp$subDat$CharacteristicName), rv_param_temp$subDatTypes$CharacteristicName[rv_param_temp$subDatTypes$DataType == "numeric"])),
                  selected = input$sel_ShowChar)
}),

renderUI({
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowChar))
  shiny::req(input$sel_SummarizeBy == "by_char")
  
  checkboxGroupInput("sel_ShowStations",
                          label = h6("Select monitoring site(s):"),
                          choices =  sort(unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowChar])),
                          selected = input$sel_ShowStations
  )# don't do switch here because will cause problems with select all/none
  
  }),

renderUI({
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowChar))
  shiny::req(input$sel_SummarizeBy == "by_char")
  
      FuncAllNoneButtons(cond = "input.sel_ShowStations", name_all = "button_allStations", name_none = "button_noStations")
}),

renderUI({
    shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowChar), !is.null(input$sel_ShowStations))
  shiny::req(input$sel_SummarizeBy == "by_char")
        
        checkboxGroupInput("sel_ShowCharSets",
                         label = h6("Select characteristic set(s):"),
                         choices = sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName==input$sel_ShowChar & rv_param_temp$subDat$MonitoringLocationIdentifier %in% input$sel_ShowStations])),
                         selected = sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName==input$sel_ShowChar & rv_param_temp$subDat$MonitoringLocationIdentifier %in% input$sel_ShowStations])))
        }),

renderUI({
   shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowChar), !is.null(input$sel_ShowStations))
  shiny::req(input$sel_SummarizeBy == "by_char")
    
    FuncAllNoneButtons(cond = "input.sel_ShowCharSets", name_all = "button_allCharSets", name_none = "button_noCharSets")
    }),

# If summarizing by station (many characteristics for ONE STATION)...
renderUI({
    shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat))
  shiny::req(input$sel_SummarizeBy == "by_station")
  
    selectInput("sel_ShowOneStation",
                label = h6("Select a monitoring site:"),
                choices = sort(unique(rv_param_temp$subDat$MonitoringLocationIdentifier)),
                selected = input$sel_ShowOneStation)
}),

renderUI({
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(rv_param_temp$subDatTypes), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
    
    checkboxGroupInput("sel_ShowStationChars",
              label = h6("Select characteristic(s):"),
              choices = sort(intersect(unique(rv_param_temp$subDat$CharacteristicName[rv_param_temp$subDat$MonitoringLocationIdentifier == input$sel_ShowOneStation]), rv_param_temp$subDatTypes$CharacteristicName[rv_param_temp$subDatTypes$DataType == "numeric"])),
              selected = input$sel_ShowStationChars
              ) # don't do switch here because will cause problems with select all/none
}),

renderUI({
  shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(rv_param_temp$subDatTypes), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
    
    FuncAllNoneButtons(cond = "input.sel_ShowStationChars", name_all = "button_allStationChars", name_none = "button_noStationChars")
}),

renderUI({
   shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowStationChars), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
          
    checkboxGroupInput("sel_ShowStationCharSets",
                         label = h6("Select characteristic set(s):"),
                         choices = sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowStationChars & rv_param_temp$subDat$MonitoringLocationIdentifier == input$sel_ShowOneStation])),
                         selected = sort(unique(rv_param_temp$subDat$CharacteristicSet[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowStationChars & rv_param_temp$subDat$MonitoringLocationIdentifier == input$sel_ShowOneStation])))
    
}),

renderUI({
   shiny::req(!is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$subDat), !is.null(input$sel_ShowStationChars), !is.null(input$sel_ShowOneStation))
  shiny::req(input$sel_SummarizeBy == "by_station")
    
    FuncAllNoneButtons(cond = "input.sel_ShowStationCharSets", name_all = "button_allStationCharSets", name_none = "button_noStationCharSets")
    })
)# end of wellPanel

wellPanel(
  id = "plot_display_options",
  p(strong("Display Options")),
  
radioButtons("sel_PlotType",
             label = h6("Plot type:"),
             choiceNames = list("Points", "Points + Smooth", "Box Plots (per year)"),
             choiceValues = list("points", "points_smooth", "box"),
             selected = "points_smooth"),

selectInput("sel_SeasonalTimeUnit",
              label = h6("SEASONAL patterns time unit:"),
              choices = c("Day of Year" = "DayOfYr", "Week of Year" = "Wk", "Month of Year" = "Mnth", "Season of Year" = "Season"),
              selected = "Mnth"),

selectInput("sel_YScale",
                label = h6("Scale for y-axis:"),
                choices = c("Identity" = "identity", "Ln()" = "log"),
                selected = "identity"),

renderUI({
  checkboxInput("sel_PlotByStation",
                        label = h6("Show one monitoring site per plot"),
                        value = switch(is.null(input$sel_PlotByStation)+1, input$sel_PlotByStation, TRUE))
}),

renderUI({
  checkboxInput("sel_FreeY",
                        label = h6("Allow y-axis to differ across plots"),
                        value = switch(is.null(input$sel_FreeY)+1, input$sel_FreeY, FALSE))
  }),

  renderUI({
    radioButtons("sel_Categ",
                 label = h6("Color point plots by a categorical characteristic:"),
                 choices = switch((!is.null(rv_param_temp$categLevelsPlot) & !is.null(input$sel_SummaryParam))+1, "none", c("none", sort(intersect(input$sel_SummaryParam, unique(rv_param_temp$categLevelsPlot$CharacteristicName))))),
                 selected = "none")
    }),

p(strong("Add streamflow/precip")),
  
  # Additional plot
  renderUI({
    radioButtons("sel_AddGagePrecip",
                 label = h6("Add external data plot: "),
                 choices = c("none", "streamflow", "precipitation"),
                 selected = switch(is.null(input$sel_AddGagePrecip)+1, input$sel_AddGagePrecip, "none")
                 )
  }),
  
  # Add streamflow plot
  renderUI({
    shiny::req(!is.null(input$sel_AddGagePrecip))
    shiny::req(input$sel_AddGagePrecip == "streamflow")
    shiny::validate(
      need(!is.null(rv$selectedGages) & !is.null(rv$gagesDat), message = "No streamflow data imported"))
    conditionalPanel(
      condition = "input.sel_AddGagePrecip == 'streamflow'", 
      selectInput("sel_GageStation", # choose a gage station
                  label = "Select a gage station for streamflow data",
                  choices = sort(unique(rv$selectedGages$GageName)),
                  selected = switch(is.null(input$sel_GageStation)+1, input$sel_GageStation, sort(unique(rv$selectedGages$GageName))[1])),
      
      selectInput("sel_gage_YScale",
                  label = "Scale for streamflow y-axis:",
                  choices = c("Identity" = "identity", "Ln()" = "log"),
                  selected = switch(is.null(input$sel_gage_YScale)+1, input$sel_gage_YScale, "identity"))
      )
    }),
  
  # Add precipitation plot
  renderUI({
    shiny::req(!is.null(input$sel_AddGagePrecip))
    shiny::req(input$sel_AddGagePrecip == "precipitation")
    shiny::validate(
      need(!is.null(rv$selectedMeteo) & !is.null(rv$meteoDat), message = "No precipitation data imported"))
    conditionalPanel(
      condition = "input.sel_AddGagePrecip == 'precipitation'",
      selectInput("sel_PrecipStation", # choose a weather station
                  label = "Select a weather station",
                  choices = sort(unique(rv$selectedMeteo$MeteoName)),
                  selected = switch(is.null(input$sel_PrecipStation)+1, input$sel_PrecipStation, sort(unique(rv$selectedMeteo$MeteoName))[1])),
      
      selectInput("sel_precip_YScale",
                  label = "Scale for precipitation y-axis:",
                  choices = c("Identity" = "identity", "Ln()" = "log"),
                  selected = switch(is.null(input$sel_precip_YScale)+1, input$sel_precip_YScale, "identity"))
      )
    })
) # end of well panel

wellPanel(
  id = "define_limits",
  p(strong("Define threshold and percentile limits")),
  
  renderUI({ 
    shiny::req(!is.null(rv_param_temp$subDat))
    radioButtons("sel_ShowThresholds",
                 label = h6("Show threshold limits on plot"),
                 choiceNames = c("Do not show", "Use threshold limits from attached file", "Use limits entered below for the selected characteristic"),
                 choiceValues = c("showthresh_none", "showthresh_file", "showthresh_custom"),
                 selected = switch(is.null(input$sel_Thresholds)+1, switch((input$sel_SummarizeBy=="site")+1, input$sel_Thresholds, "showthresh_none"), switch(is.null(rv_param_temp$threshList)+1, "showthresh_file", "showthresh_none"))
    )
    }),
  
  renderUI({ # Set threshold limits
    shiny::req(!is.null(rv_param_temp$subDat), !is.null(input$sel_ShowThresholds), !is.null(input$sel_SummarizeBy))
    shiny::req(input$sel_ShowThresholds == "showthresh_custom")
    conditionalPanel(
      condition = "input.sel_ShowThresholds == 'showthresh_custom'",
      shiny::validate(need(input$sel_SummarizeBy == "by_char", message = "This option is available only when summarizing by characteristic (not by station)")),
        selectInput("sel_ThreshUnit",
                    label = "Threshold measure unit",
                    choices = sort(unique(na.omit(rv_param_temp$subDat$ResultMeasure.MeasureUnitCode[ rv_param_temp$subDat$CharacteristicName == input$sel_ShowChar]))),
                    selected = switch(is.null(input$sel_ThreshUnit)+1, input$sel_ThreshUnit, sort(unique(na.omit(rv_param_temp$subDat$ResultMeasure.MeasureUnitCode[ rv_param_temp$subDat$CharacteristicName == input$sel_ShowChar])))[1])
        ),
        numericInput("sel_ThreshLower",
                     label = "Enter a lower threshold limit (use -999 for no lower limit)",
                     value = -999,
                     min = NA,
                     max = NA,
                     step = NA),
        numericInput("sel_ThreshUpper",
                     label = "Enter an upper threshold limit (use 999 for no upper limit)",
                     value = 999,
                     min = NA,
                     max = NA,
                     step = NA)
    )
    }),
  
  br(),

  renderUI({
  checkboxInput("sel_AddQuantile",
              label = h6("Add percentile lines to plot"),
              value = switch(is.null(input$sel_AddQuantile)+1, input$sel_AddQuantile, TRUE))
    }),
  
  renderUI({
    shiny::req(!is.null(input$sel_AddQuantile),
               !is.null(input$sel_SummarizeBy))
    shiny::req(input$sel_AddQuantile == TRUE)
    conditionalPanel(
      condition = "input.sel_AddQuantile == true",
      numericInput("sel_QuantileProbLower",
                 label = "Enter lower percentile limit (or 0 for no lower limit)",
                 value = 0.05,
                 min = 0.0,
                 max = 1.0,
                 step = 0.05),
      numericInput("sel_QuantileProbUpper",
                 label = "Enter upper percentile limit (or 1 for no upper limit)",
                 value = 0.95,
                 min = 0.0,
                 max = 1.0,
                 step = 0.05),
      # if(input$sel_SummarizeBy == "by_char") {
        selectInput("sel_QuantileGroupBy",
                 label = "Calculate percentile limits:",
                 choices = c("per site" = "quant_each",
                             "across sites" = "quant_all"),
              selected = "quant_all")
        # } # <<<<<<<<<<<<<< REALLY THIS SHOULD ONLY SHOW IF BY_CHAR, BUT I NEED AN ENTRY REGARDLESS
      )
    })
  ) # end of wellPanel
```

Column
-------------------------------------

### Map of selected monitoring sites

```{r map input}
br()

splitLayout(
  cellWidths = c("40%", "60%"),
  renderUI({
  shiny::req(!is.null(input$sel_SummarizeBy))
  selectInput("sel_ParamMapShow",
              label = h6("Show on map: "),
              choices = switch((input$sel_SummarizeBy == "by_char")+1, c("SELECTABLE monitoring sites" = "show"), c("SELECTABLE monitoring sites" = "show", "Overall median value" = "overall_median", "Overall threshold levels" = "overall_thresh", "Annual median value" = "median", "Annual threshold levels" = "thresh", "Annual percentile levels" = "perc")),
              selected = "show") # <<<<<<<<< NEED TO CALC OVERALLS STILL
  }),
  verticalLayout(
      renderUI({
  shiny::req(!is.null(rv$unitPoly))
  map_zoom <- min(RgoogleMaps::MaxZoom(lonrange = rv$unitPoly@bbox["x",], latrange = rv$unitPoly@bbox["y",]))
  sliderInput("sel_ParamMapZoom", label = h6("Set map zoom (smaller = wider view):"), min = max(1, map_zoom - 6), max = 15, value = map_zoom - 1, step = 0.5, ticks = FALSE, dragRange = FALSE, width = "95%")
  }),
    renderUI({
  shiny::req(!is.null(rv$unitPoly), !is.null(rv_param_temp$plotSummarizeBy), !is.null(rv_param_temp$plotDat), !is.null(input$sel_ParamMapShow))
      # shiny::req(input$sel_ParamMapShow %in% c("thresh", "perc"))
  # shiny::req(rv_param_temp$plotSummarizeBy == "by_char", length(unique(rv_param_temp$plotDat$Yr)) > 0)
  sliderTextInput("sel_SurvYr", force_edges = TRUE, label = h6("Choose a survey year"), choices = sort(unique(rv_param_temp$plotDat$Yr)), selected = max(rv_param_temp$plotDat$Yr, na.rm = TRUE), dragRange = FALSE, animate = TRUE, width = "85%")
  }),
  renderUI({
  shiny::req(!is.null(rv$unitPoly), !is.null(rv_param_temp$plotSummarizeBy), !is.null(rv_param_temp$plotDat), !is.null(input$sel_ParamMapShow))
  # shiny::req(rv_param_temp$plotSummarizeBy == "by_char")
    # shiny::req(input$sel_ParamMapShow %in% c("thresh", "perc"))
    sliderInput("sel_MapPointSize", label = "Resize map pie charts:", min = 10, max = 60, value = 30, step = 10, ticks = FALSE, dragRange = FALSE, width = "95%")
    })
  )
)


# wellPanel(
#   id = "summarize_map_options",
#   p(strong("MAP OPTIONS")),
#     
# renderUI({ 
#   shiny::req(!is.null(input$sel_SummarizeBy))
#   selectInput("sel_ParamMapShow",
#               label = h6("Show on map: "),
#               choices = switch((input$sel_SummarizeBy == "by_char")+1, c("SELECTABLE monitoring sites" = "show"), c("SELECTABLE monitoring sites" = "show", "Overall median value" = "overall_median", "Overall threshold levels" = "overall_thresh", "Annual median value" = "median", "Annual threshold levels" = "thresh", "Annual percentile levels" = "perc")),
#               selected = "show") # <<<<<<<<< NEED TO CALC OVERALLS STILL
# }),
#   
# renderUI({
#   shiny::req(!is.null(rv_param_temp$plotSummarizeBy), !is.null(rv_param_temp$plotDat), !is.null(input$sel_ParamMapShow)) 
#   shiny::req(rv_param_temp$plotSummarizeBy == "by_char", length(unique(rv_param_temp$plotDat$Yr)) > 0)
#   sliderTextInput("sel_SurvYr", force_edges = TRUE, label = h6("Choose a survey year"), choices = sort(unique(rv_param_temp$plotDat$Yr)), selected = max(rv_param_temp$plotDat$Yr, na.rm = TRUE), dragRange = FALSE, animate = TRUE, width = "85%")
#   }),
# 
# renderUI({
#   shiny::req(!is.null(rv$unitPoly))
#   map_zoom <- min(RgoogleMaps::MaxZoom(lonrange = rv$unitPoly@bbox["x",], latrange = rv$unitPoly@bbox["y",]))
#   sliderInput("sel_ParamMapZoom", label = h6("Set map zoom (smaller = wider view):"), min = max(1, map_zoom - 6), max = 15, value = map_zoom - 0.5, step = 0.5, ticks = FALSE, dragRange = FALSE, width = "95%")
# }),
# 
# renderUI({
#   shiny::req(!is.null(rv$unitPoly))
#   sliderInput("sel_MapPointSize", label = "Resize map pie charts:", min = 10, max = 60, value = 30, step = 10, ticks = FALSE, dragRange = FALSE, width = "95%")
# }) # <<<<<<<<<<<<<<< THIS DOESN'T SEEM TO DO ANYTHING
# )
```

```{r param_map}

div(style="display:inline-block;", renderPrint({rv_param_temp$param_map_highlight}))


output$param_map <- renderLeaflet({

  FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = FALSE) # make sure data have been imported and filtered, and plot data have been generated
  # 
  shiny::req(!is.null(rv_param_temp$subDat), !is.null(rv$sitesPointsSub), !is.null(rv$unitPoly), !is.null(rv$userSelect), !is.null(input$sel_SummarizeBy), !is.null(rv_param_temp$palOrg), !is.null(input$sel_ParamMapShow))
cat("RENDERING ENTIRE MAP AGAIN\n")
  tags$style(type = "text/css", "#param_map {height: calc(100vh - 80px) !important;}") # expand map to fill screen

  iconGages = makeAwesomeIcon(
    text = fa("water"),
    iconColor = "black",
    markerColor = "blue")
iconGagesSelected = makeAwesomeIcon(
    text = fa("water"),
    iconColor = "black",
    markerColor = "orange")
iconMeteo = makeAwesomeIcon(icon= "fa-cloud", library = "fa", squareMarker = TRUE, markerColor = "white")
  iconMeteoSelected = makeAwesomeIcon(icon= "fa-cloud", library = "fa", squareMarker = TRUE, markerColor = "orange") #
  iconCWA = makeAwesomeIcon(icon= "fa-building", library = "fa", markerColor = "lightgray")

  param_map <- leaflet(options = leafletOptions(zoomControl = FALSE, zoomSnap = 0.25)) %>%
    addMapPane("pane_param_selectedStations", zIndex = 250) %>% # higher index is on top
    addMapPane("pane_param_availableStations", zIndex = 245) %>%
    addMapPane("pane_param_polylines", zIndex = 230) %>%
    addMapPane("pane_param_facilitiesPointsSub", zIndex = 226) %>%
    addMapPane("pane_param_gageStations", zIndex = 225) %>%
    addMapPane("pane_param_gageStations_selected", zIndex = 227) %>%
    addMapPane("pane_param_meteoStations", zIndex = 225) %>%
    addMapPane("pane_param_meteoStations_selected", zIndex = 227) %>%
    addMapPane("pane_param_HUC", zIndex = 220) %>%
    addMapPane("pane_param_unitPoly", zIndex = 210) %>%
    addTiles(options = tileOptions(noWrap = TRUE), group = "Street") %>%
    addProviderTiles("Esri.WorldImagery", options = providerTileOptions(noWrap = TRUE), group="Satellite") %>%
    addPolygons(data = rv$unitPoly, group = "NPS unit", color = "black", fillColor = "yellow", fillOpacity = 1, weight = 1, options = pathOptions(pane = "pane_param_unitPoly")) %>% # park unit outline
    addPolygons(data = rv[[rv$userSelect$sel_HUClevel]], group = paste0(rv$userSelect$sel_HUClevel, " boundaries"), color = "blue", fillColor = "lightblue", fillOpacity = 0.3, weight = 0.7, options = pathOptions(pane = "pane_param_HUC")) %>% # HUC polygons
    addScaleBar() %>%
    addControl(rv$parkID, position = "topleft") # add 4-letter UNIT code on map

cat("line3026")

  # Done with the standard mapping. Now to conditional layers.

  show_layers <- data.frame(layer = c(paste0(rv$userSelect$sel_HUClevel, " boundaries"), "Available monitoring sites", "Selected monitoring sites", "Imported stream lines", "Discharge facilities", "Available gage stations", "Available weather stations"), show = c(TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE)) # dataframe to track what layers to show
  
  if(input$sel_SummarizeBy == "by_char") { # if multiple sites per characteristic, then available sites are only those that actually have the selected characteristic
    shiny::req(!is.null(input$sel_ShowChar))
    avail_sites_data <- rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier %in% unique(rv_param_temp$subDat$MonitoringLocationIdentifier[rv_param_temp$subDat$CharacteristicName %in% input$sel_ShowChar]),]
  } else {
    avail_sites_data <- rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier %in% unique(rv_param_temp$subDat$MonitoringLocationIdentifier),]
  }
  # isolate({
cat("RENDERING AVAILABLE SITES IN FULL MAP\n")
  param_map %<>%
    addCircleMarkers(data = avail_sites_data, group = "Available monitoring sites", lat = ~LatitudeMeasure, lng = ~LongitudeMeasure, layerId = ~MonitoringLocationIdentifier, label = ~SITELAB, radius = 12, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 0.8, stroke = FALSE, color = ~rv_param_temp$palOrg(OrganizationFormalName), opacity = 0.7, options = pathOptions(pane = "pane_param_availableStations")) # WQ stations for which data (for selected parameter) are available  
cat("line1988")
# })
  

  # If UP-DOWN selection
  if(rv$userSelect$sel_SelectMethod=="methodDist") {
    show_layers$show[show_layers$layer == "Imported stream lines"] <- TRUE
  cat("line2693")
    if(!is.null(rv$selectedDownstreamLines)) { # add selected downstreams in brown
      param_map %<>%
        addPolylines(data = rv$selectedDownstreamLines, color = "brown", weight = 2, opacity = 1, options = pathOptions(pane = "pane_param_polylines"), group = "Imported stream lines")
    }
  cat("line2698")
        if(!is.null(rv$selectedUpstreamLines)) { # add selected upstreams in blue
      param_map %<>%
        addPolylines(data = rv$selectedUpstreamLines, color = "blue", weight = 2, opacity = 1, options = pathOptions(pane = "pane_param_polylines"), group = "Imported stream lines")
    }

  } else {
    show_layers$show[show_layers$layer == "Imported stream lines"] <- FALSE
  }
  cat("line2707")
  if(!is.null(rv$gageStations)) { # Add gage stations only if found
  param_map %<>%
    addAwesomeMarkers(icon = iconGages, data = rv$gageStations, lng = ~Longitude, lat = ~Latitude, group = "Available gage stations", label = ~GAGELAB, popup = ~GAGEPOP, options = pathOptions(pane = "pane_param_gageStations")) # imported stream gage stations
    show_layers$show[show_layers$layer == "Available gage stations"] <- TRUE
if(!is.null(rv$selectedGages)) {
  if(all(rv$selectedGages$GageID %in% rv$gageStations$GageID)) {
  param_map %<>%
    addAwesomeMarkers(icon = iconGagesSelected, data = rv$selectedGages, lng = ~Longitude, lat = ~Latitude, group = "Available gage stations", label = ~GAGELAB, popup = ~GAGEPOP, options = pathOptions(pane = "pane_param_gageStations_selected")) # selected stream gage stations
  }
}
} else {
    show_layers$show[show_layers$layer == "Available gage stations"] <- FALSE
  }
  cat("line2721")
  # If weather stations have been found
  if(!is.null(rv$meteoStations)) {
    param_map %<>%
      addAwesomeMarkers(icon = iconMeteo, data = rv$meteoStations, lng = ~longitude, lat = ~latitude, group = "Available weather stations", label = ~METEOLAB, popup = ~METEOPOP, options = pathOptions(pane = "pane_param_meteoStations")) # imported weather stations
    show_layers$show[show_layers$layer == "Available weather stations"] <- TRUE

    if(!is.null(rv$selectedMeteo)) {
      param_map %<>%
      addAwesomeMarkers(icon = iconMeteoSelected, data = rv$selectedMeteo, lng = ~longitude, lat = ~latitude, group = "Available weather stations", label = ~METEOLAB, popup = ~METEOPOP, options = pathOptions(pane = "pane_param_meteoStations_selected")) # selected weather stations
    }

  } else {
    show_layers$show[show_layers$layer == "Available weather stations"] <- FALSE
  }

  # If Discharge facilities have been found
  if(!is.null(rv$facilitiesPointsSub)) {
    param_map %<>%
      addAwesomeMarkers(icon = iconCWA, data = rv$facilitiesPointsSub, group = "Discharge facilities", label = ~FACLAB, popup = ~FACPOP, options = pathOptions(pane = "pane_param_facilitiesPointsSub"))
    show_layers$show[show_layers$layer == "Discharge facilities"] <- TRUE
  } else {
    show_layers$show[show_layers$layer == "Discharge facilities"] <- FALSE
  }
  cat("line2745")
  #

  cat("line3098")
  # Highlight selected stations
  if(input$sel_ParamMapShow == "show")
    {
    # isolate({
    # if(is.null(rv_param_temp$param_map_highlight)) { # White outline on sites selected from left panel
      # rv_param_temp$update_from_sidebar <- TRUE # so it's no longer NULL and can now be activated
    cat("RENDERING SELECTED SITES IN FULL MAP\n")
    # Need to do this on first go-around because don't yet have a param_map to update with proxy. 
      sel_sites <- switch((input$sel_SummarizeBy == "by_char") + 1, input$sel_ShowOneStation, input$sel_ShowStations)
      if(length(sel_sites) > 0) {
        param_map %<>%
      addCircleMarkers(data = rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier %in% sel_sites,], group = "Available monitoring sites", lat = ~LatitudeMeasure, lng = ~LongitudeMeasure, layerId = ~MonitoringLocationIdentifier, label = ~SITELAB, radius = 15, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 1, stroke = TRUE, weight = 4, color = "white", opacity = 1, options = pathOptions(pane = "pane_param_availableStations"))
      }
      
    # } # selected WQ stations are shown as larger, white-outlined points
    # })
    } 
  
    # Highlight selected stations
  # if(input$sel_ParamMapShow == "show" & !is.null(isolate(rv_param_temp$param_map_highlight))) { # White outline on sites selected from left panel
  #   if(length(isolate(rv_param_temp$param_temp_highlight)) > 0) {
  #           param_map %<>%
  #     addCircleMarkers(data = rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier %in% isolate(rv_param_temp$param_map_highlight),], group = "Available monitoring sites", lat = ~LatitudeMeasure, lng = ~LongitudeMeasure, layerId = ~MonitoringLocationIdentifier, label = ~SITELAB, radius = 15, fillColor = ~rv_param_temp$palOrg(OrganizationFormalName), fillOpacity = 1, stroke = TRUE, weight = 4, color = "white", opacity = 1, options = pathOptions(pane = "pane_param_availableStations")) # selected WQ stations are shown as larger, white-outlined points
      
    # }
  #   
  #     if(input$sel_SummarizeBy == "by_char" & !is.null(input$sel_ShowStations)) { # if multiple sites per characteristic, then available sites are only those that actually have the selected characteristic
  #   # if(input$sel_SummarizeBy == "by_char") { 
  #       selected_sites_data <- rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier %in% input$sel_ShowStations,]
  #     } else {
  #       
  #       if(input$sel_SummarizeBy == "by_station" & !is.null(input$sel_ShowOneStation)) {
  #     selected_sites_data <- rv$sitesPointsSub[rv$sitesPointsSub@data$MonitoringLocationIdentifier %in% input$sel_ShowOneStation,]
  #       } else {
  #       selected_sites_data <- NULL
  #     }
  #   
  # }
  #   cat("line2075")
  #   if(!is.null(selected_sites_data)) {
  #   # if(length(selected_sites_data) > 0) {

    # }
  
cat("line2095")
  # If summarizing by characteristic, then additional summary options are available
  if(input$sel_SummarizeBy == "by_char" & !is.null(input$sel_SurvYr)){

    # summarize stations by a single characteristic, user can choose from several summary functions...
    # If map choice is 'median'
    # if(input$sel_ParamMapShow == "median") {
    #   shiny::validate(need(sum(!is.na(rv_param_temp$plotDat$ResultMeasureValue)) > 0, message = "No monitoring results available for these data"))
    # 
    #   temp_median <- rv_param_temp$plotDat %>%
    #     dplyr::group_by(MonitoringLocationIdentifier, Yr) %>%
    #     summarise(median_val = round(median(ResultMeasureValue, na.rm = TRUE), 2)) %>%
    #     left_join(rv$sitesPointsSub@data[, c("MonitoringLocationIdentifier", "LatitudeMeasure", "LongitudeMeasure", "SITELAB")], by = "MonitoringLocationIdentifier") # >>>>>>>>>>>>>>>>> TRUNCATES LAT-LONG
    # 
    #   palNumeric <- colorNumeric(
    #     palette = "Reds",
    #     domain = temp_median$median_val)
    # 
    #   temp_median_plot <- temp_median %>%
    #     filter(Yr == as.numeric(input$sel_SurvYr)) %>% # Do this after setting the range of values for legend
    #     dplyr::mutate(SITEPOP = paste0("Site: ", MonitoringLocationIdentifier, "<br>Year: ", Yr, "<br>Median Value: ", median_val))
    #   param_map %<>%
    #     addControl(tags$div(tag.map.title, HTML(input$sel_ShowChar, " in Year ", input$sel_SurvYr)), position = "topleft", className="map-title") %>%
    #     addCircleMarkers(data = temp_median_plot, lat = ~LatitudeMeasure, lng = ~LongitudeMeasure, label = ~SITELAB, popup = ~SITEPOP, radius = 12, fillColor = ~palNumeric(median_val), fillOpacity = 1, color = ~palNumeric(median_val), stroke = FALSE, opacity = 1, options = pathOptions(pane = "pane_param_selectedStations")) %>%
    #     addLegend(pal = palNumeric, values = temp_median$median_val, position = "topleft", title = input$sel_ShowChar) %>%
    #     hideGroup("Available monitoring sites") %>%
    #     hideGroup("Selected monitoring sites")
    # }

    # If map choice is 'thresh'
    if(input$sel_ParamMapShow == "thresh") {
      shiny::validate(need(sum(!is.na(rv_param_temp$plotDat$ThreshCateg)) > 0, message = "No threshold limits defined for these data."))

      thresh_mat <- rv_param_temp$plotDat %>%
        dplyr::filter(!is.na(ThreshCateg)) # NA's occur when is.na(ResultMeasureValue_replaced)--these should not be included, they are just missing values

      thresh_list <- switch(rv_param_temp$threshType,
                          showthresh_file = rv_param_temp$threshList,
                          showthresh_custom = rv_param_temp$threshCustom,
                          showthresh_none = NULL)

      thresh_mat$ThreshCateg <- factor(thresh_mat$ThreshCateg, levels = thresh_list[[1]]$cut_categ) # ensures that a column is created even if a factor level is not in the data
      thresh_mat %<>%
        filter(Yr == as.numeric(input$sel_SurvYr)) %>%
        group_by(MonitoringLocationIdentifier) %>%
        dplyr::count(ThreshCateg) %>%
        spread(key = ThreshCateg, value = n, drop = FALSE, fill = 0) %>%
        left_join(subset(rv$sitesPointsSub@data, select = c("MonitoringLocationIdentifier", "LatitudeMeasure", "LongitudeMeasure", "SITELAB")), by = "MonitoringLocationIdentifier") %>%
        ungroup()
      param_map %<>%
        addControl(tags$div(tag.map.title, HTML(input$sel_ShowChar, " in Year ", input$sel_SurvYr)), position = "topleft", className="map-title") %>%
        addMinicharts(
          lng = thresh_mat$LongitudeMeasure,
          lat = thresh_mat$LatitudeMeasure,
          time = thresh_mat$Yr,
          type = "pie",
          transitionTime = 0,
          layerId = thresh_mat$SITELAB,
          height = input$sel_MapPointSize,
          width = input$sel_MapPointSize,
          chartdata = as.matrix(subset(thresh_mat, select = thresh_list[[1]]$cut_categ)),
          colorPalette = thresh_list[[1]]$cut_colors,
          opacity = 1) %>%
        hideGroup("Available monitoring sites")%>%
        hideGroup("Selected monitoring sites")
    }
    cat("lnie2658")
    
    # If map choice is 'perc'
    if(input$sel_ParamMapShow == "perc") {
      shiny::validate(need(sum(!is.na(rv_param_temp$plotDat$PercCateg)) > 0, message = "No percentile limits set for these data"))

      perc_mat <- rv_param_temp$plotDat %>%
        dplyr::filter(!is.na(PercCateg)) %>% # NA's occur when is.na(ResultMeasureValue_replaced)--these should not be included, they are just missing values
        filter(Yr == as.numeric(input$sel_SurvYr)) %>%
        group_by(MonitoringLocationIdentifier, Yr) %>%
        dplyr::count(PercCateg) %>%
        spread(key = PercCateg, value = n, drop = FALSE, fill = 0) %>%
        left_join(subset(rv$sitesPointsSub@data, select = c("MonitoringLocationIdentifier", "LatitudeMeasure", "LongitudeMeasure", "SITELAB")), by = c("MonitoringLocationIdentifier")) %>%
        ungroup()
      param_map %<>% addControl(tags$div(tag.map.title, HTML(input$sel_ShowChar, " in Year ", input$sel_SurvYr)), position = "topleft", className="map-title") %>%
        addMinicharts(
          lng = perc_mat$LongitudeMeasure,
          lat = perc_mat$LatitudeMeasure,
          time = perc_mat$Yr,
          type = "pie",
          transitionTime = 0,
          height = input$sel_MapPointSize,
          width = input$sel_MapPointSize,
          layerId = perc_mat$SITELAB,
          chartdata = as.matrix(perc_mat[, c("below", "between", "above")]),
          colorPalette = c("lightgray", "#56B4E9", "orange"),
          opacity = 1) %>%
        hideGroup("Available monitoring sites") %>%
        hideGroup("Selected monitoring sites")
    }
  }
  param_map %<>%
    hideGroup("Available gage stations") %>%
    hideGroup("Available weather stations") %>%
    hideGroup("Discharge facilities") %>%
    addLayersControl(
      baseGroups = c("Street", "Satellite"),
      overlayGroups = show_layers$layer[show_layers$show == TRUE],
      options = layersControlOptions(collapsed = TRUE)) %>% # set map view at current settings or, if initial map viewing, set to initial defaults. Irritating that it blinks every time, but it seems this can't be easily addressed with leaflet (html-based) outputs
    setView(lng = switch((is.null(input$param_map_center$lng))+1, input$param_map_center$lng, mean(rv$unitPoly@bbox["x",])), lat = switch((is.null(input$param_map_center$lat))+1, input$param_map_center$lat, mean(rv$unitPoly@bbox["y",])), zoom = input$sel_ParamMapZoom)

})
leafletOutput('param_map', height="100%", width = "100%")

```

Column {.tabset .tabset-fade}
-------------------------------------

### Time Series

```{r TS_plots_legend}
# renderPlot({ # separate validation statements so they are checked in sequence
#   shiny::req(!is.null(rv$userSelect), !is.null(rv$sitesPointsSub), !is.null(rv_param_temp))
#   if(any(!rv$userSelect$sel_Organization %in% rv$sitesPointsSub@data$OrganizationFormalName, is.null(rv_param_temp$finalPlot$shared_legend), is.null(rv_param_temp$showStations), is.null(rv_param_temp$showCharSets), is.null(rv_param_temp$finalPlot$shared_legend))) { # this if-statement forces the plot to be reset to blank when these conditions apply
#     ts_plotly_legend <- ggplot(dat = data.frame()) + theme_minimal()
#   } else {
#     ts_plotly_legend <- grid.arrange(rv_param_temp$finalPlot$shared_legend)
#   }
#   ts_plotly_legend
# }, height = 40) # setting the width here or at the 'Legend' subheading seems to rescale the height too. Size of ggplot legends is absolute. Set height through the 'Legend' subheading in combination with here. Legend width will not adjust with browser window. Fixed the width issue by putting the plot notes on a white background.
```

```{r TS_plots}
renderPlotly({ # separate validation statements so they are checked in sequence

  FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = FALSE)
cat("line5039")

  shiny::validate(
    need(!is.null(rv_param_temp$showCharSets) & !is.null(rv_param_temp$showStations), message = "From the left sidebar, please select characteristic(s), characteristic set(s) and monitoring site(s) to plot, then click the green 'REFRESH PLOT DATA' button"))

  shiny::validate(
    need(length(unique(na.omit(rv_param_temp$subDat$ResultSampleFractionText[rv_param_temp$subDat$CharacteristicSet %in% rv_param_temp$showCharSets]))) < 2 | rv_param_temp$plotSummarizeBy == "by_station", message = "Cannot combine characteristic sets with different sample fractions (e.g., dissolved vs. total)"))

    if(!is.null(input$sel_PlotByStation) & !is.null(rv_param_temp$showStations)) {
      shiny::validate(need(length(rv_param_temp$showStations) < 6 | input$sel_PlotByStation == TRUE, message = "The maximum number of monitoring sites to display in a single plot is FIVE. From the left sidebar, please either select 'Show one monitoring site per plot' or reduce the number of sites to display."))
    }
cat("line2220")
  # shiny::req(!is.null(rv_param_temp$plotDat), !is.null(rv_param_temp$quantDat))
  cat("line2222")
  if(!is.null(rv_param_temp$plotDat) &!is.null(rv_param_temp$quantDat)) {
    rv_param_temp$finalPlot <- FuncPlotPage(plot_type = input$sel_PlotType, plot_dat = rv_param_temp$plotDat, quant_dat = rv_param_temp$quantDat, time_unit = "ActivityStartDate", free_y = input$sel_FreeY, y_scale = input$sel_YScale)
    cat("line2224")
  }
    
    # shiny::req(!is.null(rv_param_temp$finalPlot$plotly_page))
    cat("line2226")
  
    rv_param_temp$finalPlot$plotly_page
    })
unlink("Rplots.pdf")
```

### Seasonal Patterns

```{r seasonal_plots_legend}
# renderPlot({ # separate validation statements so they are checked in sequence
#   shiny::req(!is.null(rv$userSelect), !is.null(rv$sitesPointsSub), !is.null(rv_param_temp))
#   if(any(!rv$userSelect$sel_Organization %in% rv$sitesPointsSub@data$OrganizationFormalName, is.null(rv_param_temp$seasonalPlot$shared_legend), is.null(rv_param_temp$showStations), is.null(rv_param_temp$showCharSets), is.null(rv_param_temp$seasonalPlot$shared_legend))) { # this if-statement forces the plot to be reset to blank when these conditions apply
#     ts_plotly_legend <- ggplot(dat = data.frame()) + theme_minimal()
#   } else {
#     ts_plotly_legend <- grid.arrange(rv_param_temp$seasonalPlot$shared_legend)
#   }
#   ts_plotly_legend
# }, height = 40) # setting the width here or at the 'Legend' subheading seems to rescale the height too. Size of ggplot legends is absolute. Set height through the 'Legend' subheading in combination with here. Legend width will not adjust with browser window. Fixed the width issue by putting the plot notes on a white background.
```

```{r seasonal_plots}
renderPlotly({
  
    FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = FALSE)
  
  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$subDat),  !is.null(rv_param_temp$subDatTypes))

  shiny::validate(
    need(!is.null(rv_param_temp$showCharSets) & !is.null(rv_param_temp$showStations), message = "From the left sidebar, please select characteristic set(s) and monitoring site(s) to plot, then click the green 'REFRESH PLOT DATA' button"))

  shiny::validate(
    need(length(unique(na.omit(rv_param_temp$subDat$ResultSampleFractionText[rv_param_temp$subDat$CharacteristicSet %in% input$sel_ShowCharSets]))) < 2, message = "Cannot combine characteristic sets with different sample fractions (e.g., dissolved vs. total)"))

  if(!is.null(input$sel_PlotByStation) & !is.null(rv_param_temp$showStations)) {
    shiny::validate(need(length(rv_param_temp$showStations) < 6 | input$sel_PlotByStation == TRUE, message = "The maximum number of monitoring sites to display in a single plot is FIVE. From the left sidebar, please either select 'Show one monitoring site per plot' or reduce the number of sites to display."))
  }
    
  shiny::req(!is.null(rv_param_temp$plotDat), !is.null(rv_param_temp$quantDat))
  
    rv_param_temp$seasonalPlot <- FuncPlotPage(plot_type = input$sel_PlotType, plot_dat = rv_param_temp$plotDat, quant_dat = rv_param_temp$quantDat, time_unit = rv_param_temp$seasonalTimeUnit, free_y = input$sel_FreeY, y_scale = input$sel_YScale)

  shiny::req(!is.null(rv_param_temp$seasonalPlot$plotly_page))
  rv_param_temp$seasonalPlot$plotly_page
})
unlink("Rplots.pdf")
```

### Annual Threshold Levels

```{r pie_thresh}
output$out_ThreshPie <- renderPlotly({

  # FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = TRUE)

  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$subDat),  !is.null(rv_param_temp$subDatTypes), !is.null(rv_param_temp$plotDat))
shiny::req(!is.null(rv_param_temp$plotSummarizeBy))
shiny::validate(need(rv_param_temp$plotSummarizeBy == "by_char", message = "Currently, this display is available only when summarizing by characteristic (not by station)"))

shiny::req(!is.null(rv_param_temp$threshType))
shiny::validate(need(!is.null(rv_param_temp$threshType != "showthresh_none"), "In the left sidebar, choose to define custom threshold limits or import limits from a file, then click the green 'REFRESH PLOT DATA' button"))

thresh_list <- switch(rv_param_temp$threshType,
                          showthresh_file = rv_param_temp$threshList,
                          showthresh_custom = rv_param_temp$threshCustom)

shiny::validate(need(!is.null(thresh_list), message = "No threshold limits defined"))

thresh_ID = paste0(unique(na.omit(rv_param_temp$plotDat$CharacteristicName)), " (", unique(na.omit(rv_param_temp$plotDat$ResultMeasure.MeasureUnitCode)), ")")
shiny::validate(need(!is.null(thresh_list[[thresh_ID]]), message = paste0("No threshold limits defined for ", thresh_ID)))

  threshPieDat <- FuncPieDat(limit_type = "ThreshCateg")
  
  shiny::validate(
    need(!is.null(threshPieDat), message = "No threshold limits defined"))
  
  thresh_named_colors <- thresh_list[[thresh_ID]]$cut_colors
  thresh_named_levels <- thresh_list[[thresh_ID]]$cut_categ
  
  thresh_plot_title <- paste0("Threshold levels by ", switch((rv_param_temp$plotSummarizeBy == "by_char")+1, "water quality characteristic", "monitoring site"), " (rows) and year (cols) for ", switch((rv_param_temp$plotSummarizeBy == "by_char")+1, unique(rv_param_temp$plotDat$MonitoringLocationIdentifier), unique(rv_param_temp$plotDat$CharacteristicName)))
  
  thresh_pie <- FuncPlotlyPieMatrix(dat = threshPieDat %>% dplyr::filter(!is.na(CategVar)), discrete_cols = thresh_named_colors, discrete_levels = thresh_named_levels, plot_title = thresh_plot_title)
  })

tags$style("#out_ThreshPie{height:100vh;overflow-x:scroll;overflow-y:scroll}")
plotlyOutput('out_ThreshPie', height="100%", width = "100%")
```

### Annual Percentile Levels

```{r pie_perc}
output$out_PercPie <- renderPlotly({
  # FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = TRUE)
  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$subDat),  !is.null(rv_param_temp$subDatTypes), !is.null(rv_param_temp$plotDat))
          
  percPieDat <- FuncPieDat(limit_type = "PercCateg")
  
  shiny::validate(
    need(!is.null(percPieDat), message = "No percentile data calculated"))
  shiny::req(!is.null(rv_param_temp$plotSummarizeBy), !is.null(input$sel_AddQuantile))

  perc_named_colors <- c("lightgray", "#56B4E9", "orange")

  perc_named_levels <- c("below", "between", "above")

  plot_title <- paste0("Percentile levels by ", switch((rv_param_temp$plotSummarizeBy == "by_char")+1, "WQ characteristic", "monitoring site"), " (rows) and year (cols) for ", switch((rv_param_temp$plotSummarizeBy == "by_char")+1, unique(rv_param_temp$plotDat$MonitoringLocationIdentifier), unique(rv_param_temp$plotDat$CharacteristicName)), " calculated", switch((input$sel_QuantileGroupBy=="quant_all")+1, " separately by site", " for all sites combined"))

  perc_pie <- FuncPlotlyPieMatrix(dat = percPieDat %>% dplyr::filter(!is.na(CategVar)), discrete_cols = perc_named_colors, discrete_levels = perc_named_levels, plot_title = plot_title)
  })

tags$style("#out_PercPie{height:100vh;overflow-x:scroll;overflow-y:scroll}")
plotlyOutput('out_PercPie', height="100%", width = "100%")
```

Summary Tables {.hidden}
======================================
Inputs {.sidebar data-width=355}
-------------------------------------
```{r plot_data_sidebar}

br()

 # >>>>>>>>>>>>>>> PICK UP FROM HERE --THIS PAGE GENERATES WARNING MESSAGE ABOUT TEXT TO BE WRITTEN MUST BE ONE CHARACTER VECTOR?? <<<<<<<<<<<<<<<<<<<<<<<
# renderUI({
#   shiny::req(!is.null(rv_param_temp$plotSummarizeBy))
#   radioButtons("sel_SummaryTab",
#                label = h6("In summary table, group data by: "),
#                choiceNames = switch((rv_param_temp$plotSummarizeBy=="by_station")+1, c("WQ station", "WQ station & Year"), c("WQ characteristic", "WQ characteristic & Year")),
#                choiceValues = switch((rv_param_temp$plotSummarizeBy=="by_station")+1, c("sum_station", "sum_station_yr"), c("sum_char", "sum_char_yr")),
#                selected = switch((rv_param_temp$plotSummarizeBy=="by_station")+1, "sum_station", "sum_char")
#                )
#   })
# 
#   wellPanel(
#     id = "raw_plot_cols",
#     em(tags$a(href="https://www.waterqualitydata.us/portal_userguide/#WQPUserGuide-Table5", "Click for Variable Definitions", target="_blank")),
# 
#     br(),
# 
#     renderUI({
#       shiny::req(!is.null(rv_param_temp$plotDat))
#       checkboxGroupInput("sel_PlotDataCols",
#                        label = "Variables to show in 'Raw Plot Data': ",
#                        choices = sort(names(rv_param_temp$plotDat)),
#                        selected = switch(is.null(input$sel_PlotDataCols)+1, input$sel_PlotDataCols, Reduce(intersect, list(c("OrganizationFormalName", "MonitoringLocationIdentifier", "CharacteristicName", "ActivityStartDate", "ResultMeasureValue", "PercCateg", "ThreshCateg"), names(rv_param_temp$plotDat))))
#       )
#       })
#   )
```

Plot Data Tables {.tabset .tabset-fade}
-------------------------------------

### Plot Data Summary
```{r plot_summary}
# output$plotDT <- DT::renderDT({
#   FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = TRUE)
#   shiny::req(!is.null(input$sel_SummaryTab), !is.null(rv_param_temp$plotSummarizeBy), !is.null(rv_param_temp$plotDat), !is.null(rv_param_temp$plotSummary))
# 
# 
#   temp_plotsummary <- DT::datatable(
#     rv_param_temp$plotSummary,
#     escape = FALSE,
#     filter = "top",
#     rownames = FALSE,
#     selection = "none",
#     options = list(
#       pageLength = 10,
#       lengthMenu = c(5, 10, 15, 20),
#       columnDefs = list(
#         list(className = 'dt-center', targets = "_all"))
#       )
#     )
# })
# plot_proxyDT <- DT::dataTableProxy("plotDT", session = session)
# dataTableOutput("plotDT")
# tags$style("#plotDT{height:100vh;overflow-x:scroll;overflow-y:scroll}")
```

### Raw Plot Data
*Raw data used to generate the time series plots. For a list of all possible data columns, click "Show column options for 'Raw Plot Data' table" (in left sidebar)*
```{r plot_raw_data}
# output$table_raw_plot <- DT::renderDT({
#   FuncOrderCheck(import = TRUE, filter_internal = FALSE, filter_external = TRUE, plot = TRUE)
#   shiny::req(!is.null(rv_param_temp$plotDat), !is.null(input$sel_PlotDataCols))
# 
#   DT::datatable(
#     rv_param_temp$plotDat %>%
#       dplyr::select(input$sel_PlotDataCols),
#     filter = "top",
#     rownames = FALSE,
#     selection = "none",
#     options = list(
#       pageLength = 10,
#       lengthMenu = c(5, 10, 15, 20),
#       columnDefs = list(list(className = "dt-center", targets = "_all"))))
# })
# 
# DTOutput("table_raw_plot")
# tags$style("#table_raw_plot{height:100vh;overflow-x:scroll;overflow-y:scroll}")
```

Raw Data
======================================

Inputs {.sidebar data-width=320}
-------------------------------------
```{r raw_data_input}
strong("Raw Data Fields for Filtered Data")

# Raw data columns to display
em(tags$a(href="https://www.waterqualitydata.us/portal_userguide/#WQPUserGuide-Table5", target="_blank", "Click for Variable Definitions"))
    renderUI({
      checkboxGroupInput("sel_RawFilteredDataCols",
                       label = h6("Raw data fields (columns) to display: "),
                       choices = sort(names(rv$dat)),
                       selected = c("OrganizationFormalName", "MonitoringLocationIdentifier", "CharacteristicName", "ActivityTypeCode", "ActivityStartDate", "ResultDetectionConditionText", "ResultMeasureValue", "ResultStatusIdentifier", "ResultCommentText")
                     )
      })
```

Raw Data
-------------------------------------

### Raw Data

<center>*Raw data fields from Water Quality Portal, for selected characteristics (see left sidebar for characteristics to choose from)*</center>

```{r raw_data}
output$table_raw_filtered <- DT::renderDT({
  # FuncOrderCheck(import = TRUE, filter_internal = TRUE, filter_external = FALSE, plot = FALSE)
  shiny::req(!is.null(rv$dat), !is.null(rv_param_temp$subDat), !is.null(rv_param_temp$subDatTypes))

  DT::datatable(
    rv_param_temp$subDat %>%
      {if(!is.null(input$sel_RawFilteredDataCols)) dplyr::select(., input$sel_RawFilteredDataCols) else dplyr::select(., OrganizationFormalName, MonitoringLocationIdentifier, CharacteristicName, ActivityTypeCode, ActivityStartDate, ResultDetectionConditionText, ResultMeasureValue, ResultStatusIdentifier, ResultCommentText)},
    filter = "top",
    rownames = FALSE,
    selection = "none",
    options = list(
      pageLength = 10,
      lengthMenu = c(5, 10, 15, 20),
      columnDefs = list(list(className = "dt-center", targets = "_all"))))
})

DTOutput("table_raw_filtered")
tags$style("#table_raw_filtered{height:100vh;overflow-x:scroll;overflow-y:scroll}")
```

Troubleshooting & FAQ's
====================================== 

TROUBLESHOOTING
* I could not import data from web services (import aborted)
* Some of the data from WQP were not in the imported data file
* I found a bug in the dashboard! How do I report it?
* I found a mistake in the data--how do I report it?

FAQ's

* Where do the data come from?
* What is a water quality "characteristic set"?
* How can I set custom seasons if I don't want to use calendar seasons?
* How can I export figures and tables from the dashboard?
* Mann Kendall calcs--how are they done? What criteria for pre-checking the data? Are they reliable?
* How were default threshold limits determined?
https://www.epa.gov/wqs-tech/state-specific-water-quality-standards-effective-under-clean-water-act-cwa#tb4
* How to display categorical parameters with colors
* How to upload my own threshold limits?
* Can I set threshold limits calculated over multiple days, etc.?
* Can I download the dashboard to my own computer?
* GitHub link and contact email for questions, suggestions, reporting bugs